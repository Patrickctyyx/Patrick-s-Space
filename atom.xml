<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2017-12-03T03:29:31.421Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>首次接触智能合约遇到的坑</title>
    <link href="https://blog.patrickcty.cc/2017/12/03/%E9%A6%96%E6%AC%A1%E6%8E%A5%E8%A7%A6%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2017/12/03/首次接触智能合约遇到的坑/</id>
    <published>2017-12-03T03:26:06.000Z</published>
    <updated>2017-12-03T03:29:31.421Z</updated>
    
    <content type="html"><![CDATA[<p>在很多的教程中，都是使用如下方法来编译 sol 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contract = eth.compile.solidity(contractSource).test</div></pre></td></tr></table></figure>
<p>但这样会报错：</p>
<blockquote>
<p>Error: The method eth_getCompilers does not exist/is not available</p>
</blockquote>
<p>原因在于在最新的 API 中这个方法已经被抛弃了，因此我们只能手动编译代码再创建一个合约类了。</p>
<p>编译的方法可以直接用 solc 命令来编译，不过直接在 <a href="https://ethereum.github.io/browser-solidity/" target="_blank" rel="external">remix</a>——可以看做一个在线的 Solidity IDE 中编译会比较方便。</p>
<p>编译之后记录下 abi 以及编译后的二进制代码，然后使用下面语句初始化智能合约类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yourContract = web3.eth.contract(your_abi)</div></pre></td></tr></table></figure>
<p>再用智能合约类来创建一个智能合约的实例并且部署到区块链上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var ss = browser_ballot_sol_smartsponsorContract.new(</div><div class="line">   _benefactor,  // 接受钱的人</div><div class="line">   &#123;</div><div class="line">     from: therunner,  // 智能合约发起者 </div><div class="line">     data: theBinaryCode</div><div class="line">     gas: &apos;4700000&apos;  // 需要的手续费</div><div class="line">   &#125;, function (e, contract)&#123;</div><div class="line">    console.log(e, contract);</div><div class="line">    if (typeof contract.address !== &apos;undefined&apos;) &#123;</div><div class="line">         console.log(&apos;Contract mined! address: &apos; + contract.address + &apos; transactionHash: &apos; + contract.transactionHash);</div><div class="line">    &#125;</div><div class="line"> &#125;)</div></pre></td></tr></table></figure>
<p>之后就只需要使用 <code>loadScript</code> 来加载出合约了。</p>
<p>注意：当合约已经被部署到区块链上就不能再修改了，如果要再次访问就要通过 abi 与 address 了，如果不记得这些的话就无法再次访问到合约了。</p>
<h2 id="无法正常连接"><a href="#无法正常连接" class="headerlink" title="无法正常连接"></a>无法正常连接</h2><p><a href="http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum" target="_blank" rel="external">在之前的教程</a>中我们要使用 <code>geth attach</code> 命令来连接到相应的网络中，但是直接使用这个命令的话会提示无法找到 ipc 文件。</p>
<p>报错的原因在于直接使用这条命令连接的默认的公有链，但是我们想连接的是自己定义的私有链，因此我们要用私有链接的 ipc 来进行连接。</p>
<p>首先要启动我们的私有连，在启动之后会有如下的提示信息：</p>
<blockquote>
<p>IPC endpoint opened: /Users/patrick/Music/BlockChain/data/geth.ipc<br>Welcome to the Geth JavaScript console!</p>
<p>instance: Geth/v1.7.2-stable-1db4ecdc/darwin-amd64/go1.9<br>coinbase: 0xea21220a7ab78b50107734d7a4a6ca19cc39f595<br>at block: 139 (Fri, 01 Dec 2017 23:55:34 CST)<br> datadir: /Users/patrick/Music/BlockChain/data<br> modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</p>
</blockquote>
<p>这里第一行的 ipc 就是我们所需要的私有链的地址，然后使用如下命令就可以连接上私有链了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; geth attach ipc:/the/path/of/the/ipc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多的教程中，都是使用如下方法来编译 sol 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术-智能合约-以太坊（译文修改版）</title>
    <link href="https://blog.patrickcty.cc/2017/12/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%88%E8%AF%91%E6%96%87%E4%BF%AE%E6%94%B9%E7%89%88%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/12/03/区块链技术-智能合约-以太坊（译文修改版）/</id>
    <published>2017-12-03T03:24:20.000Z</published>
    <updated>2017-12-03T03:25:16.397Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅仅是出于学习的目的，对 King Wang 的译文中的代码部分根据当前版本的工具进行了更新。</p>
<hr>
<p>本文征得IBM的Glynn Bird同意翻译发表。虽然文章没有很深的理论，但是它用简洁的语言描述了区块链技术，智能合约，以及以太坊。文章用了一个可以运行的慈善募捐实例，把以太坊最核心的功能做了演示。</p>
<hr>
<p>区块链(BlockChain)技术吸引了大量的关注，原因不仅是它作为账本来纪录交易，成为加密货币(例如比特币)的引擎；更重要的是，它可以封装代码和数据，成为“智能合约”(Smart Contract)。本文介绍开源区块链技术的一种：以太坊(Ethereum), 并且以慈善募捐为例构建一个智能合约，来演示这种技术的强大之处。</p>
<h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><p>区块链是一种数据结构，把数据按时间顺序存储在可以无限伸长的链表中，就像一个账本。区块链数据结构通过分布式，无中心“主”节点，点对点的计算机网络来维护。链表中的每个区块包含一定数量的交易，交易代表数据库状态的改变，例如，钱从一个帐号转到另一个。交易由网络中的多个节点验证，并且最终存储在区块链的区块里面。每个区块包含一个签名哈希(Signed Hash)，包含的是链表中前一个区块的内容。遍历整个区块链可以验证：某个区块的哈希确实是存储在链表中后一个区块里。区块链用图来表示是这样子的：</p>
<p>The Genesis Block是最原始的区块。H()是哈希。Transaction是交易。Time是时间轴，从原始区块链到无限。</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/56f449a7d8e9486784757e9ddc7294d6.png" alt="区块链结构"></p>
<p>区块链包含一系列价值的转移，从一个地址转到另一个。一个地址代表系统中唯一的一个帐号。地址实际上是一个公钥，它的对应私钥属于创建账号的那个用户。没有用账户的私钥做数字签名，价值就不能从那个账户中转移。</p>
<p>在加密保护交易的同时，区块链还提供数据库状态的分布共识。它保证价值转移要么发生一次，要么不发生。应用开发人员可以放心：因为数据一旦存储，就不能修改，可以信赖。区块链网络抽取一个计算机节点，在区块链中产生下一个区块，这个节点要花费大量的算力解决一个数学任务，这个节点是事先未知的。这个节点找到了问题的解答，可以命名下一个区块并发布，网络中的其它节点验证这个发布的区块。由于证明了工作量(Proof of Work)， 赢得发布的节点得到两种奖励：获得新铸成的加密货币，以及从创建交易的一方收取费用。这个过程称为“挖矿”，它的目的是：</p>
<ol>
<li>铸成新的加密货币，而产生货币的速率是受严格控制的</li>
<li>奖励“矿工”，“矿工”验证了交易以及在网络中达成共识</li>
</ol>
<p>实践中，有非常快的特殊硬件，挖矿就有优势，所以就有了“军备竞赛”：矿工们采用越来越多的硬件，来维持同样的获取货币的速率。</p>
<p>比特币是最有名的区块链的实用例子。比特币是可以交换真实货币的加密货币。它可以通过区块链交易，在比特币账号(钱包)之间转移。本文写作时，比特币点对点网络有7000个节点。</p>
<h2 id="以太坊和智能合约"><a href="#以太坊和智能合约" class="headerlink" title="以太坊和智能合约"></a>以太坊和智能合约</h2><p>区块链吸引应用开发人员的主要的性质有：</p>
<ol>
<li>区块链由别人运营。如果你的应用把数据存在大家都用的区块链，它就不需要为数据提供存储机制。区块链中的节点提供存储有激励：收交易费和有机会铸新币。</li>
<li>区块链提供分布共识机制，你自己做很难。</li>
<li>区块链为用户提供匿名机制。一个账号身份标识(ID)是个公钥,它不一定和人直接相关。</li>
<li>“价值”可以从一个账号转移到另一个，但是费用要小于传统的真实货币转账机制。</li>
<li>如果某个区块链受信赖，那么存储在那个区块链的交易也受信赖。</li>
</ol>
<p>以太坊采用区块链的原理，又增加了在区块链上创建智能合约：智能合约是一种应用，它能保存价值，存储数据，封装代码，执行计算任务。类似比特币，以太坊也含有货币，称为以太(ether)。以太是计算机节点挖出来的，由节点验证交易，交易存储在分布共识的区块链中。以太可以在账户(公钥)之间以及智能合约之间转移。</p>
<p>智能合约允许匿名的几方进入约束协议，每个参与方对交易完全知情。价值可以在账户间转移，或者放在智能合约中的第三方托管（escrow ）。由于合约就是代码，开发者想做什么应用，就能做得出，你的想象力是唯一的限制。</p>
<h2 id="智能合约的例子：智能赞助-smartSponsor"><a href="#智能合约的例子：智能赞助-smartSponsor" class="headerlink" title="智能合约的例子：智能赞助(smartSponsor)"></a>智能合约的例子：智能赞助(smartSponsor)</h2><p>在本文的剩余部分，我们构建一个智能合约，它可以让持有账户的用户做以下互动:</p>
<ol>
<li>一个慈善机构搞募捐，称为受益者thebenefactor</li>
<li>一个赞助实施方为这个慈善机构募捐，称为实施者therunner</li>
<li>想要提供赞助的用户，称为赞助者thesponsor</li>
<li>一个以太坊区块链的挖矿节点，验证交易，称为矿工theminer</li>
</ol>
<p>我们的称为智能赞助(smartSponsor)的合约(contract)是:</p>
<ol>
<li>实施者therunner通过一个募捐活动为慈善机构募捐</li>
<li>构建合约时，实施者therunner命名接受募捐的受益者thebenefactor</li>
<li>实施者therunner然后邀请用户提供赞助，用户调用智能合约的函数(function), 这个函数的功能是从赞助者thesponsor的账号转移以太到合约(contract)中，这些以太沉淀在合约中，直到有回调发生</li>
<li>在合约的整个生命周期，各方都可以看到谁是受益者thebenefactor，募到了多少以太，从谁哪儿募到(当然赞助者thesponsor可以匿名)</li>
</ol>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/eb0bdd5098014980a8bcf3c24cc3ba94.png" alt="合约模型"></p>
<p>合约定了以后，两种现象必有其一：</p>
<p>1.募捐照计划实施，实施者指示合约把全部募捐转移给受益者</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/69ad085d0f94498d8d4e70a7be0be2f6.png" alt="合约模型2"></p>
<p>2.因为某种原因募捐实施不了，实施者指示合约把赞助者承诺的募捐退还</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/8fb34f670a0447f581c0b675d5651929.png" alt="合约模型3"></p>
<p>以太坊允许智能合约用代码定义，代码使用一种叫Solidity的编程语言。这是一种类似Java的语言。合约就像Java类，区块链交易存储在成员变量中，可以调用合约的方法来查询合约，或者改变合约的状态。由于区块链的拷贝分布在网络中所有的节点，任何人可以查询合约来获取合约中的公有信息。</p>
<p>我们的合约会包含以下方法：</p>
<ol>
<li>smartSponsor –合约的构造器。它初始化合约的状态。合约的构建者命名账户的地址，这个账户会在合约提款时得益。</li>
<li>pledge –可以被任何捐赠以太的赞助者调用。赞助者可以提供支持募捐的信息，但这个不是必需的。</li>
<li>getPot –返回合约中当前的以太总量。</li>
<li>refund –把承诺的募捐退还给赞助者。只有合约的拥有者能够调用这个方法。</li>
<li>drawdown –把合约中的全部募捐转移到受益者账户。同样，只有合约的拥有者能够调用这个方法。</li>
</ol>
<p>我们的想法是合约要有约束：如果赞助者把以太转移到合约，除非整个合约退回，否则赞助者不能取回。如此，所有的数据都公开可取，意思是任何能够访问以太坊的人，通过合约的代码，能够看到谁设置了合约，谁是受益者，谁承诺了哪一笔捐赠。</p>
<p>重要的是，所有改变合约状态的操作(构建，承诺，退还，或者把合约中的全部募捐转移到受益者账户)都需要在区块链中创建交易。这就意味着，交易被“挖矿”和区块被存储以前，数据还没有被存储。有些操作只是读取已经存在的合约状态(getPot或者读取公共成员变量)，这些操作不需要挖矿。这点重要而微妙：写操作很慢(我们必须等到挖矿完成)。或许写操作结果最终进不了区块链(如果你的代码抛出一个异常或者有其他的错误)，需要调用者给矿工干活的激励。这在以太坊术语中称为gas。所有写操作需要支付gas来改变区块链的状态。</p>
<p>我们有幸不需要加入太坊网络和购买以太，就能使用相同的软件，配置一个本地测试区块链，运行一个矿工来产生自己所谓的以太。这样我们不用浪费真的以太，来测试我们的代码。</p>
<h2 id="Solidity-代码"><a href="#Solidity-代码" class="headerlink" title="Solidity 代码"></a>Solidity 代码</h2><p>这里是用Solidity语言写的我们的智能合约的全部代码：（注：这是修改后的代码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line">// Smart contract to allow someone to organise a sponsored event for charity</div><div class="line">// Glynn Bird - 2016</div><div class="line"></div><div class="line">contract smartSponsor &#123;</div><div class="line">  address public owner;</div><div class="line">  address public benefactor;</div><div class="line">  bool public refunded; </div><div class="line">  bool public complete;</div><div class="line">  uint public numPledges;</div><div class="line">  struct Pledge &#123;</div><div class="line">    uint amount;</div><div class="line">    address eth_address;</div><div class="line">    bytes32 message;</div><div class="line">  &#125;</div><div class="line">  mapping(uint =&gt; Pledge) public pledges;</div><div class="line">  </div><div class="line">  // constructor</div><div class="line">  function smartSponsor(address _benefactor) public &#123;</div><div class="line">    owner = msg.sender;</div><div class="line">    numPledges = 0;</div><div class="line">    refunded = false;</div><div class="line">    complete = false;</div><div class="line">    benefactor = _benefactor;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // add a new pledge</div><div class="line">  function pledge(bytes32 _message) public payable &#123;</div><div class="line">    if (msg.value == 0 || complete || refunded) revert();</div><div class="line">    pledges[numPledges] = Pledge(msg.value, msg.sender, _message);</div><div class="line">    numPledges++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getPot() public constant returns (uint) &#123;</div><div class="line">    return this.balance; </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // refund the backers</div><div class="line">  function refund() public &#123;</div><div class="line">    if (msg.sender != owner || complete || refunded) revert();</div><div class="line">    for (uint i = 0; i &lt; numPledges; ++i) &#123;</div><div class="line">      pledges[i].eth_address.transfer(pledges[i].amount);</div><div class="line">    &#125;</div><div class="line">    refunded = true;</div><div class="line">    complete = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // send funds to the contract benefactor</div><div class="line">  function drawdown() public &#123;</div><div class="line">    if (msg.sender != owner || complete || refunded) revert();</div><div class="line">    benefactor.transfer(this.balance);</div><div class="line">    complete = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Pledge结构描述一个捐赠，记录赞助者的账号，赞助值，和一个消息字符串</li>
<li>pledges数组记录一组Pledge</li>
<li>所有contract的成员变量都是公共的，因此它们的getter是自动产生的<br>有些函数调用throw来避免在出错时，数据被存储到区块链<br>请注意，代码没有提及交易，区块，gas，或者区块链以及加密货币的任何术语。代码仅仅存储成员变量的状态。以太坊仅仅创建了必要的交易，提交给网络验证(本例采用了我们的测试网络)，然后存储到区块链。所有复杂的东西，都避免让我们看到。结果我们的代码很少(50行)，又容易理解。</li>
</ul>
<p>这个很重要，因为智能合约就是信赖的共享；合约中的所有参与方应该清楚他们的承諾，募捐去了哪里，谁可以做哪些操作。代码越简单，越容易验证合约是否值得信赖。</p>
<h2 id="运行智能合约"><a href="#运行智能合约" class="headerlink" title="运行智能合约"></a>运行智能合约</h2><p>要运营合约，先要把以太坊跑起来。我的Ubuntu服务器安装指南在<a href="https://github.com/glynnbird/smartsponsor。" target="_blank" rel="external">https://github.com/glynnbird/smartsponsor。</a> 我使用的是IBM的Bluemix虚拟机(译注：这个不是必须的)，再用apt-get加些需要的包。</p>
<p>假定你根据我的安装指南，在你的测试网络创建了4个以太坊账号，以及配置了一个挖矿进程， 我们可以拷贝smartSponsor代码，在以太坊控制台执行（也就是说打开了两个窗口，一个用来挖矿另一个执行导入合约的代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; git clone https://github.com/glynnbird/smartsponsor.git  // 注：代码有修改</div><div class="line">&gt; cd smartsponsor</div><div class="line">&gt; geth attach</div></pre></td></tr></table></figure>
<p>从geth控制台，执行和以太坊API交互的JavaScript命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; loadScript(&quot;./smartsponsor.js&quot;)</div><div class="line">Contract transaction send: TransactionHash: 0xe797ce5c1e5eeaae6e4bd09ad6564f9deba1beeeb7f09b6c16eec728584e370c waiting to be mined...</div><div class="line">true</div><div class="line">&gt; Contract mined! Address: 0x15590c0417f6421fd35e113db0fdb2055df2344b</div><div class="line">[object Object]</div></pre></td></tr></table></figure>
<p>其中 JavaScript 文件修改成了<a href="https://www.zybuluo.com/PatrickCtyyx/note/972386" target="_blank" rel="external">这篇文章</a>的情况。</p>
<p>smartsponsor.js文件创建了一些变量，它们是我们创建的4个以太坊坊账号的地址(theminer, therunner, thebenefactor, thesponsor),这样接下来的代码片段中，谁做了什么，就容易理解了。该文件还包含一系列的指令，用来编译Solidity源码，构建smartSponsor合约，产生therunner合约实例，确保合约的受益者是thebenefactor。</p>
<p>直到交易被挖矿了，合约才变活。这个需要几秒或几分钟，取决于运行计算机的速度。让我们来观察一下合约（合约赋给了变量ss）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; ss</div><div class="line">&#123;</div><div class="line">  address: &quot;0xe021f45922e141f5e17d05a4b2721ec972065960&quot;,</div><div class="line">  transactionHash: &quot;0x77ba5bc77f0a62888c08084a7c00cf00b6cc024f88f988e9daada751788c8693&quot;,</div><div class="line">  allEvents: function(),</div><div class="line">  benefactor: function(),</div><div class="line">  complete: function(),</div><div class="line">  drawdown: function(),</div><div class="line">  getPledge: function(),</div><div class="line">  getPot: function(),</div><div class="line">  numPledges: function(),</div><div class="line">  owner: function(),</div><div class="line">  pledge: function(),</div><div class="line">  refund: function(),</div><div class="line">  refunded: function()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到合约有一个address，意味着它能收发以太值，以及一个transactionHash，用它来找到区块链中的位置。公共的，可对合约调用的函数也列出了。现在让我们调用几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; ss.benefactor()</div><div class="line">&quot;0x63de8807ac0bd63be460be0de250749c4df1dcb0&quot;</div><div class="line">&gt; ss.owner()</div><div class="line">&quot;0x458305055882d53663b41a00eebd0b657469843f&quot;</div><div class="line">&gt; ss.getPot()</div><div class="line">0</div><div class="line">&gt; ss.numPledges()</div><div class="line">0</div><div class="line">&gt; ss.complete()</div><div class="line">False</div></pre></td></tr></table></figure>
<p>我们可以看到合约的拥有者和受益者是不同的账号(分别是therunner和thebenefactor)，合约的状态初始化为没有募捐和赞助。从自己的区块链拷贝做读操作，是免费的，所以我们不需要提供gas。</p>
<p>接下来我们寄给thesponsor账号一些钱，原先账号是没有以太的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(thesponsor,&quot;password&quot;);</div><div class="line">&gt; eth.sendTransaction(&#123;from: theminer, to: thesponsor, value: 100000000000000000&#125;);</div><div class="line">&quot;0xd4fc641311e31abb6546c3503c367c6ac971b0ad9cb4bcd4c56597e3b98d6d7a&quot;</div><div class="line">&gt; eth.getBalance(theminer);</div><div class="line">4.9524805801917e+22</div><div class="line">&gt; eth.getBalance(thesponsor);</div><div class="line">100000000000000000</div></pre></td></tr></table></figure>
<p>接下来认证thesponsor用户，给我们的智能合约赞助一些钱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(thesponsor,&quot;password&quot;);</div><div class="line">true</div><div class="line">&gt; ss.pledge(&quot;Good luck with the run!&quot;, &#123;from: thesponsor, value: 10000000, gas: 3000000&#125;);</div><div class="line">&quot;0xc0880c4151946014389e135bcbefe39fb8f786e9e3e0ce077fa5f967e2a31ab3&quot;</div></pre></td></tr></table></figure>
<p>价值参数是我们希望转移到合约的以太数量。10000000似乎很大，但单位是wei。1个以太有1000000000000000000个wei！</p>
<p>返回值是交易标识。我们必须等到交易存储到区块链，才能看到合约状态改变了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; ss.getPot()</div><div class="line">10000000</div><div class="line">&gt; ss.numPledges()</div><div class="line">1</div><div class="line">&gt; ss.pledges(0)</div><div class="line">[10000000, &quot;0x225905462cf12404757852c01edfd2ec0bf0dbe9&quot;, &quot;0x476f6f64206c75636b2077697468207468652072756e21000000000000000000&quot;]</div></pre></td></tr></table></figure>
<p>调用pledges(0)返回第一个捐赠pledge，包含它的价值，赞助者的地址，和消息(以一串字节表示).我们可以不断地调用pledge函数来增加捐赠，并观察pot变大。在7个赞助者捐赠以后，我们有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; ss.getPot()</div><div class="line">70000000</div></pre></td></tr></table></figure>
<p>请注意，合约得到了赞助者承诺的全部以太数量，但是赞助者的账号被扣除了比承诺稍多一点的价值。为什么？因为调用pledge函数的操作，必须提供gas作为动力。<br>当实施者准备完成合约，只需调用drawdown函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(therunner,&quot;password&quot;);</div><div class="line">true</div><div class="line">&gt; ss.drawdown(&#123;from: therunner, gas:3000000&#125;);</div><div class="line">&quot;0x082424d8057b8c250f8b86cda05211628bb3bae513ce27bf6194445ae035a3c4&quot;</div></pre></td></tr></table></figure>
<p>合约挖矿完成后，我们应该看到受益者的账号收到了合约的捐赠数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getBalance(thebenefactor);</div><div class="line">70000000</div><div class="line">&gt; ss.getPot()</div><div class="line">0</div></pre></td></tr></table></figure>
<h3 id="补充：在另一个窗口中打开智能合约："><a href="#补充：在另一个窗口中打开智能合约：" class="headerlink" title="补充：在另一个窗口中打开智能合约："></a>补充：在另一个窗口中打开智能合约：</h3><p>如果想在另一个窗口中打开此智能合约则需要记录下合约的 abi 以及 address:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; abi = your_abi</div><div class="line">&gt; sample = eth.contract(abi)</div><div class="line">&gt; ss2 = sample.at(&quot;your_address&quot;)</div><div class="line">&gt; ss2.getPot</div><div class="line">0</div></pre></td></tr></table></figure>
<p>智能合约在合约里的第三方托管记录多个捐赠，要么转移到受益者，要么退还给赞助者。代码确保只有合约的创建者可以退还捐赠，或者全部转移给受益者，并且防止合约完成后再加捐赠。整个过程中，合约的状态可以被各方查询，这些都包含在50行代码里面！</p>
<p>用geth行命令工具执行的命令实际上是Javascript语句。你用自己的客户端代码同样可以调用远端API,和真实(或测试)网络进行交互。这样，创建基于互联网的智能合约前端就很简单。</p>
<p>你用Mist浏览器可以创建帐户，查看和操作合约，就像一个智能合约的应用商店。Mist设想了很多计划，但目前它是一个相对简单的钱包应用，以及合约浏览器。</p>
<h2 id="区块链仅仅是一个分布式数据库？"><a href="#区块链仅仅是一个分布式数据库？" class="headerlink" title="区块链仅仅是一个分布式数据库？"></a>区块链仅仅是一个分布式数据库？</h2><p>区块链是一种按时间顺序存储数据的账本，它是跨越多个结点的分布式数据库。但和Cloudant分布式数据库的意义不同：它并不是把数据分割成片，使工作量散布，从而每片就能搞定一部分。它的网络中，所有节点必须处理所有的数据变化。还有，挖矿的节点执行工作量证明(proof-of-work)，来证明节点有资格实施所预计的改变，这个造成写数据的过程极度缓慢，以太坊每秒只能处理20-30个交易(不是每个用户20-30个交易，而是全部区块链)。</p>
<p>以太坊不仅是一个数据仓库。它增加了新的功能：在区块链中封装代码和数据。这样参与各方可以确信一个合约能够说到做到。与签过名的纸上合约，律师，公证，银行，保险，清算相比，大有不同。</p>
<h2 id="区块链和智能合约能做什么？"><a href="#区块链和智能合约能做什么？" class="headerlink" title="区块链和智能合约能做什么？"></a>区块链和智能合约能做什么？</h2><p>以太坊只是智能合约平台的一种，用它可以构建基于区块链的应用。最合适的用例有：</p>
<ul>
<li>从一方转移价值到另一方</li>
<li>一方或几方需要匿名</li>
<li>价值必须存储在合约本身，并且存储一段时间</li>
<li>希望避免转移真实货币产生的交易费用 需要建立共识 </li>
<li>希望显示公开性，把状态存储在公共域</li>
<li>需要确保物理或虚拟材料的来源和真实性</li>
</ul>
<p>马上想到的应用有：拍卖，借贷，遗嘱，注册，众筹，股权，和投票。</p>
<p>从金钱和计算角度看，写操作是很贵的，所以智能合约多用在写操作少，但是数据价值高的应用。尽管读操作是免费的，只存在一些简单的查询操作。你可以给存储的数据加索引，但还不像一般的数据库，它不存在查询语言，也不存在抽取或聚合数据的方式。</p>
<p>区块链还有另外一些缺点。所有网络中的参与方要存储所有的区块，数据不是分割成可以分别搞定的片段，所以每个节点必须存储整个数据库，并且处理每一个变化。用工作量证明模型，在网络中分布信赖，是一种聪明的迂回解决方案，但是实际情况下，要用千万个节点消耗能量来证明节点值得信赖。最后一点，以太的价值，就像比特币，买卖受投机影响，使得以太的金融价值不稳定。以太坊在发展规划中有性能提升，可扩展性，替换工作量证明，但是在笔者写此文时，它们还只是愿景。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p>中文原文：<a href="http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum" target="_blank" rel="external">http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅仅是出于学习的目的，对 King Wang 的译文中的代码部分根据当前版本的工具进行了更新。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文征得IBM的Glynn Bird同意翻译发表。虽然文章没有很深的理论，但是它用简洁的语言描述了区块链技术，智能合约，以及以太坊。文章用了一个可以运
    
    </summary>
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>Vue与API请求遇到的坑</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/Vue%E4%B8%8EAPI%E8%AF%B7%E6%B1%82%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/Vue与API请求遇到的坑/</id>
    <published>2017-11-07T11:18:51.000Z</published>
    <updated>2017-11-07T11:19:49.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>最近在写比赛项目 TeamSeeker 的代码，后台写得差不多了，于是乎决定写一下网页前端来请求 API，顺便再次测试一下后台的合理性，同时也接触一下一直都想尝试的 Vue。只是没想到居然会遇到这么多坑。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="初始化-Vue-项目"><a href="#初始化-Vue-项目" class="headerlink" title="初始化 Vue 项目"></a>初始化 Vue 项目</h3><p>本来只是准备写单个的 HTML 来组织成前端的，后来想来想去还是跟着教程用 Webpack 来初始化一个比较大的项目。</p>
<p>但是项目是成功初始了，但是在引用第三方的组件的时候，明明已经使用 npm 安装了但是就是引用不了 CSS。</p>
<p>去网上找了一圈发现是没有在项目的配置文件中对这些文件类型进行配置，然而试了半天配置的还是不成功……</p>
<p>最后发现了一个简单的方法，就是在用 npm 安装模块的时候使用 -S 参数，这样就会自动保存在配置中了。这个参数表示保存的意思，等同于 <code>--save</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i materialize-css -S</div></pre></td></tr></table></figure>
<h3 id="发送请求时候的跨域问题"><a href="#发送请求时候的跨域问题" class="headerlink" title="发送请求时候的跨域问题"></a>发送请求时候的跨域问题</h3><p>因为使用的是前后端分离的设计思想，因此难免会产生跨域问题。其实这个问题我之前遇到过，当时是直接在返回的内容中带上 <code>Access-Control-Allow-Origin</code> 这个请求头。</p>
<p>不过坑爹的是，在有的时候，在发送跨域请求之前，浏览器会发送 OPTIONS 请求来检查服务器有没有返回 <code>Access-Control-Allow-Origin</code> 这个请求头从而判断服务器是否支持跨域。于是问题就来了，因为我根本没有定义这个方法，因此也自然不会返回这个请求头了，于是就产生了跨域的问题……</p>
<p>不过这个问题在 Google 上找到了答案，具体原理就是在服务器自定义 Response 类，使得在每次请求后都返回所需要的请求头，这样就可以解决这个问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyResponse(Response):</div><div class="line">    def __init__(self, response=None, **kwargs):</div><div class="line">        kwargs[&apos;headers&apos;] = &apos;&apos;</div><div class="line">        headers = kwargs.get(&apos;headers&apos;)</div><div class="line">        # 跨域控制</div><div class="line">        origin = (&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</div><div class="line">        methods = (&apos;Access-Control-Allow-Methods&apos;, &apos;HEAD, OPTIONS, GET, POST, DELETE, PUT&apos;)</div><div class="line">        if headers:</div><div class="line">            headers.add(*origin)</div><div class="line">            headers.add(*methods)</div><div class="line">        else:</div><div class="line">            headers = Headers([origin, methods])</div><div class="line">        kwargs[&apos;headers&apos;] = headers</div><div class="line">        return super().__init__(response, **kwargs)</div></pre></td></tr></table></figure>
<p>然后在 <code>create_app</code> 里面使用这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.response_class = MyResponse</div></pre></td></tr></table></figure>
<p>原文参考<a href="https://blog.zengrong.net/post/2615.html" target="_blank" rel="external">这个博客</a>。</p>
<p>顺便一提，在解决这个问题的时候还出现了一个问题，那就是在请求第二页的时候不管后端前端怎么改都得不到正确的结果，结果找了半天发现是并没有第二页的内容……真的是智障了……</p>
<h3 id="使用-axios-无法将-response-保存下来"><a href="#使用-axios-无法将-response-保存下来" class="headerlink" title="使用 axios 无法将 response 保存下来"></a>使用 axios 无法将 response 保存下来</h3><p>axios 是 Vue 官方推荐的 AJAX 请求发送的模块，一个 GET 请求是这样发送的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">axios.get(&apos;http://example.com/api/index&apos;, &#123;</div><div class="line">    params: &#123;</div><div class="line">      &quot;page&quot;: page</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">    .then(function (response) &#123;</div><div class="line">      console.log(response);</div><div class="line">    &#125;)</div><div class="line">    .catch(function (error) &#123;</div><div class="line">      console.log(error);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>但是我如果想保存 response 对象到 Vue 的一个对象中（需要使用 this） 来访问，如果直接使用 <code>this.$store.dispatch(&#39;getIndex&#39;, response.data);</code> 是不能保存进去的，原因在于 this 在 axios.get() 函数中也起作用，在函数中的作用域就不是 Vue 的对象了，因此我们要在调用函数之前把 this 赋值给另一个变量，然后再用另一个变量来引用 Vue 的对象的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var _self = this;</div><div class="line">axios.get(</div><div class="line">    ...</div><div class="line">    _this.$store.dispatch(&apos;getIndex&apos;, response.data);</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="数据首次加载"><a href="#数据首次加载" class="headerlink" title="数据首次加载"></a>数据首次加载</h3><p>这个到现在还是不是很清楚，先留个坑。</p>
<h3 id="使用-axios-发送-POST-请求遇到的坑"><a href="#使用-axios-发送-POST-请求遇到的坑" class="headerlink" title="使用 axios 发送 POST 请求遇到的坑"></a>使用 axios 发送 POST 请求遇到的坑</h3><p>继使用 axios 发送 GET 请求遇到坑之后，用 POST 请求又踩到了坑，真的是体验极差啊（哭。</p>
<p>这次又是什么问题呢？那就是：</p>
<blockquote>
<p>Request header field Access-Control-Allow-Headers is not allowed by Access-Control-Allow-Headers</p>
</blockquote>
<p>为什么会出现这个问题呢？又是 OPTIONS 这个磨人的小妖精……StackOverflow 上是这样解释的：</p>
<blockquote>
<p>For cross-domain requests, setting the content type to anything other than application/x-www-form-urlencoded, multipart/form-data, or text/plain will trigger the browser to send a preflight OPTIONS request to the server.</p>
</blockquote>
<p>而 axios 发送 POST 请求的时候默认是用 JSON 作为 Content-Type 来发送了，而这正好不是上面的这些，因此就又要提前发送一次 OPTIONS 请求，而正好我又没有对这个处理……</p>
<p>不过这次就不用改服务器的代码了，axios 官方已经给出了解决方法了，那就是把 Content-Type 设置为 <code>application/x-www-form-urlencoded</code>，然后再对 JSON 数据进行处理，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var qs = require(&apos;qs&apos;);</div><div class="line">axios.post(&apos;http://example.com/api/wxlogin&apos;,    </div><div class="line">    qs.stringify(&#123;</div><div class="line">        js_code: &apos;001U3te40K6KSD1Bpaf40DKAe40U3tel&apos;</div><div class="line">    &#125;)</div><div class="line">)</div><div class="line">    .then(function (response) &#123;</div><div class="line">        console.log(response);</div><div class="line">    &#125;)</div><div class="line">    .catch(function (error) &#123;</div><div class="line">        console.log(&apos;aaa&apos;, error);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>当然这个 qs 模块也是要事先安装的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i qs -S</div></pre></td></tr></table></figure>
<h3 id="使用-font-awesome-但是死活引入不了-CSS"><a href="#使用-font-awesome-但是死活引入不了-CSS" class="headerlink" title="使用 font-awesome 但是死活引入不了 CSS"></a>使用 font-awesome 但是死活引入不了 CSS</h3><p>网站当然少不了图标，一个比较简单好用的方法就是使用 font-awesome 提供的图标，平常我都是使用 CDN 来引入的，但是这个项目结构下好像不适合直接引入，而是应该使用 npm 安装模块。</p>
<p>但是安装之后死活找不到安装好的模块，也就无法引入了。于是不得不去安装 vue-awesome，然而这个的图标死活和文字对齐不了……这个简直不能忍啊，最后不得不又得回到 font-awesome。</p>
<p>又找了一圈之后发现是我安装的方法不对，我一开始是使用下面这个来安装的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i fontawesome -S（不要用这个安装！！！）</div></pre></td></tr></table></figure>
<p>确实提示已经安装成功了，但是不能用。我之后又使用了下面这个来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i font-awesome -S</div></pre></td></tr></table></figure>
<p>加了中间这个短横线之后就可以引入了……虽然我发现安装后的提示都是一样的……简直坑爹啊……还是我大 Python 的 pip 要好用……</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这几天真的踩了超多的坑，简单的一个页面结果写了一周才大概完成……中间的心酸真的是只有自己知道了……</p>
<p>最近一段时间也是事情堆起来了……哎只希望下次驾照考试能顺利一点吧……已经成了我心中的梦魇了……真的很害怕很无助……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;最近在写比赛项目 TeamSeeker 的代码，后台写得差不多了，于是乎决定写一下网页前端来请求 API，顺便再次测试一下后
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Vue" scheme="https://blog.patrickcty.cc/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB一些操作</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/MATLAB%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/MATLAB一些操作/</id>
    <published>2017-11-07T11:17:48.000Z</published>
    <updated>2017-11-07T11:18:24.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="syms"><a href="#syms" class="headerlink" title="syms"></a>syms</h2><p>使用 syms 关键字可以定义自变量，这样就可以写出带 x，y，z 等的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">syms x, y;</div><div class="line"></div><div class="line">y = exp(-2 * x);</div></pre></td></tr></table></figure>
<h2 id="prod"><a href="#prod" class="headerlink" title="prod"></a>prod</h2><p>使用 prod 可以实现矩阵中的元素连乘的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = [3 4 5];</div><div class="line">prod(x)</div><div class="line">&gt;&gt; 120</div></pre></td></tr></table></figure>
<h2 id="循环遍历一个向量"><a href="#循环遍历一个向量" class="headerlink" title="循环遍历一个向量"></a>循环遍历一个向量</h2><p>直接把向量赋值给循环变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = [4 5 6]；</div><div class="line"></div><div class="line">for i = a</div><div class="line">    % disp 为输出语句</div><div class="line">    disp(i);</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="subs"><a href="#subs" class="headerlink" title="subs"></a>subs</h2><p>subs 用来替换。</p>
<p>假设 poly 是一个以 x 为自变量的多项式，如果要计算某个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subs(poly, x, 5)</div></pre></td></tr></table></figure>
<h2 id="在向量中增加元素"><a href="#在向量中增加元素" class="headerlink" title="在向量中增加元素"></a>在向量中增加元素</h2><p>假设 event 是一个向量，如果要增加一个 b 向量在尾部，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event = [event b]</div></pre></td></tr></table></figure>
<h2 id="ezplot"><a href="#ezplot" class="headerlink" title="ezplot"></a>ezplot</h2><p>ezplot 用来画出某个带自变量的表达式的曲线，可以指定自变量的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">% polyresult 为多项式表达式</div><div class="line">ezplot(polyresult, [-1, 1]);</div></pre></td></tr></table></figure>
<h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><p>最基本的画曲线的函数，根据横纵坐标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(x0, errevent, &apos;--&apos;, x0, errcheby);</div></pre></td></tr></table></figure>
<h2 id="figure"><a href="#figure" class="headerlink" title="figure"></a>figure</h2><p>新建一张画布，下一个图就会画在这个画布上了。</p>
<h2 id="hold-on-amp-hold-off"><a href="#hold-on-amp-hold-off" class="headerlink" title="hold on &amp; hold off"></a>hold on &amp; hold off</h2><p>用来把多个曲线画在同一个坐标系中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">figure;</div><div class="line">ezplot(polyresult, [-1, 1]);</div><div class="line">hold on;</div><div class="line">syms x0;</div><div class="line">ezplot(exp(-2 * x0), [-1, 1]);</div><div class="line">hold off;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;syms&quot;&gt;&lt;a href=&quot;#syms&quot; class=&quot;headerlink&quot; title=&quot;syms&quot;&gt;&lt;/a&gt;syms&lt;/h2&gt;&lt;p&gt;使用 syms 关键字可以定义自变量，这样就可以写出带 x，y，z 等的表达式。&lt;/p&gt;
&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="MATLAB" scheme="https://blog.patrickcty.cc/tags/MATLAB/"/>
    
      <category term="数值分析" scheme="https://blog.patrickcty.cc/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据库ROLLUP与CUBE</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93ROLLUP%E4%B8%8ECUBE/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/数据库ROLLUP与CUBE/</id>
    <published>2017-11-07T11:16:27.000Z</published>
    <updated>2017-11-07T11:17:14.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>ROLLUP 和 CUBE 都是用来在差查询结果中生成合计的项目。</p>
<p>这两个关键字需要和 GROUP BY 来一起使用，需要注意的是 GROUP BY 关键字后面可以跟多个列名，这多个列名之间的顺序和输出的顺序是相关的。</p>
<p>ROLLUP 和 CUBE 的操作都要依赖 GROUP BY。</p>
<h2 id="GROUPING"><a href="#GROUPING" class="headerlink" title="GROUPING"></a>GROUPING</h2><p>GROUPING 用来区分是本来内容就是 null 还是是因为 ROLLUP 和 CUBE 而产生的 null 值，如果是后者那么 GROUPING(列名) 返回的结果就是 1，否则则是零。</p>
<p>ROLLUP 统计的时候会默认生成 null，这时候就需要自己填入统计的结果了。</p>
<h2 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h2><p>ROLLUP 产生的合计项目和 GROUP BY 中的多个列名的顺序有关。</p>
<p>ROLLUP 会根据 GROUP BY 的第一个列来进行分组并且输出汇总的内容。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with rollup;</div></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Ann Arbor	MI</div><div class="line">Ann Arbor	ALL</div><div class="line">……省略若干行</div><div class="line">Vacaville	CA</div><div class="line">Vacaville	ALL</div><div class="line">Walnut Creek	CA</div><div class="line">Walnut Creek	ALL</div><div class="line">ALL	ALL</div></pre></td></tr></table></figure></p>
<p>在这里是对应的每个不同的州进行分组，然后对每个组进行汇总，最终对所有的州再进行一次汇总。</p>
<h2 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h2><p>CUBE 产生的合计项目和 GROUP BY 中的多个列名的顺序在某种程度上可以说是无关。</p>
<p>CUBE 产生的结果不仅会产生 ROLLUP 的结果，还会产生 ROLLUP 中没出现的另一种顺序的结果。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with cube;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Berkeley	CA</div><div class="line">Covelo	CA</div><div class="line">Menlo Park	CA</div><div class="line">Oakland	CA</div><div class="line">Palo Alto	CA</div><div class="line">San Francisco	CA</div><div class="line">San Jose	CA</div><div class="line">Vacaville	CA</div><div class="line">Walnut Creek	CA</div><div class="line">ALL	CA</div><div class="line">Gary	IN</div><div class="line">ALL	IN</div><div class="line">Lawrence	KS</div><div class="line">ALL	KS</div><div class="line">Rockville	MD</div><div class="line">ALL	MD</div><div class="line">Ann Arbor	MI</div><div class="line">ALL	MI</div><div class="line">Corvallis	OR</div><div class="line">ALL	OR</div><div class="line">Nashville	TN</div><div class="line">ALL	TN</div><div class="line">Salt Lake City	UT</div><div class="line">ALL	UT</div><div class="line">ALL	ALL</div><div class="line">Ann Arbor	ALL</div><div class="line">Berkeley	ALL</div><div class="line">Corvallis	ALL</div><div class="line">Covelo	ALL</div><div class="line">Gary	ALL</div><div class="line">Lawrence	ALL</div><div class="line">Menlo Park	ALL</div><div class="line">Nashville	ALL</div><div class="line">Oakland	ALL</div><div class="line">Palo Alto	ALL</div><div class="line">Rockville	ALL</div><div class="line">Salt Lake City	ALL</div><div class="line">San Francisco	ALL</div><div class="line">San Jose	ALL</div><div class="line">Vacaville	ALL</div><div class="line">Walnut Creek	ALL</div></pre></td></tr></table></figure></p>
<p>如果忽视输出数据的顺序，那么这个结果相当于两个 ROLLUP 的结果作 UNION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with rollup</div><div class="line">union</div><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by state, city with rollup;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;ROLLUP 和 CUBE 都是用来在差查询结果中生成合计的项目。&lt;/p&gt;
&lt;p&gt;这两个关键字需要和 GROUP BY 来一起使用，需要注意
    
    </summary>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="数据库" scheme="https://blog.patrickcty.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL Server" scheme="https://blog.patrickcty.cc/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序学习</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/微信小程序学习/</id>
    <published>2017-11-07T11:14:01.000Z</published>
    <updated>2017-11-07T11:14:53.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>全局配置文件为 app.json，在项目的根目录中。</p>
<p>配置详情参考<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="external">官方文档</a>。</p>
<p>要注意的是主体页面的颜色要和微信的颜色保持一致为白色，但是状态栏以及标签页这些地方可以是自己喜欢的颜色。</p>
<h2 id="登录状态的维护"><a href="#登录状态的维护" class="headerlink" title="登录状态的维护"></a>登录状态的维护</h2><p>和其他媒介一样，微信小程序本质上是内容的载体，因而我们也要有一个后台服务器来为小程序提供内容。</p>
<p>从小程序登录微信是极其容易的一件事情，但是我们的后台 api 怎么知道用户是不是真的登录了呢？那就要通过微信提供的 api 来验证了。</p>
<p>在微信的 <code>wx.login()</code> api 中，如果成功登录，则会返回一个登录凭证 code，小程序可以把这个 code 传递给 后台服务器，然后后台服务器通过调用微信的验证 api 来测试登录状态，如果成功则会返回 session_key 到后台服务器（这个 session_key 是密钥，不应该传输到小程序客户端）。</p>
<p>而小程序和普通的浏览器不一样，是不能存储 cookie 的，因此 cookie 相关应该存储到服务器中，而服务器应该把存储 cookie 的 key 来返回给小程序，小程序之后就通过这个 key 来向服务器进行请求。</p>
<p>注意这里有两个登录状态，一个是小程序中微信号的登录状态，第二个是服务器中的登录状态。后者是依托于前者，如果前者过期重新登录，则必须要更新服务的的登录状态。</p>
<p>这样设置的好处是控制了服务器的资源不能被随意获取。</p>
<p><a href="http://www.jianshu.com/p/c5f6c98b2685" target="_blank" rel="external">参考资料</a></p>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p><code>wx.getStorageSync(key)</code> 是用来从本地缓存中同步获取指定 key 对应的内容。</p>
<p><code>wx.setStorageSync(key, value)</code> 把 value 存储到相应的 key 对应的内容中，会覆盖掉原来 key 对应的内容。</p>
<p><code>.unshift()</code> Array 的方法，用来在数组的首部添加一个或多个元素，添加几个元素就有几个参数。</p>
<p><code>.map()</code> Array 的方法，用 map 中的函数来处理 Array 中的每个数据。</p>
<p><code>=&gt;</code> 用来定义箭头函数，这个函数表达式的语法比函数表达式短。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 一个参数时圆括号是可选的</div><div class="line">singleParam =&gt; &#123; statements; &#125;</div><div class="line">(singleParam) =&gt; &#123; statements; &#125;</div><div class="line"></div><div class="line">(param1, param2, …, paramN) =&gt; &#123; statements; &#125;</div><div class="line">(param1, param2, …, paramN) =&gt; expression</div><div class="line">// 等价于：(param1, param2, …, paramN) =&gt; &#123; return expression; &#125;</div><div class="line">/* 当删除大括号时，它将是一个隐式的返回值，这意味着我们不需要指定我们返回*/</div><div class="line"></div><div class="line">// 没有参数时必须要使用圆括号</div><div class="line">() =&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h2&gt;&lt;p&gt;全局配置文件为 app.json，在项目的根目录中。&lt;/p&gt;
&lt;p&gt;配置详情参考&lt;a href=&quot;https://mp.we
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="微信小程序" scheme="https://blog.patrickcty.cc/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Consensus Algorithms</title>
    <link href="https://blog.patrickcty.cc/2017/09/27/ConsensusAlgorithms/"/>
    <id>https://blog.patrickcty.cc/2017/09/27/ConsensusAlgorithms/</id>
    <published>2017-09-27T01:34:39.000Z</published>
    <updated>2017-10-04T00:11:35.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PoW-Proof-of-Work"><a href="#PoW-Proof-of-Work" class="headerlink" title="PoW(Proof of Work)"></a>PoW(Proof of Work)</h2><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>PoW is a consensus strategy used in Bitcoin network.</p>
<p>In PoW, each node of the network is calculating a hash value of the constantly changing block header.</p>
<p>The consensus requires that the calculated value must be equal or small than a certain given value.</p>
<p>When one node obtains the relevant value, all other nodes must mutally validated in case of frauds. Then a new block is added to the blockchain.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Bitcoin network regard the blockchain head as the input, including:</p>
<ul>
<li>version number(4 Bytes)</li>
<li>previous block hash(32 Bytes)</li>
<li>Merkle root(32 Bytes, formed by transactions in current block)</li>
<li>timestamp(4 Bytes)</li>
<li>bits(4 Bytes, representing the difficulty of the calculation)</li>
<li>nonce(4 Bytes, a random number, by changing which miners guess the solution)</li>
</ul>
<p>As has been mentioned above, miners changes the value of the nonce(and the timestamp) to guess the solution. And the function that is used to calculate the result is SHA256.</p>
<p>The solution or the target value is controlled by ‘bits’, and here is the computational formula：</p>
<blockquote>
<p>targe value = max target value / bits</p>
</blockquote>
<p>And max target value is a constant value:</p>
<blockquote>
<p>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</p>
</blockquote>
<p>That is to say, the larger the ‘bits’ value is, the harder the target value can be guessed.</p>
<p>Above all, the procedures botcoin miners do to prove their work can be concluded with three steps:</p>
<ul>
<li>generate the Merkle Root Hash using transactions</li>
<li>combine all the fields as the input</li>
<li>change the nonce value in the blockchain head and calculate SHA256(SHA256(Block_Header)), compare it with the target value, if it is smaller then the proof is done</li>
</ul>
<h3 id="Other-PoW-Protocols"><a href="#Other-PoW-Protocols" class="headerlink" title="Other PoW Protocols"></a>Other PoW Protocols</h3><p>PoW needs a lot of computer calculations which is a waste of resources. To take advantage of the loss, some PoW protocols are designed to have some side-applications.</p>
<ul>
<li>Primecoin searches for special prime number chains to be used in mathematical research.</li>
<li>PoB(Proof of Burn) uses bitcoin instead of electricity to mine blocks.(It’s kind of similar to buying a lottery)</li>
</ul>
<h2 id="PoS-Proof-of-Stake"><a href="#PoS-Proof-of-Stake" class="headerlink" title="PoS(Proof of Stake)"></a>PoS(Proof of Stake)</h2><h3 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation"></a>Explanation</h3><p>PoS requires people to prove the ownership of the amount of currency, which means that preople with more currencies is more likely to forge the next block.</p>
<p>To avoid the result that the single richest prople domain the network, solutions are often proposed with the combination of the stake size. </p>
<p>P.S. PoS still has to calculate the hash value.</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>Blackcoin uses a formula that looks for the lowest hash value in combination with the size of the stake.</p>
<p>In peercoin, older and larger sets of coins have a greater probability of mining the next block.</p>
<h2 id="PBFT-Practical-Byzantine-Fault-Tolerance"><a href="#PBFT-Practical-Byzantine-Fault-Tolerance" class="headerlink" title="PBFT(Practical Byzantine Fault Tolerance)"></a>PBFT(Practical Byzantine Fault Tolerance)</h2><h3 id="Explanation-2"><a href="#Explanation-2" class="headerlink" title="Explanation"></a>Explanation</h3><p>PBFT is a replication algorithm to tolerate byzantine faults.</p>
<p>A new block is determined in a round. </p>
<p>In each round, a primary would be selected according to some rules. And it is responsible for ording the transaction.</p>
<p>The whole process could be divided into three phrases: pre-prepared, prepared and commit. In each phrase, a node would enter next phrase if it has received votes from over 2/3 of all nodes.</p>
<p>P.S. PBFT requires that every node is known to the network.</p>
<h2 id="DPoS-Delegated-Proof-of-Stake"><a href="#DPoS-Delegated-Proof-of-Stake" class="headerlink" title="DPoS(Delegated Proof of Stake)"></a>DPoS(Delegated Proof of Stake)</h2><h3 id="Explanation-3"><a href="#Explanation-3" class="headerlink" title="Explanation"></a>Explanation</h3><p>In DPoS, miners get their priority to generate the blocks according to their stake. </p>
<p>Stakeholders elect their delegates to generate and validate a block, which will significantly improve the speed of confirmation.</p>
<p>Besides, the parameters of the network such as block size and block intervals could be tuned by elected delegates.</p>
<p>P.S. DPoS still has to calculate the hash value.</p>
<h2 id="Ripple"><a href="#Ripple" class="headerlink" title="Ripple"></a>Ripple</h2><h3 id="Explanation-4"><a href="#Explanation-4" class="headerlink" title="Explanation"></a>Explanation</h3><p>Ripple is a consensus algorithm that utilizes collectively-trusted subnetworks within the large network.</p>
<p>In this network, nodes are divided into two types:</p>
<ul>
<li>server: participate consensus process</li>
<li>client: only transfer funds</li>
</ul>
<p>In PBFT, nodes have to ask every node, but in Ripple each node only has a Unique Node List(UNL) to query.</p>
<p>When determining whether to put a transaction into the ledger, the server would query the nodes in UNL. If the received agreements have reached 80%, the transaction would be packed into the ledger.</p>
<h2 id="Tendermint"><a href="#Tendermint" class="headerlink" title="Tendermint"></a>Tendermint</h2><h3 id="Explanation-5"><a href="#Explanation-5" class="headerlink" title="Explanation"></a>Explanation</h3><p>In Tendermint, a new node is determined in a round. </p>
<p>A propser would be selected to broadcast an unconfirmed block in this round.</p>
<p>It would be devided into three steps:</p>
<ol>
<li>Prevote </li>
<li>Precommit</li>
<li>Commit</li>
</ol>
<p>Only if the node has received 2/3 or the agreement can it reach the next step. And when the node has received 2/3 of the commits, it accepts the block.</p>
<p>It’s similar to PBFT, but in this method nodes have to lock their coins to become validators.</p>
<p>P.S. Tendermint requires that every node is known to the network.</p>
<h2 id="More-Infomation"><a href="#More-Infomation" class="headerlink" title="More Infomation"></a>More Infomation</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part02" target="_blank" rel="external">PoW</a></li>
<li><a href="http://www.jianshu.com/p/1e2acd3cbd9f" target="_blank" rel="external">PBFT</a></li>
<li><a href="http://blog.csdn.net/lsttoy/article/details/61624287" target="_blank" rel="external">PoW</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PoW-Proof-of-Work&quot;&gt;&lt;a href=&quot;#PoW-Proof-of-Work&quot; class=&quot;headerlink&quot; title=&quot;PoW(Proof of Work)&quot;&gt;&lt;/a&gt;PoW(Proof of Work)&lt;/h2&gt;&lt;h3 id=&quot;Exp
    
    </summary>
    
      <category term="区块链" scheme="https://blog.patrickcty.cc/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://blog.patrickcty.cc/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="算法" scheme="https://blog.patrickcty.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Flask常用扩展用法（二）</title>
    <link href="https://blog.patrickcty.cc/2017/09/23/Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/09/23/Flask常用扩展用法（二）/</id>
    <published>2017-09-23T03:16:56.000Z</published>
    <updated>2017-09-23T03:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-Restful"><a href="#Flask-Restful" class="headerlink" title="Flask-Restful"></a>Flask-Restful</h2><p>具体内容参考之前的<a href="https://blog.patrickcty.cc/2017/08/10/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADRESTfulAPI/">文章</a>。</p>
<h2 id="Flask-Celery"><a href="#Flask-Celery" class="headerlink" title="Flask-Celery"></a>Flask-Celery</h2><p>这个用法比较多，之前的两篇文章也有总结过，可以参考之前的内容：</p>
<ul>
<li><a href="https://blog.patrickcty.cc/2017/09/01/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/">第一篇</a></li>
<li><a href="https://blog.patrickcty.cc/2017/09/03/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/">第二篇</a></li>
</ul>
<h2 id="Flask-Debugtool"><a href="#Flask-Debugtool" class="headerlink" title="Flask-Debugtool"></a>Flask-Debugtool</h2><p>如同这个扩展的名字一样，这个扩展的作用就是为了使调试 Flask 应用变得更加的轻松愉快。</p>
<p>注意：这个扩展只有在配置文件的 Debug = True 的时候才会生效。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_debugtoolbar import DebugToolbarExtension</div><div class="line"></div><div class="line">debug_toolbar = DebugToolbarExtension()</div><div class="line">debug_toolbar.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>默认情况下，Flask Debug Tool 会拦截 HTTP 302 重定向请求，修改配置文件来禁止这个行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEBUG_TB_INTERCEPT_REDIRECTS = False</div></pre></td></tr></table></figure>
<h2 id="Flask-Cache"><a href="#Flask-Cache" class="headerlink" title="Flask-Cache"></a>Flask-Cache</h2><p>一个强大的缓存工具，可以有效减少数据库等的查询次数，从而极大程度加快页面的访问速度。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_cache import Cache</div><div class="line"></div><div class="line">cache = Cache()</div><div class="line">cache.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="配置缓存输出结果"><a href="#配置缓存输出结果" class="headerlink" title="配置缓存输出结果"></a>配置缓存输出结果</h3><p>这里是把结果保存在内存的一个 Python 字典里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CACHE_TYPE = &apos;simple&apos;</div></pre></td></tr></table></figure></p>
<h3 id="缓存函数和视图"><a href="#缓存函数和视图" class="headerlink" title="缓存函数和视图"></a>缓存函数和视图</h3><h4 id="缓存视图函数"><a href="#缓存视图函数" class="headerlink" title="缓存视图函数"></a>缓存视图函数</h4><p>只用在函数上添加一个装饰器就可以缓存这个视图函数的输出结果了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@blog_print.route(&apos;/&apos;)</div><div class="line">@blog_print.route(&apos;/&lt;int:page&gt;&apos;)</div><div class="line">@cache.cached(timeout=60)</div><div class="line">def home(page=1):</div><div class="line">    posts = Post.query.order_by(</div><div class="line">        Post.publish_time.desc()</div><div class="line">    ).paginate(page, 10)</div><div class="line">    recent, top_tags = sidebar_data()</div><div class="line"></div><div class="line">    return render_template(</div><div class="line">        &apos;home.html&apos;,</div><div class="line">        posts=posts,</div><div class="line">        recent=recent,</div><div class="line">        top_tags=top_tags</div><div class="line">    )</div></pre></td></tr></table></figure>
<p>timeout 表示结果缓存的时长，超过这个时长就会再次执行函数取得新的缓存结果。</p>
<h4 id="缓存不带参数的函数"><a href="#缓存不带参数的函数" class="headerlink" title="缓存不带参数的函数"></a>缓存不带参数的函数</h4><p>非视图函数也可以缓存，不过要加入 key_prefix 参数，这个参数用来表示函数的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@cache.cached(timeout=7200, key_prefix=&apos;sidebar_data&apos;)</div><div class="line">def sidebar_data():</div><div class="line">    recent = Post.query.order_by(</div><div class="line">        Post.publish_time.desc()</div><div class="line">    ).limit(5).all()</div><div class="line">    # 下面这个查询不是很理解，join 和 group_by 这两个的用法没怎么接触过</div><div class="line">    top_tags = db.session.query(</div><div class="line">        Tag, func.count(tags.c.post_id).label(&apos;total&apos;)</div><div class="line">    ).join(</div><div class="line">        tags</div><div class="line">    ).group_by(Tag).limit(5).all()</div><div class="line"></div><div class="line">    return recent, top_tags</div></pre></td></tr></table></figure>
<h4 id="缓存带参数的函数"><a href="#缓存带参数的函数" class="headerlink" title="缓存带参数的函数"></a>缓存带参数的函数</h4><p>对于需要接受参数的函数，就不能直接加上装饰器了，不然每次运行的结果都是相同，这时候我们可以使用 memorize 函数来解决这个问题。</p>
<p>memorize 函数不但会储存函数的运行结果，还会储存调用时的参数，括号里面表示的也是缓存的秒数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@staticmethod</div><div class="line">@cache.memoize(60)</div><div class="line">def verify_auth_token(token):</div><div class="line">    s = Serializer(current_app.config[&apos;SECRET_KEY&apos;])</div><div class="line"></div><div class="line">    try:</div><div class="line">        data = s.loads(token)</div><div class="line">    except SignatureExpired:</div><div class="line">        return None</div><div class="line">    except BadSignature:</div><div class="line">        return None</div><div class="line">    user = User.query.get(data[&apos;id&apos;])</div><div class="line">    return user</div></pre></td></tr></table></figure>
<h3 id="使用-redis-作为缓存后端"><a href="#使用-redis-作为缓存后端" class="headerlink" title="使用 redis 作为缓存后端"></a>使用 redis 作为缓存后端</h3><p>redis 我们在 Flask-Celery 里面用到过，用来储存消息队列相关内容，在这里我们也可以利用 redis 来缓存更多的结果。</p>
<p>只用修改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ProdConfig(Config):</div><div class="line">    CACHE_TYPE = &apos;redis&apos;</div><div class="line">    CACHE_REDIS_HOST = &apos;localhost&apos;</div><div class="line">    CACHE_REDIS_PORT = &apos;6379&apos;</div><div class="line">    CACHE_REDIS_PASSWORD = &apos;&apos;</div><div class="line">    CACHE_REDIS_DB = &apos;0&apos;</div></pre></td></tr></table></figure>
<h2 id="Flask-Admin"><a href="#Flask-Admin" class="headerlink" title="Flask-Admin"></a>Flask-Admin</h2><p>强大的管理员管理界面，省去了不少造轮子的功夫。</p>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_admin import Admin</div><div class="line"></div><div class="line">admin = Admin()</div><div class="line">admin.init_app(app)</div></pre></td></tr></table></figure>
<p>初始化之后这个扩展就自动在 localhost:5000/admin 处显示出了相应的管理员页面。</p>
<h3 id="编写基础管理页面"><a href="#编写基础管理页面" class="headerlink" title="编写基础管理页面"></a>编写基础管理页面</h3><p>BaseView 是用来在 admin 的主界面添加相应的视图选项。</p>
<p>现在我们在 localhost:5000/admin 之后添加一个 customview 的选项。例如生成 localhost:5000/admin/customview/ 的路径</p>
<p>由于也要创建视图，所以在视图函数所在的文件/文件夹 里面加入以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask_admin import BaseView, expose</div><div class="line"></div><div class="line">class CustomView(BaseView):</div><div class="line">    @expose(&apos;/&apos;)</div><div class="line">    @login_required</div><div class="line">    @admin_permission.require(http_exception=403)</div><div class="line">    def index(self):</div><div class="line">        return self.render(&apos;admin/custom.html&apos;)</div><div class="line"></div><div class="line">    @expose(&apos;/second_page&apos;)</div><div class="line">    @login_required</div><div class="line">    @admin_permission.require(http_exception=403)</div><div class="line">    def second_page(self):</div><div class="line">        return self.render(&apos;admin/second_page.html&apos;)</div></pre></td></tr></table></figure>
<p>这个类名就是默认的路由的名字（localhost:5000/admin/customview/）了，还可以定义更多的子路由，定义的方法就是使用 expose 装饰器。</p>
<p>注意这里必须要有一个暴露‘/’路由的方法来作为选项的根路径。</p>
<p>为了保持风格的统一性，我们的模板也应该继承 Flask Admin 的默认样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% extends &apos;admin/master.html&apos; %&#125;</div><div class="line">&#123;% block body %&#125;</div><div class="line">    Test custom view.</div><div class="line">    &lt;a href=&quot;&#123;&#123; url_for(&apos;.second_page&apos;) &#125;&#125;&quot;&gt;Link&lt;/a&gt;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure>
<p>基本工作已经做完了，但是要让这些生效，必须在 admin 对象上注册一个 CustomView 的实例，这个是在 create_app 函数中完成的，而不是在 extensions 中。因为渲染管理页面需要用到数据库对象，如果放在 extensions 则可能会发生循环导入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># name 参数用来表示导航条中的文本</div><div class="line">admin.add_view(CustomView(name=&apos;Custom&apos;))</div></pre></td></tr></table></figure>
<h3 id="编写数据库管理页面"><a href="#编写数据库管理页面" class="headerlink" title="编写数据库管理页面"></a>编写数据库管理页面</h3><p>Flask Admin 最强大的地方就是它可以直接管理 SQLAlchemy 模型，让对数据库的操作直接在 GUI 中完成。</p>
<p>完成这样的功能同样也需要在视图函数文件处进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from flask_admin.contrib.sqla import ModelView</div><div class="line">from flask_admin.contrib.fileadmin import FileAdmin</div><div class="line"></div><div class="line">class CustomModelView(ModelView):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>也要在 create_app 的地方注册，这里要把所需要的表注册进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">models = [User, Reminder, Post, Role, Comment, Contact, Tag]</div><div class="line"></div><div class="line">for model in models:</div><div class="line">    # category 参数相同的部分就会放在导航栏的同一个下拉菜单中</div><div class="line">    admin.add_view(CustomModelView(model, db.session, category=&apos;Models&apos;))</div></pre></td></tr></table></figure>
<h3 id="编写文件系统管理页面"><a href="#编写文件系统管理页面" class="headerlink" title="编写文件系统管理页面"></a>编写文件系统管理页面</h3><p>除了直接访问数据库内容，Flask Admin 还可以从网页访问服务器的文件系统。</p>
<p>首先也需要在视图函数文件处进行初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_admin.contrib.fileadmin import FileAdmin</div><div class="line"></div><div class="line">class CustomFileAdmin(FileAdmin):</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<p>然后只需要把 CustomFileAdmin 类注册到 admin 中就可以访问了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">admin.add_view(CustomFileAdmin(</div><div class="line">    os.path.join(os.path.dirname(__file__), &apos;static&apos;),</div><div class="line">    &apos;/static/&apos;,</div><div class="line">    name=&apos;Static Files&apos;</div><div class="line">))</div></pre></td></tr></table></figure>
<h3 id="保护-Flask-Admin-的安全"><a href="#保护-Flask-Admin-的安全" class="headerlink" title="保护 Flask Admin 的安全"></a>保护 Flask Admin 的安全</h3><p>既然是 Admin，那自然只有管理员才能访问了，所以我们要加入相应的权限。</p>
<p>首先也应该在自定义路由加入 login_require, admin_permission.require() 装饰器来声明权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class CustomView(BaseView):</div><div class="line">    @expose(&apos;/&apos;)</div><div class="line">    @login_required</div><div class="line">    @admin_permission.require(http_exception=403)</div><div class="line">    def index(self):</div><div class="line">        return self.render(&apos;admin/custom.html&apos;)</div><div class="line"></div><div class="line">    @expose(&apos;/second_page&apos;)</div><div class="line">    @login_required</div><div class="line">    @admin_permission.require(http_exception=403)</div><div class="line">    def second_page(self):</div><div class="line">        return self.render(&apos;admin/second_page.html&apos;)</div></pre></td></tr></table></figure>
<p>再就是在 MobileView 和 FileAdmin 中定义 is_accessible 方法来控制权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class CustomModelView(ModelView):</div><div class="line">    def is_accessible(self):</div><div class="line">        return current_user.is_authenticated and admin_permission.can()</div><div class="line">        </div><div class="line">        </div><div class="line">class CustomFileAdmin(FileAdmin):</div><div class="line">    def is_accessible(self):</div><div class="line">        return current_user.is_authenticated and admin_permission.can()</div></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>常用的扩展差不多就是这么多了，Flask 的一个强大的地方就是它自定义扩展很容易，所以市面上 Flask 扩展有很多，实现的功能也很全面，就进一步减轻了完成一个 Flask App 的工作量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flask-Restful&quot;&gt;&lt;a href=&quot;#Flask-Restful&quot; class=&quot;headerlink&quot; title=&quot;Flask-Restful&quot;&gt;&lt;/a&gt;Flask-Restful&lt;/h2&gt;&lt;p&gt;具体内容参考之前的&lt;a href=&quot;https://
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Cache" scheme="https://blog.patrickcty.cc/tags/Cache/"/>
    
      <category term="Admin" scheme="https://blog.patrickcty.cc/tags/Admin/"/>
    
  </entry>
  
  <entry>
    <title>Flask常用扩展用法</title>
    <link href="https://blog.patrickcty.cc/2017/09/18/Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.patrickcty.cc/2017/09/18/Flask常用扩展用法/</id>
    <published>2017-09-18T15:21:51.000Z</published>
    <updated>2017-09-18T15:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>强大的 ORM 工具，让对数据库的操作变得简单。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_sqlalchemy import SQLAlchemy</div><div class="line"></div><div class="line">db = SQLAlchemy()</div><div class="line">db.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 根据实际的数据库类型来确定 URI</div><div class="line">SQLALCHEMY_DATABASE_URI = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;dev.sqlite&apos;)</div><div class="line">SQLALCHEMT_ECHO = True  # 可选</div><div class="line">SQLALCHEMY_TRACK_MODIFICATIONS = True  # 需要显式指明</div></pre></td></tr></table></figure>
<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Role(db.Model):</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    name = db.Column(db.String(80), unique=True)</div><div class="line">    description = db.Column(db.String(255))</div><div class="line"></div><div class="line">    def __init__(self, name=&apos;default&apos;):</div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;&lt;Role &#123;&#125;&gt;&apos;.format(self.name)</div></pre></td></tr></table></figure>
<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.create_all()</div><div class="line">db.session.query()</div><div class="line">db.session.add()</div><div class="line">db.session.commit()</div><div class="line">db.session.flush()</div><div class="line">db.drop_all()</div></pre></td></tr></table></figure>
<h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>好用的登录控制扩展，功能全面并且强大。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from flask-login import LoginManger</div><div class="line"></div><div class="line">login_manger.login_view = &apos;main.login&apos;</div><div class="line">login_manger.session_protection = &apos;strong&apos;</div><div class="line">login_manger.login_message = &apos;请登录以访问该页面&apos;</div><div class="line">login_manger.login_message_category = &apos;info&apos;</div><div class="line"></div><div class="line">login_manger.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>需要在用户类里面实现特定的方法，或直接继承 UserMixin，注意如果用户的主键不是 id 则要自己实现 user_loader() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask_login import UserMixin, AnonymousUserMixin</div><div class="line"></div><div class="line">class User(db.Model, UserMixin):</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    </div><div class="line"></div><div class="line">class AnonymousUser(AnonymousUserMixin):</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<h3 id="作为函数的装饰器"><a href="#作为函数的装饰器" class="headerlink" title="作为函数的装饰器"></a>作为函数的装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@main_blueprint.route(&apos;/logout&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">@login_required</div><div class="line">def logout():</div><div class="line">    logout_user()</div><div class="line">    flash(&apos;登出成功！&apos;, category=&apos;success&apos;)</div><div class="line">    return redirect(url_for(&apos;blog.home&apos;))</div></pre></td></tr></table></figure>
<h3 id="登入登出"><a href="#登入登出" class="headerlink" title="登入登出"></a>登入登出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">login_user(user, remember=form.remember_me.data)</div><div class="line">logout_user()</div></pre></td></tr></table></figure>
<h3 id="获得当前用户对象"><a href="#获得当前用户对象" class="headerlink" title="获得当前用户对象"></a>获得当前用户对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from flask-login import current_user</div></pre></td></tr></table></figure>
<p>在 Jinja2 模板中可以直接调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; current_user.name &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="Flask-Bcrypt"><a href="#Flask-Bcrypt" class="headerlink" title="Flask-Bcrypt"></a>Flask-Bcrypt</h2><p>用来生成和检查加密字符串，常用作密码管理。</p>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask-bcrypt import Bcrypt</div><div class="line"></div><div class="line">bcrypt = Bcrypt()</div><div class="line">bcrypt.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="生成与检验密码"><a href="#生成与检验密码" class="headerlink" title="生成与检验密码"></a>生成与检验密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># property 装饰器将方法封装成了属性</div><div class="line">@property</div><div class="line">def passwd(self):</div><div class="line">    raise AttributeError(&apos;密码不可读！&apos;)</div><div class="line"></div><div class="line"># 通过下面的方法来实现直接对“属性”赋值</div><div class="line"># self.passwd = &apos;aaa&apos;</div><div class="line">@passwd.setter</div><div class="line">def passwd(self, password):</div><div class="line">    # 生成密码</div><div class="line">    self.password = bcrypt.generate_password_hash(password)</div><div class="line"></div><div class="line">def verify_password(self, password):</div><div class="line">    # 检验密码</div><div class="line">    return bcrypt.check_password_hash(self.password, password)</div></pre></td></tr></table></figure>
<h2 id="Flask-Principal"><a href="#Flask-Principal" class="headerlink" title="Flask-Principal"></a>Flask-Principal</h2><p>权限管理扩展。</p>
<h3 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h3><h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>Identity 用来表示身份，而 Need 是 Identity 的一部分，用来表示具体的权限。</p>
<p>Identity 一般在身份状态改变的时候创建，此时也会发出 identity_loaded 的信号，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">identity_changed.send(current_app._get_current_object(),</div><div class="line">                      identity=Identity(user.id))</div></pre></td></tr></table></figure>
<p>Identity 使用用户的 id 来表示用户以及创建对象。</p>
<h4 id="Need"><a href="#Need" class="headerlink" title="Need"></a>Need</h4><p>Need 如上面所说是用来表示具体的权限，是用 namedtuple 来实现的。</p>
<p>namedtuple 是 Python collections 模块中的一个数据结构，实现类似 C 语言中 struct 的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import namedtuple</div><div class="line">&gt;&gt;&gt; MyNT = namedtuple(&apos;tuple_name&apos;, [&apos;attr1&apos;, &apos;attr2&apos;])</div><div class="line">&gt;&gt;&gt; MyNT.__name__</div><div class="line">&apos;tuple_name&apos;</div><div class="line">&gt;&gt;&gt; nt = MyNT(&apos;this is the first attr&apos;, &apos;hello&apos;)</div><div class="line">&gt;&gt;&gt; nt.attr1</div><div class="line">&apos;this is the first attr&apos;</div></pre></td></tr></table></figure>
<p>Need 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Need = namedtuple(&apos;Need&apos;, [&apos;method&apos;, &apos;value&apos;])</div></pre></td></tr></table></figure>
<p>Need 一般是 tuple，之后在 Permission 初始化的时候会被转换为 set，set 的基本元素是 Need。</p>
<p>UserNeed 和 RoleNeed 是 Need 的两种典型的表现形式，前者用 user id 来表示 method（个人感觉和 Identity 有些重叠），后者用 role 表示 method 作为权限。它们使用 Python 的 functools 中的 partial 来固定了 Need 的 method。</p>
<p>partial 一般用来固定函数的某个参数的值，产生一个偏函数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pow(2, 3)</div><div class="line">8</div><div class="line">&gt;&gt;&gt; from functools import partial</div><div class="line">&gt;&gt;&gt; my_pow = partial(pow, 2)  # 固定了 2 作为了 pow 的第一个参数</div><div class="line">&gt;&gt;&gt; my_pow(5)</div><div class="line">32</div></pre></td></tr></table></figure>
<p>RoleNeed 和 UserNeed 就是这样产生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RoleNeed = partial(Need, &apos;role&apos;)</div><div class="line">UserNeed = partial(Need, &apos;id&apos;)</div></pre></td></tr></table></figure>
<h4 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h4><p>Permission 用来表示权限，和具体的 Identity 无关，但是可以用来判断当前的 Identity 是否具有相应的权限。</p>
<p>Permission 使用 Need 来初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div></pre></td></tr></table></figure></p>
<p>使用 can() 方法来检测当前用户是否具有相应的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if not admin_permission.can():</div><div class="line">    abort(403)</div></pre></td></tr></table></figure></p>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>使用 Permission 表示权限，Identity 表示用户，用户所拥有的权限用 Need 来表示，通过 Permission 来检测 Identity 里面是否具有相应的 Need 来判断这个用户是否有相应的权限。</p>
<h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from flask_principal import Principal, Permission, RoleNeed, identity_loaded()</div><div class="line"></div><div class="line">principals = Principal()</div><div class="line"># 定义了三种权限</div><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div><div class="line"></div><div class="line">principals.init_app(app)</div><div class="line"></div><div class="line"># 当接收到 identity_loaded 信号时会被调用</div><div class="line"># 此时会将 Need 添加到相应的身份对象中</div><div class="line">@identity_loaded.connect_via(app)</div><div class="line">def on_identity_loaded(sender, identity):</div><div class="line">    identity.user = current_user</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;id&apos;):</div><div class="line">        identity.provides.add(UserNeed(current_user.id))</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;roles&apos;):</div><div class="line">        for role in current_user.roles:</div><div class="line">            identity.provides.add(RoleNeed(role.name))</div></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>作为装饰器或者直接调用 can() 方法来判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@blog_print.route(&apos;/edit/&lt;int:post_id&gt;&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line"># 没有 poster 权限无法访问</div><div class="line">@poster_permission.require(http_exception=403) </div><div class="line">@login_required</div><div class="line">def edit_post(post_id):</div><div class="line"></div><div class="line">    post = Post.query.get_or_404(post_id)</div><div class="line">    # 这个权限表示只有创建者才能访问</div><div class="line">    permission = Permission(UserNeed(post.user_id))</div><div class="line">    # 如果不是作者而是管理员则也可以访问</div><div class="line">    if not (permission.can() or admin_permission.can()):</div><div class="line">        abort(403)</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Identity-1"><a href="#Identity-1" class="headerlink" title="Identity"></a>Identity</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class Identity(object):</div><div class="line">    &quot;&quot;&quot;Represent the user&apos;s identity.</div><div class="line"></div><div class="line">    :param id: The user id</div><div class="line">    :param auth_type: The authentication type used to confirm the user&apos;s</div><div class="line">                      identity.</div><div class="line"></div><div class="line">    The identity is used to represent the user&apos;s identity in the system. This</div><div class="line">    object is created on login, or on the start of the request as loaded from</div><div class="line">    the user&apos;s session.</div><div class="line"></div><div class="line">    Once loaded it is sent using the `identity-loaded` signal, and should be</div><div class="line">    populated with additional required information.</div><div class="line"></div><div class="line">    Needs that are provided by this identity should be added to the `provides`</div><div class="line">    set after loading.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, id, auth_type=None):</div><div class="line">        self.id = id</div><div class="line">        self.auth_type = auth_type</div><div class="line">        self.provides = set()</div><div class="line"></div><div class="line">    def can(self, permission):</div><div class="line">        &quot;&quot;&quot;Whether the identity has access to the permission.</div><div class="line"></div><div class="line">        :param permission: The permission to test provision for.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return permission.allows(self)</div><div class="line"></div><div class="line"></div><div class="line">class AnonymousIdentity(Identity):</div><div class="line">    &quot;&quot;&quot;An anonymous identity&quot;&quot;&quot;</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        Identity.__init__(self, None)</div></pre></td></tr></table></figure>
<p>Identity 接受 user id 作为参数，provides 属性是和 Permission 类似都是一个用来储存 Need 的 set，其中 provides 的内容在切换身份的时候添加。</p>
<p>Identity 可以使用 can() 方法来判断该 Identity 是否具有相应的权限，这个方法接受一个 Permission 来作为参数，实际上直接调用 Permission 的方法来检查权限。</p>
<p>而匿名 Identity 则是 id 为空的特殊 Identity。</p>
<h4 id="IdentityContext"><a href="#IdentityContext" class="headerlink" title="IdentityContext"></a>IdentityContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class IdentityContext(object):</div><div class="line">    &quot;&quot;&quot;The context of an identity for a permission.</div><div class="line"></div><div class="line">    .. note:: The principal is usually created by the flaskext.Permission.require method</div><div class="line">              call for normal use-cases.</div><div class="line"></div><div class="line">    The principal behaves as either a context manager or a decorator. The</div><div class="line">    permission is checked for provision in the identity, and if available the</div><div class="line">    flow is continued (context manager) or the function is executed (decorator).</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    def __init__(self, permission, http_exception=None):</div><div class="line">        self.permission = permission</div><div class="line">        self.http_exception = http_exception</div><div class="line">        &quot;&quot;&quot;The permission of this principal</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">    @property</div><div class="line">    def identity(self):</div><div class="line">        &quot;&quot;&quot;The identity of this principal</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return g.identity</div><div class="line"></div><div class="line">    def can(self):</div><div class="line">        &quot;&quot;&quot;Whether the identity has access to the permission</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return self.identity.can(self.permission)</div></pre></td></tr></table></figure>
<p>IdentityContext 通常通过 Permission.require() 方法来创建，它接受 Permission 作为参数，绑定的 Identity 是当前用户的 Identity（通过 g 来实现）。</p>
<h4 id="Permission-1"><a href="#Permission-1" class="headerlink" title="Permission"></a>Permission</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">class Permission(object):</div><div class="line">    &quot;&quot;&quot;Represents needs, any of which must be present to access a resource</div><div class="line"></div><div class="line">    :param needs: The needs for this permission</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, *needs):</div><div class="line">        &quot;&quot;&quot;A set of needs, any of which must be present in an identity to have</div><div class="line">        access.</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">        self.needs = set(needs)</div><div class="line">        self.excludes = set()</div><div class="line"></div><div class="line">    def require(self, http_exception=None):</div><div class="line">        &quot;&quot;&quot;Create a principal for this permission.</div><div class="line"></div><div class="line">        The principal may be used as a context manager, or a decroator.</div><div class="line"></div><div class="line">        If ``http_exception`` is passed then ``abort()`` will be called</div><div class="line">        with the HTTP exception code. Otherwise a ``PermissionDenied``</div><div class="line">        exception will be raised if the identity does not meet the</div><div class="line">        requirements.</div><div class="line"></div><div class="line">        :param http_exception: the HTTP exception code (403, 401 etc)</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return IdentityContext(self, http_exception)</div><div class="line"></div><div class="line">    def allows(self, identity):</div><div class="line">        &quot;&quot;&quot;Whether the identity can access this permission.</div><div class="line"></div><div class="line">        :param identity: The identity</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        if self.needs and not self.needs.intersection(identity.provides):</div><div class="line">            return False</div><div class="line"></div><div class="line">        if self.excludes and self.excludes.intersection(identity.provides):</div><div class="line">            return False</div><div class="line"></div><div class="line">        return True</div><div class="line"></div><div class="line">    def can(self):</div><div class="line">        &quot;&quot;&quot;Whether the required context for this permission has access</div><div class="line"></div><div class="line">        This creates an identity context and tests whether it can access this</div><div class="line">        permission</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return self.require().can()</div></pre></td></tr></table></figure>
<p>Permission 可以说是最关键的部分了，它接受 Need 的 list 作为参数，并将其转换为 set 来储存所有的权限。为什么是 set 呢？因为 set 不可重复，并且做集合运算很容易直到是否存在某个 Need。</p>
<p>它的 require() 方法是使用得最多的方法之一，在调用这个方法的时候会创建一个 IdentityContext 实例，它会调用 IdentityContext.__enter__() 方法来检查权限，而这个方法里面又要调用 IdentityContext.can() 方法，这个方法又调用了相应的 Identity 对应的 Identity.can() 方法，并且传入当前 Identity 含有的权限作为参数。Identity 又调用 Permission.allows() 方法来检查权限，而这个方法则把 Permission 所具有的 Need 的 set 和 Identity.provides 这个 set 来做集合交运算来判断是否有相应的权限。（调用了一大圈，汗）</p>
<p>而 Permission.can() 的用法和上面的几乎一样。不过不同的是 require() 方法一般被用作装饰器，而 can() 方法一般用来直接进行判断。</p>
<h3 id="Principal-总结"><a href="#Principal-总结" class="headerlink" title="Principal 总结"></a>Principal 总结</h3><p>不得不说整个扩展设计得还是非常不错的，各个模块的逻辑性很强，只是太难理解了……我前前后后看了两遍……这次才终于搞清楚前前后后的逻辑了……</p>
<p>果然还是要看源代码，话说源代码写得还真不错，不仅文档详实，代码真的超级规范！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flask-SQLAlchemy&quot;&gt;&lt;a href=&quot;#Flask-SQLAlchemy&quot; class=&quot;headerlink&quot; title=&quot;Flask-SQLAlchemy&quot;&gt;&lt;/a&gt;Flask-SQLAlchemy&lt;/h2&gt;&lt;p&gt;强大的 ORM 工具，让对数
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="SQLAlchemy" scheme="https://blog.patrickcty.cc/tags/SQLAlchemy/"/>
    
      <category term="Principal" scheme="https://blog.patrickcty.cc/tags/Principal/"/>
    
      <category term="Login" scheme="https://blog.patrickcty.cc/tags/Login/"/>
    
  </entry>
  
  <entry>
    <title>《爆漫王》</title>
    <link href="https://blog.patrickcty.cc/2017/09/17/%E3%80%8A%E7%88%86%E6%BC%AB%E7%8E%8B%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/09/17/《爆漫王》/</id>
    <published>2017-09-17T06:34:49.000Z</published>
    <updated>2017-09-17T06:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>梦想，多么熟悉又陌生的一个词。对我来说，这个词似乎从来都没有存在过。</p>
<p>小学时候的“梦想”是成为天文学家，但这只是一个听起来很厉害的职业，而同期的小伙伴们很多选择的是同样炫酷的科学家、医生……这个所谓的梦想的作用也只是在亲戚和老师问到之后的一个回答而已。</p>
<p>而天文学家最接近梦想的一次是爸爸给我买天文望远镜，但是因为我没有太大的兴趣，所以天文望远镜也只用过一次就永远躺在老屋黑暗的顶楼中了。之后这个“梦想”就像那个崭新的天文望远镜一样湮没在尘埃之中了。</p>
<p>初中和高中本应该是大谈理想与未来的时刻，但是在深井中哪看得到什么理想，更何况背上还压着重担。在这样的情况下，大家都是一样，所谓的梦想，被简化成了目标，而目标，则被固化成了取得好成绩。</p>
<p>而我就在大流中漂着，偶尔也有人问过梦想，但是我的回答是不存在。</p>
<p>也不知道什么时候开始，整个社会，特别是青年一代，都开始追逐财富。“最大的梦想是一夜暴富”这种话也多次从我口中说出，但是真正暴富又怎样呢？这个我也从未认真想过，或许也只是因为欲望吧。</p>
<p>追求财富其实也是一个好梦想，但是好的梦想背后总有一个意义，而财富的意义确是那么空虚。所以这与其来说是一个梦想，倒不如说是一种焦虑，一种因为内心空虚缺乏梦想的焦虑。</p>
<p>高中毕业之后，背上的重担终于解除，离开井底也就是理所应当的了。其实很多时候人们一直待在井底并不是因为背上的重担，就像大象会被拴在木桩上并不是因为绳子。真正让我一直待在井底的原因在于我不知道外面有更广阔的世界，也没有机会能接触到。而上大学，让我被动着离开井底，虽然这之前我从来不知道我一直待在井底。</p>
<p>正是在这个过程中我才知道原来生活不仅仅只有成绩，兴趣不仅仅只有篮球动漫。虽然视野拓宽了，但是梦想似乎还是没有萌生，不过走着走着，总算是有了目标，而目标之后的梦想，却宛若缥缈云烟一般，仍然不可触及。</p>
<p>海贼王是一部有梦想的动漫，也是陪我从高中走到现在的动漫。路飞的梦想是成为海贼王，索隆的梦想是成为世界第一的大剑豪，娜美的梦想是画出整个世界的航海图，乌索普的梦想是成为勇敢的海上勇士，山治的梦想是找到 All Blue，罗宾的梦想是追寻历史的真相，乔巴的梦想是成为万能药，弗兰奇的梦想是看到自己造的船达到世界的尽头，而布鲁克的梦想则是再次与拉布见面。</p>
<p>每个人都有梦想，他们也在实现梦想的途中努着力，接受着嘲笑，但也是因为海贼的世界设计的太过精妙，反而没能激励我去现实世界寻找、实现梦想。而我最近看的《爆漫王》却是这种能让人充满干劲，甚至开始思考梦想的一部极其优秀的作品。</p>
<p>曾经男主真诚最高也是一名没有梦想的中学生，每天回家靠打游戏来挥霍时间，在学校里面有不高不低的成绩，暗恋一个从未说过话的女生。但是一个已经拥有并且准备追求梦想的人——高木秋人的出现改变了他的一生。<br>他们和女主一起确定了梦想：两人合作画出漫画，等到作品动画化之后最高就和女主亚豆结婚。</p>
<p>动画的第一季主要是讲述主角确定梦想并且开始向梦想奋斗的故事，其中不仅有欢笑，更多是对梦想的万分执着。两个年仅十四岁的少年，就已经有了人生奋斗的目标，并且和平常人不同的是，他们在这之后就全力追求目标了，连一秒钟都不浪费。真诚练习画画，高木写原作 NAME，很多人都会戏称《爆漫王》为《爆肝王》，因为他们真的太努力了。他们就这样一直奋斗着，接近着目标，从提名到刊载到这一季最后的连载，他们一步步在向那个梦想靠近。</p>
<p>个人认为第一季是整部剧最燃的一季，在这里我们和主角他们一起从零开始一起奋斗一起提心吊胆、分享喜悦，真的让人有一种马上去学习的欲望。</p>
<p>第二季同样精彩，但是这一季整体节奏没有第一步那么明快，颇有几分压抑的气息。那是因为梦想实现的过程总不总是一帆风顺，总是会有各种各样的挫折。</p>
<p>而主角他们遇到的第一个大的挫折就是首部连载作品因为真诚的“爆肝”而不得不长时间休刊，等到最后恢复的时候已经人气下降被腰斩。之后又因为责编的原因不得不去画他们所不喜欢且不擅长的搞笑漫画，也因此他们的作品的名次一直在一个很令人尴尬的位置。在这一季最后，他们勇敢地选择结束连载，并在重重困难之下完成了新的作品，通过了编辑部的挑战。</p>
<p>这一季看的时候感觉十分揪心，就像《牧羊少年》里面说的那样，梦想是以初行者的运气开始，而到了后面就成为了对旅行者的考验。这时候的真诚他们也是迈入了后一个阶段，其中令人印象深刻的是真诚在医院中挣扎着画画的场景，这种对梦想的执着真的是无人能及了。</p>
<p>除此之外，第二季中友谊这个概念也变得更加深入，除了真诚和高木的革命友谊之外，同为福田组的新妻英二、福田先生、中井先生、苍树红等这些人物与主角的友情也表现得淋漓尽致，虽然他们是对手，但同时也是伙伴，正是有了他们相互的支持，这一季才不会让人感觉过于压抑。</p>
<p>说到这些其他的角色，就不得不说这部动漫的另一个亮点了——人物刻画。主人公一行人就不用说了，一群志同道合又个性鲜明的作者，一群性格迥异却又敬业的编辑，全都是“圆形人物”，人物的个性都被表现得淋漓尽致。</p>
<p>其中最让人喜欢的莫过于直爽天真又天赋异禀的新妻英二，他虽然是天才但是并没有天才的架子，反而是一个非常让人亲近的人，也正是抱着超过他的态度，主角他们才能一次一次奋斗，画出更好的作品。而编辑的角色中服部先生最让人喜爱，不仅是因为他直爽的性格与笑声，更是因为他的敬业与真性情，他会为了作者而开心与难受，和他们一起奋斗，正是有了他才让亚城木梦叶他们能走在正确的道路上接近梦想。</p>
<p>而第三季的剧情就比第二季明快不少，但是少了第一季的跌宕起伏，不过剧情的精彩程度还是无可挑剔的。这一季主人公终于走出低谷，大放异彩，最终实现了梦想。</p>
<p>看到最后的时候不禁让人感到落寞，短短的一段时间，就见证了主角他们十年的努力。看的时候希望他们能早日实现梦想，但是当真正实现了梦想的时候却也是不得不说再见的时候了。虽然剧情到这里就结束了，但是这部动漫让我陷入了思考——我的梦想到底是什么？</p>
<p>想来想去，虽然我没有真诚那样明确的梦想，动画化，结婚。但是我也有一个阶段一个阶段的目标，从最近的跟着导师搞科研，到之后的考研上中山大学。和主角相比，我对梦想的执着程度还是太低，这也是我一直以来最大的问题。我无法像主角那样一直专注于梦想，但是看过这部动漫之后我也有了行动，我放弃掉了一些占用很多时间的无意义的内容，比如花大量时间看对我没什么用的手机评测以及肝得很累的崩坏 3。</p>
<p>我想，等我以后觉得很累想放弃的时候我就会再次拾起这部动漫重新找回向前奋斗的勇气吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梦想，多么熟悉又陌生的一个词。对我来说，这个词似乎从来都没有存在过。&lt;/p&gt;
&lt;p&gt;小学时候的“梦想”是成为天文学家，但这只是一个听起来很厉害的职业，而同期的小伙伴们很多选择的是同样炫酷的科学家、医生……这个所谓的梦想的作用也只是在亲戚和老师问到之后的一个回答而已。&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="https://blog.patrickcty.cc/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="感动" scheme="https://blog.patrickcty.cc/tags/%E6%84%9F%E5%8A%A8/"/>
    
      <category term="梦想" scheme="https://blog.patrickcty.cc/tags/%E6%A2%A6%E6%83%B3/"/>
    
      <category term="友谊" scheme="https://blog.patrickcty.cc/tags/%E5%8F%8B%E8%B0%8A/"/>
    
      <category term="欢乐" scheme="https://blog.patrickcty.cc/tags/%E6%AC%A2%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中 Celery 的用法（二）</title>
    <link href="https://blog.patrickcty.cc/2017/09/03/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/09/03/再次理解Flask中Celery的用法（二）/</id>
    <published>2017-09-03T02:58:34.000Z</published>
    <updated>2017-09-03T03:00:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-Celery-的用法（二）"><a href="#再次理解-Flask-中-Celery-的用法（二）" class="headerlink" title="再次理解 Flask 中 Celery 的用法（二）"></a>再次理解 Flask 中 Celery 的用法（二）</h1><h2 id="运行-Celery-task"><a href="#运行-Celery-task" class="headerlink" title="运行 Celery task"></a>运行 Celery task</h2><p>我们之前都是用 Celery task 的 delay() 方法来运行任务，但是这只是 apply_async 方法的简略版本，后者的使用方法如下：</p>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">task.apply_async(</div><div class="line">    args=[1, 2],  # 可选，表示参数列表，是一个 list</div><div class="line">    kwargs=&#123;&apos;kwarg1&apos;: &apos;1&apos;, &apos;kwarg2&apos;: &apos;2&apos;&#125;,</div><div class="line">    # countdown 表示指定秒数后后开始处理这个任务</div><div class="line">    # 不是一定在那个时候执行，要根据其他任务来定</div><div class="line">    countdown=600,</div><div class="line">    # eta 表示指定时间开始处理这个任务</div><div class="line">    # 执行时间和 countdown 一样不完全可靠</div><div class="line">    # 我用这个参数来发邮件结果第二天才发出去……</div><div class="line">    eta=datetime.datime.now() + datetime.timedelta(hours=1)</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="Celery-签名-子任务"><a href="#Celery-签名-子任务" class="headerlink" title="Celery 签名/子任务"></a>Celery 签名/子任务</h2><p>签名可以把 task 生成函数来便于其他的函数进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import signature</div><div class="line">&gt;&gt;&gt; from webapp.tasks import multiply</div><div class="line"># signature 的第一个参数要写全</div><div class="line">&gt;&gt;&gt; signature(&apos;webapp.tasks.multiply&apos;, args=[4, 4], countdown=10)</div><div class="line">webapp.tasks.multiply(4, 4)  # 返回的是一个函数</div><div class="line"># 和上面相同的功能</div><div class="line">&gt;&gt;&gt; multiply.subtask((4, 4), countdown=10)</div><div class="line">webapp.tasks.multiply(4, 4)</div><div class="line"># 上面的缩略版本，没有关键字参数</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4)</div><div class="line">webapp.tasks.multiply(4, 4)</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4)()  # 调用函数</div><div class="line">16</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4).delay()  # 创建任务</div></pre></td></tr></table></figure>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Celery 任务签名的第一个应用是偏函数。偏函数来源于一个要接受很多参数的函数，这个函数被施加某种操作之后，生成了一个新的函数，在调用这个函数的时候，前 n 个参数永远是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; partial = multiply.s(4)  # 第一个参数永远是 4</div><div class="line">&gt;&gt;&gt; partial(5)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; partial.delay(5)</div></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是根据前一个任务执行的结果来执行的函数。在 apply_async() 中使用 link 参数来添加回调函数。</p>
<p>这个执行任务返回的值并不是回调函数的结果，而是前一个任务执行的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># link 接受一个签名作为参数</div><div class="line"># log 接受 multiply 的结果作为参数</div><div class="line"># 这里是建立了两个 task，并且返回值都是 16</div><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.s())</div><div class="line"># 如果回调函数不接受输入或者不需要上一个任务的结果</div><div class="line"># 那么签名必须使用 si 方法（设置为不可变类型）</div><div class="line"># 结果为 16 而不是 hello</div><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.si(&apos;hello&apos;))</div></pre></td></tr></table></figure>
<p>回调函数常常用来做两个联系紧密的任务，比如每次创建用户的任务之后都发送一封欢迎 email。</p>
<p>偏函数也可以和回调函数一起用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=multiply.s(4))</div></pre></td></tr></table></figure>
<h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><p>任务组函数接受一组任务签名的列表，并生成一个函数，调用该函数可并行执行所有的任务签名，并返回所有结果的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import group</div><div class="line">&gt;&gt;&gt; sig = group(multiply.s(i, i + 5) for i in range(10))</div><div class="line">&gt;&gt;&gt; rst = sig.delay()</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</div></pre></td></tr></table></figure>
<h2 id="任务链"><a href="#任务链" class="headerlink" title="任务链"></a>任务链</h2><p>任务链和回调函数有点相像，它接受一组任务签名，把每个签名的执行结果传给任务链的下一个，最后只会返回最后一个的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import chain</div><div class="line"># 事实上也是创建了多个任务，但是只会返回最终的结果</div><div class="line">&gt;&gt;&gt; sig = chain(multiply.s(10, 10), multiply.s(10), multiply.s(10))</div><div class="line"># 另一种写法</div><div class="line">&gt;&gt;&gt; sig = (multiply.s(10, 10) | multiply.s(10) | multiply.s(10))</div></pre></td></tr></table></figure>
<p>任务链也可以用来组合偏函数生成新的偏函数，这样的话任务链也可以嵌套了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; func = (multiply.s(10) | multiply.s(10))</div><div class="line">&gt;&gt;&gt; rst = func.delay(16)</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">1600</div></pre></td></tr></table></figure></p>
<h2 id="复合任务"><a href="#复合任务" class="headerlink" title="复合任务"></a>复合任务</h2><p>复合任务是函数生成一个任务签名的时候，会先执行一个任务组，然后把最终结果传给回调函数，最后回调函数的结果就是最终的结果，这里和上面的回调函数部分有些不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import chord</div><div class="line">&gt;&gt;&gt; sig = chord(</div><div class="line">    group(multiply(i, i + 5) for i in range(10)),</div><div class="line">    # 整个任务组执行的结果，也就是回调函数的参数是 list</div><div class="line">    multiply.s(2) </div><div class="line">)</div><div class="line">&gt;&gt;&gt; rst = sig.delay()</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">[0, 6, 14, 24, 36, 50, 66, 84, 104, 126, 0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</div><div class="line"># 还有另一种写法</div><div class="line">&gt;&gt;&gt; sig = (group([0, 6, 14, 24, 36, 50, 66, 84, 104, 126]) | multiply.s(2))</div></pre></td></tr></table></figure>
<h2 id="定期执行任务"><a href="#定期执行任务" class="headerlink" title="定期执行任务"></a>定期执行任务</h2><p>和 Linux 的 cron 命令有点类似，不过这里完全是在 Flask 的上下文中来执行任务的。</p>
<p>要在 config 文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CELERY_SCHEDULE = &#123;</div><div class="line">    &apos;log-every-30-seconds&apos;: &#123;</div><div class="line">        &apos;task&apos;: &apos;webapp.tasks.log&apos;,</div><div class="line">        &apos;schedule&apos;: datetime.timedelta(seconds=30),</div><div class="line">        &apos;args&apos;: [&apos;hello&apos;,]</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是定义了 log 任务每隔 30s 执行一次</p>
<p>如果要运行定期任务，就要使用 Celery 的 beat 工作进程，当然任务也是在 worker 进程中执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery -A celery_runner beat</div></pre></td></tr></table></figure>
<p>如果要在一个精确的时间执行，那么就要用 crontab 对象了，具体的用法参考 Celery <a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from celery.schedules import crontab</div><div class="line"># 每天凌晨</div><div class="line">&gt;&gt;&gt; crontab(minute=0, hour=0)</div><div class="line"># 早上五点，十点，下午三点，八点</div><div class="line">&gt;&gt;&gt; crontab(minute=0, hour=[5, 10, 15, 20])</div></pre></td></tr></table></figure>
<h2 id="在-Flower-中通过网页监控"><a href="#在-Flower-中通过网页监控" class="headerlink" title="在 Flower 中通过网页监控"></a>在 Flower 中通过网页监控</h2><p>Flower 是针对 Celery 的基于网页的试试管理工具。</p>
<p>安装 Flower：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install flower</div></pre></td></tr></table></figure></p>
<p>运行 Flower：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery flower -A celery_runner --loglevel=info</div></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说实话第一次看到上面这些的时候真的十分头大，一脸懵逼，不过现在回头整理了一遍之后明了了许多，不过要吐槽的是 eta 为什么这么坑啊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-Celery-的用法（二）&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-Celery-的用法（二）&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 Celery 的用法（二）&quot;&gt;&lt;/a&gt;再次理解 Fla
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Celery" scheme="https://blog.patrickcty.cc/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中 Celery 的用法（一）</title>
    <link href="https://blog.patrickcty.cc/2017/09/01/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/09/01/再次理解Flask中Celery的用法（一）/</id>
    <published>2017-09-01T02:19:35.000Z</published>
    <updated>2017-09-03T03:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-Celery-的用法（一）"><a href="#再次理解-Flask-中-Celery-的用法（一）" class="headerlink" title="再次理解 Flask 中 Celery 的用法（一）"></a>再次理解 Flask 中 Celery 的用法（一）</h1><h2 id="Celery-概览"><a href="#Celery-概览" class="headerlink" title="Celery 概览"></a>Celery 概览</h2><p>Celery 是用 Python 编写的任务队列工具，它使用 Python 的多任务库来并行地执行任务。</p>
<p>在下面我们用 Flask Server 来发送任务请求，由消息队列储存并转发给 Celery。Celery 运行的结果也同样由消息队列传递回去。</p>
<p>消息队列是一个队列，用来在生产者进程和消费者进程之间传递信息。不过消息队列在生产者接收到消息之后就立即把数据丢弃了，这时候可以用数据库来保存任务结果。</p>
<h2 id="配置-Celery-环境"><a href="#配置-Celery-环境" class="headerlink" title="配置 Celery 环境"></a>配置 Celery 环境</h2><p>安装 Celery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install celery</div></pre></td></tr></table></figure></p>
<p>安装 Flask 扩展来辅助处理 Celery 的初始化(可选)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install flask-celery-helper</div></pre></td></tr></table></figure></p>
<p>安装 Redis 来作为消息队列以及储存最终的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install redis</div><div class="line">redis-server  # 使用 redis</div></pre></td></tr></table></figure></p>
<h2 id="在-Celery-中创建任务"><a href="#在-Celery-中创建任务" class="headerlink" title="在 Celery 中创建任务"></a>在 Celery 中创建任务</h2><p>在 Celery 中，broker 意思是中间人，指的就是消息队列本身，而 result backend 顾名思义就是存储得到的结果。</p>
<h3 id="单文件示例"><a href="#单文件示例" class="headerlink" title="单文件示例"></a>单文件示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&quot;task.py&quot;&quot;&quot;</div><div class="line"></div><div class="line">from celery import Celery</div><div class="line">import time</div><div class="line"></div><div class="line">app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379&apos;)</div><div class="line"></div><div class="line">@app.task</div><div class="line">def add(x, y):</div><div class="line">    print &apos;hello celery&apos;</div><div class="line">    time.sleep(10)</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>使用 task：</p>
<ul>
<li><p>新建一个 Python Shell，使用 delay 或 apply_async 来运行 add 方法，注意只有当 Celery 实例存在时运行结果才会被收到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from task import add</div><div class="line">&gt;&gt;&gt; add.delay(3, 5)</div><div class="line">&gt;&gt;&gt; add.apply_acync([7, 8])</div></pre></td></tr></table></figure>
</li>
<li><p>再在另一个终端中运行 Celery worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery worker -A task --loglevel=info</div></pre></td></tr></table></figure>
<p>  worker 表示使用 Celery worker<br>  -A 参数是一个含有 Celery 实例的模块名，Celery 通过它来运行</p>
</li>
</ul>
<p>运行 Celery worker 之后就可以看到任务信息了，如果要在 shell 中得到返回的结果则还要配置 backend</p>
<p>修改上面的 app 为如下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app = Celery(</div><div class="line">    &apos;tasks&apos;,</div><div class="line">    broker=&apos;redis://localhost:6379&apos;，</div><div class="line">    backend=&apos;redis://localhost:6379&apos;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>然后就可以在 Python Shell 查看 Celery 运行的结果和状态了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; rst = add.delay(8, 7)</div><div class="line">&gt;&gt;&gt; rst.state()  # 查看任务现在的状态</div><div class="line">&gt;&gt;&gt; rst.ready()  # 判断任务是否完成</div><div class="line">&gt;&gt;&gt; rst.get()    # 得到运行结果</div><div class="line">15</div></pre></td></tr></table></figure></p>
<h3 id="Flask-中使用示例"><a href="#Flask-中使用示例" class="headerlink" title="Flask 中使用示例"></a>Flask 中使用示例</h3><h4 id="使用扩展来配置"><a href="#使用扩展来配置" class="headerlink" title="使用扩展来配置"></a>使用扩展来配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask_celery import Celery()</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config.update(</div><div class="line">    CELERY_BROKER_URL=&apos;redis://localhost:6379&apos;,</div><div class="line">    CELERY_RESULT_BACKEND=&apos;redis://localhost:6379&apos;</div><div class="line">)</div><div class="line">celery = Celery(app)</div><div class="line"></div><div class="line"></div><div class="line">@celery.task()</div><div class="line">def add_together(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure>
<p>这里直接使用了上面安装的 flask-celery-helper 扩展，所以就直接接用扩展来初始化 Celery 实例即可。</p>
<h4 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h4><p>准备工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&quot;celery_maker.py&quot;&quot;&quot;</div><div class="line">from celery import Celery</div><div class="line"></div><div class="line">def make_celery(app):</div><div class="line">    celery = Celery(</div><div class="line">        app.import_name, </div><div class="line">        broker=app.config[&apos;CELERY_BROKER_URL&apos;]</div><div class="line">    )</div><div class="line">    celery.conf.update(app.config)</div><div class="line">    TaskBase = celery.Task</div><div class="line">    class ContextTask(TaskBase):</div><div class="line">        abstract = True</div><div class="line">        def __call__(self, *args, **kwargs):</div><div class="line">            with app.app_context():</div><div class="line">                return TaskBase.__call__(self, *args, **kwargs)</div><div class="line">    celery.Task = ContextTask</div><div class="line">    return celery</div></pre></td></tr></table></figure></p>
<p>使用 Celery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from celery_maker import make_celery</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config.update(</div><div class="line">    CELERY_BROKER_URL=&apos;redis://localhost:6379&apos;,</div><div class="line">    CELERY_RESULT_BACKEND=&apos;redis://localhost:6379&apos;</div><div class="line">)</div><div class="line">celery = make_celery(app)</div><div class="line"></div><div class="line"></div><div class="line">@celery.task()</div><div class="line">def add_together(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure></p>
<p>make_celery 的作用就是把每个对 Celery 任务的调用都包含到 Python 的 with 代码中，这样 Celery 在 Flask 的应用上下文中，就可以确保 Flask 扩展的调用都能正常工作了。</p>
<p>使用方法和之前的也是一样，不过在调用 task 的时候也必须在 Flask 的应用上下文中，不然就达不到预料的结果。</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>我之前就是因为把配置文件的名字写错了导致一直提示 backend 不存在……不要盲目相信书上的内容……还是官方文档靠谱……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-Celery-的用法（一）&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-Celery-的用法（一）&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 Celery 的用法（一）&quot;&gt;&lt;/a&gt;再次理解 Fla
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Celery" scheme="https://blog.patrickcty.cc/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>《十万个冷笑话2》</title>
    <link href="https://blog.patrickcty.cc/2017/08/26/%E3%80%8A%E5%8D%81%E4%B8%87%E4%B8%AA%E5%86%B7%E7%AC%91%E8%AF%9D2%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/26/《十万个冷笑话2》/</id>
    <published>2017-08-26T01:03:25.000Z</published>
    <updated>2017-08-26T01:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《十万个冷笑话-2》"><a href="#《十万个冷笑话-2》" class="headerlink" title="《十万个冷笑话 2》"></a>《十万个冷笑话 2》</h1><p>《十万个冷笑话》是在 2014.12.31 上映，2017.8.24，一起看第一部的原班人马再度聚集。</p>
<p>说起来已经有两年多了，看《十冷》的时候正是学习最紧张的高三，每天的课程与作业压得人透不过起来，而最能让人放松的反而是每周一次的月考，因为有着难得的一整天以及一个晚上的休息时间。而趁着这个时间，荷花亭小分队就会聚首，去到菱角湖万达，那个最常去因为充满着回忆的地方，又或者是去到西园，去放松被学校所压抑的内心。而《十冷》我们就是一起到西园去看的。《十冷》电影的情节早已模糊，但是当时看电影的情景，反而浮现在了脑海中。</p>
<p>毕业也没有拆散我们的友情，不过毕业却会改变一些事情。</p>
<p>当改变还没有发生时，我们一起去了青岛，在海边，在街边，在桥上，在房间里……我们被友谊的快乐包围着，心里祈祷着这样的友谊一直到永远。</p>
<p>但是随着毕业越来越久，改变也变得越来越明显，菁搬到了遥远的汉阳，出行变得不方便，而晨晨和男神在假期也有了满满的安排，我呢，在当时也有了自己的幸福。这就导致荷花亭小分队的聚首变得愈发困难。</p>
<p>不过友谊 wins，去年暑假，我们找到了机会再度聚首，而这次是在李文菁家。依然是以吃吃吃为主题，这次吃到了李文菁亲手烘焙的饼干和泡芙。友谊依然是熟悉的味道。</p>
<p>而寒假则更难找到时间了，兜兜转转又是一年的暑假。这一年的暑假则又变得更加难以聚首，菁依旧在遥远的汉阳，男神则有学校工作以及旅游安排，晨晨也找到了实习，而我则在广州待了很久。就在我以为没办法再度见面之时，阴差阳错之间我把车票改到了后一天，男神也正好“没有安排”，而晨晨和菁也能抽出时间，于是聚会就这样定了下来，也真的可以说是缘分。于是欢乐与我们再次光临了荷花亭，也再次一起观看了《十冷 2》。</p>
<p>荷花亭的菜依旧好吃，但是《十冷 2》却没有那么好看了，不过这些都不重要，因为你们都来了，现在大家都有了自己的幸福，也都有了自己的爱好与目标，我们不再“相同”，但是那份快乐经过了这么多年的酝酿，没有变质，却是越发醇香。依然是荷花亭，依然是吃吃吃，依然是拍拍拍，依然是小分队。</p>
<p>不知道下次见面会是在哪里，不过拥有着彼此的这么多黑照，可不能随随便便玩消失呀！男神请我们去青岛吃吃喝喝，菁亲手给我们考饼干吃，晨晨也接我们去了华科吃饭，那什么时候我能接你们来广州吃早茶呢~希望真的有这一天呢~</p>
<p>《十冷 2》的剧情也不重要，但它的意义却包含了很多~以后的《十冷 3》，《百冷》，《千冷》我们也要一起笑！</p>
<p>不过我在最后还是要吐槽一下《十冷 2》的剧情，看样子导演和编剧确实想拍出好电影，但是在剧情的设计上还是有很多的槽点，在大场面的表现上也显得十分不自然，人物刻画也很草率，前期的铺垫也做得不够好……主要是剧情是硬伤……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《十万个冷笑话-2》&quot;&gt;&lt;a href=&quot;#《十万个冷笑话-2》&quot; class=&quot;headerlink&quot; title=&quot;《十万个冷笑话 2》&quot;&gt;&lt;/a&gt;《十万个冷笑话 2》&lt;/h1&gt;&lt;p&gt;《十万个冷笑话》是在 2014.12.31 上映，2017.8.24，一起看
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="十万个冷笑话" scheme="https://blog.patrickcty.cc/tags/%E5%8D%81%E4%B8%87%E4%B8%AA%E5%86%B7%E7%AC%91%E8%AF%9D/"/>
    
      <category term="荷花亭小分队" scheme="https://blog.patrickcty.cc/tags/%E8%8D%B7%E8%8A%B1%E4%BA%AD%E5%B0%8F%E5%88%86%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>《战狼2》</title>
    <link href="https://blog.patrickcty.cc/2017/08/19/%E3%80%8A%E6%88%98%E7%8B%BC2%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/19/《战狼2》/</id>
    <published>2017-08-19T14:45:42.000Z</published>
    <updated>2017-08-19T15:04:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《战狼-2》"><a href="#《战狼-2》" class="headerlink" title="《战狼 2》"></a>《战狼 2》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这是我用 MacBook Pro 写的第一部影评~撒花撒花~</p>
<p>《战狼 2》作为一部现象级的国产电影，在很长时间之内刷爆了朋友圈，于是乎在女票回学校之后就第一时间和她一起出去看了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>整部电影是以一个退伍兵为主角来讲述的，和《湄公河行动》有些相像，都是为了替被害的爱人报仇。还有一个最近比较流行的套路就是中外混血电影，《战狼 2》如此，《侠盗联盟》也如此，虽然感觉高大上了一些，但是总是感觉有慢慢的违和感……</p>
<p>不过和《湄公河行动》不同，这部电影中绝大部分都是吴京或者说是冷锋的个人英雄主义。这是整部电影最精彩的地方，但同时也是整部电影的逻辑败笔所在。</p>
<p>从刚开始的徒手潜水解决海盗，到之后枪林弹雨中带着身边的人去到中国大使馆，再到之后只身去医院解救医院的人，以及后来去解救工厂的人。这些场景中的打斗场面都十分精彩，对冷锋这个角色的表现也十分到位：有勇有谋，坚毅，技艺高超，重情……期间穿插的回忆也很妥当，不会显得拖时间。</p>
<p>但是！但是！你让一个人去解救医院里面的人还有工厂里面的人这是闹哪样！编剧恐怕真的是把冷锋当成了钢铁侠，美国队长一个人恐怕都完成不了任务……讲道理我觉得冷锋如果去美国真的可以加入复仇者联盟了，我感觉他甚至可以取代美国队长的位置了（虽然感觉打不过美国队长）。</p>
<p>整部电影后半段就纯粹变成爽片了，不过在爽的同时，电影刻画了一些小人物，比如在医院里面的医生，以及工厂里面为了保护女主两人而挺身而出面对子弹的工厂的工人们，还有就是工厂里面贪生怕死的厂长。这些人物虽然占的戏份比较少，但是都比较鲜活。</p>
<p>另外一个值得一提的人物就是张翰演的富二代卓亦凡（不知道这个名字是不是在暗指某吴姓小鲜肉），从一开始的挂着骚红的 beats 耳机登场，到后来的一些明显是没有经历过真实战争的言行。张翰的本色出演，将这样一个叛逆的公子的形象表现的淋漓尽致，和人物的定位十分贴合。而后面的人物的转变也刻画得很不错，虽然还是很坑，不过为主角战队增加了重要的战力，还有一些小小的笑点。</p>
<p>至于爱国情怀？我感觉打得有点过了，诚然祖国如今已经是十分强大，撤侨工作每次也做得十分到位及时，但是在这一部电影里面却有一种刻意地渲染以至于有些矫情了……还有就是中国的舰队在这次事情中提供的帮助真的太有限了……不过最后所有舰队的导弹的轰鸣还是十分让人热血沸腾的。</p>
<p>总之这是一部比较成功的商业大片，演员演技全程在线，作为一部爽片还是让人感觉很不错的，只是剧情还有一些硬伤，作为一个非魔幻的片还是应该“真”一点，还有就是不知道这个反派是不是在《战狼 1》中出现过，感觉他的行为全程都令人莫名奇妙……</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10.</p>
<p>特效动作都十分到位，整体也很激动人心，去电影院一起狂欢一下也是极好的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《战狼-2》&quot;&gt;&lt;a href=&quot;#《战狼-2》&quot; class=&quot;headerlink&quot; title=&quot;《战狼 2》&quot;&gt;&lt;/a&gt;《战狼 2》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="国产电影" scheme="https://blog.patrickcty.cc/tags/%E5%9B%BD%E4%BA%A7%E7%94%B5%E5%BD%B1/"/>
    
      <category term="战争片" scheme="https://blog.patrickcty.cc/tags/%E6%88%98%E4%BA%89%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>《蝙蝠侠》黑暗骑士三部曲</title>
    <link href="https://blog.patrickcty.cc/2017/08/11/%E3%80%8A%E8%9D%99%E8%9D%A0%E4%BE%A0%E3%80%8B%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>https://blog.patrickcty.cc/2017/08/11/《蝙蝠侠》黑暗骑士三部曲/</id>
    <published>2017-08-11T08:44:56.000Z</published>
    <updated>2017-08-11T08:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蝙蝠侠》黑暗骑士三部曲"><a href="#《蝙蝠侠》黑暗骑士三部曲" class="headerlink" title="《蝙蝠侠》黑暗骑士三部曲"></a>《蝙蝠侠》黑暗骑士三部曲</h1><p>在看完黑暗骑士之后，我又决定把剩下的两部看完，在看完整个三部之后，我少有的有了一种意犹未尽想看下一部的感觉。</p>
<p>大家觉得黑暗骑士三部曲经典，多是因为诺兰刻画出了一个真正的蝙蝠侠——一个一心想拯救自己父母曾全力保护的高谭市的人。而不仅仅是一个无所不能，令犯罪分子闻风丧胆的超级英雄。作为一个活生生的人，蝙蝠侠也拥有迷茫，也会害怕，也会愤怒，也正是通过这些情绪的表达，让电影不再那么模式化，让电影有了新的活力。</p>
<p>第一部《蝙蝠侠：侠影之谜》是蝙蝠侠找到自我的过程，从一个无忧无虑的富二代公子，到目睹自己父母被枪杀之后被愤怒蒙蔽双眼，再到谋杀父母的仇人被更加有后台的人枪杀之后对犯罪的迷茫，再到跟着忍者大师找回自我，于是蝙蝠侠就此产生。</p>
<p>小时候掉进蝙蝠洞的经历让他拥有了深入内心的恐惧，而这恐惧在间接中促进了他父母的死亡，于是仇恨的种子也在内心中植下。但是当仇人死亡以及被黑帮老大嘲讽之后，仇恨悄然消失，取而代之的是迷茫，这时的韦恩选择了流浪，亲身去经历犯罪，亲身感受犯罪。</p>
<p>而忍者大师的指点，帮助了他去直面自己的恐惧并且控制自己的愤怒。这部分的描绘比较写意，不过这样和意境确实契合得十分好。</p>
<p>尽管忍者大师能帮他控制情绪，但是自己的路还是要靠自己去开创，在学会控制情绪之后，韦恩也找到了自己的路，但是这条路和影武者联盟所信奉的道路产生了冲突。为了坚持自己的道路——不杀人，他让影武者联盟的房子陷入了火海，“忍者大师”也因此死亡，韦恩的师傅杜卡也陷入昏迷。</p>
<p>这部分我感觉处理的不是很好，韦恩的原则是不杀人，但是在这里他间接杀死了和自己理念不同的“忍者大师”，这难道就不违背他的原则么？而且因为这次的事情，影武者联盟的房子都被毁于一旦，成员也有死伤。从后面的剧情来看，在这里即使“忍者大师”不死，对后面的剧情也没有什么很大的影响，这个地方我觉得是败笔。</p>
<p>不过也因为有了这一段的经历，韦恩终于找到了自己要走的路，他也有了实现自己理想所需要的品质，于是蝙蝠侠就这样诞生了。</p>
<p>电影的节奏把握得极好，感觉我们在跟着韦恩一起，见证着他的成长，这种感觉让观众对蝙蝠侠有了更深的感触，电影的代入感也更强。</p>
<p>第一部讲的是蝙蝠侠的成长，而第二部则是蝙蝠侠和精通犯罪小丑的比赛中输掉了，并“元气大伤”，失去了目标，陷入了谷底，此时高谭市已经情况好转，但这也意味着蝙蝠侠复出的可能性更小了。在这样的情况下，他遇到了“最可怕的敌人”，和他一样师出忍者大师的贝恩。贝恩的强不仅仅在于他的武艺，更是因为他出身黑暗与绝望并适应黑暗与绝望，并且有着一群忠心耿耿的手下。在这样的情况下，蝙蝠侠又怎么会是他的对手？于是蝙蝠侠也被送入了他曾待过的绝望的监狱中，其实在被送进来之前，蝙蝠侠就已经身处谷底，而这个监狱，反而再次给了他崛起的契机——重新找回存在的意义，唤醒起恐惧，因为就像医生所说：“恐惧会祝你一臂之力”。而正是这样的考验下，蝙蝠侠终于找回自我，完成了崛起。</p>
<p>而另一方面在布莱克警探和戈登局长的带领下，被贝恩支配的高谭市内的人也没有放弃，但是蝙蝠侠的缺席总是让他们群龙无首，而蝙蝠侠的出现也终于将他们凝聚了起来，高潮时那一群只有普通手枪的警察面对装备精良的贝恩一群人不畏惧而毅然冲上去的场景让我感觉很震撼，在危急时刻即使是害怕死亡的人也会完成觉醒。</p>
<p>这黑暗骑士三部曲中，充分探讨了人性，从蝙蝠侠的角度——一切都是为了高谭市；从最关心蝙蝠侠人的角度——成为蝙蝠侠并不是拯救城市的唯一方法；从普通人的角度——人们可能会因为恐惧成为罪恶的爪牙，但是当真正被逼入绝境，即使是普通人也会觉醒；从反派的角度——为了贯彻自己的理念，为了纯粹的犯罪，为了复仇以及完成父亲/师傅未完成的目标。</p>
<p>三部电影，既有深度，也保持了商业片应该具有的震撼的大场面，精彩的故事情节，以及蝙蝠侠的个人英雄主义。尽管每一部都差不多有两个半小时，但是每一部的节奏都把握得很好，完全不会觉得过于冗长。真的值得一看！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《蝙蝠侠》黑暗骑士三部曲&quot;&gt;&lt;a href=&quot;#《蝙蝠侠》黑暗骑士三部曲&quot; class=&quot;headerlink&quot; title=&quot;《蝙蝠侠》黑暗骑士三部曲&quot;&gt;&lt;/a&gt;《蝙蝠侠》黑暗骑士三部曲&lt;/h1&gt;&lt;p&gt;在看完黑暗骑士之后，我又决定把剩下的两部看完，在看完整个三部
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="蝙蝠侠" scheme="https://blog.patrickcty.cc/tags/%E8%9D%99%E8%9D%A0%E4%BE%A0/"/>
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>再次理解Flask中RESTfulAPI</title>
    <link href="https://blog.patrickcty.cc/2017/08/10/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADRESTfulAPI/"/>
    <id>https://blog.patrickcty.cc/2017/08/10/再次理解Flask中RESTfulAPI/</id>
    <published>2017-08-10T07:40:22.000Z</published>
    <updated>2017-08-10T07:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-RESTful-API"><a href="#再次理解-Flask-中-RESTful-API" class="headerlink" title="再次理解 Flask 中 RESTful API"></a>再次理解 Flask 中 RESTful API</h1><p>用 Flask 构建 RESTful 有两种方法，一种是狗书中用到的方法，把视图“包装”成 API —— 视图函数完成 API 所需要的功能，但最后返回的不再是一个 HTML 文件，而是由所需要的数据构成的 JSON。</p>
<p>而另一种方法就是使用 flask-restful 扩展来构建 API 了，利用专有的类来作为 REST 的资源部分，通过资源类的不同方法来处理不同的 http 请求，最后以 JSON 格式返回数据，具体步骤如下：</p>
<ul>
<li><p>初始化扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Api</div><div class="line"></div><div class="line">rest_api = Api()</div></pre></td></tr></table></figure>
</li>
<li><p>自定义资源类以及相应的请求方法（对应了一个路由）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Resource</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    # 如果用没有定义的请求方法访问则会返回 405 错误</div><div class="line">    def get(self):</div><div class="line">        pass</div><div class="line">    def post(self):</div><div class="line">        pass</div><div class="line">    def put(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
</li>
<li><p>初始化 API 对象路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from .extensions import rest_api</div><div class="line">from .controller.rest.post import PostApi</div><div class="line"></div><div class="line">def create_app(object_name):</div><div class="line">    ...</div><div class="line">    # 如果是多个路由则要分别绑定</div><div class="line">    rest_api.add_resource(PostApi, &apos;/api/post&apos;, &apos;/api/post/&lt;int:post_id&gt;&apos;)</div><div class="line">    rest_api.add_resource(AnotherApi, &apos;/api/another&apos;)</div><div class="line">    rest_api.init_app(app)</div></pre></td></tr></table></figure>
</li>
<li><p>JSON 化输出格式</p>
</li>
</ul>
<p>JSON 化也同样有两种方法：</p>
<ul>
<li>第一种是使用 flask.jsonify() 把数据手动转换成 JSON 对象再返回。</li>
<li><p>第二种则是使用 field 对象和 mashal_with 函数来进行转换，返回直接返回原来的对象即可。这种方法通过一个由 field 定义的 dict 来说明要转化输出的内容，并且把它传递给 mashal_with 装饰器，最后在返回之前自动转换成相应的 JSON 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Resource, fields, mashal_with</div><div class="line"></div><div class="line">nested_tag_fields = &#123;</div><div class="line">    &apos;id&apos;: fields.Integer(),</div><div class="line">    &apos;title&apos;: fields.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line">post_fields = &#123;</div><div class="line">    # 字符串 field，从对象的 .user.username 中取出值作为值</div><div class="line">    &apos;author&apos;: fields.String(attribute=lambda x: x.user.username), </div><div class="line">    &apos;title&apos;: fields.String(),</div><div class="line">    &apos;text&apos;: HTMLField(),  # 自定义 field</div><div class="line">    # list field，转换后成为 JSON list</div><div class="line">    # 内层为一个特殊的 field，是另外一个 JSON 对象，它是用另一个字段对象构成的</div><div class="line">    &apos;tags&apos;: fields.List(fields.Nested(nested_tag_fields)),</div><div class="line">    &apos;publish_time&apos;: fields.DateTime(dt_format=&apos;iso8601&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    @marshal_with(post_fields)  # 对象的属性会根据这个 dict 来转换</div><div class="line">    def get(self, post_id=None):</div><div class="line">        if post_id:</div><div class="line">            post = Post.query.get(post_id)</div><div class="line">            if not post:</div><div class="line">                abort(404)</div><div class="line">            return post  # 返回的 post 的内容已经被转换格式了</div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
<li><p>接收请求参数</p>
</li>
</ul>
<p>定义 parser<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">post_get_parser = reqparse.RequestParser()  # 初始化 parser</div><div class="line">post_get_parser.add_argument(  # 在 parser 中添加参数以及相应规则</div><div class="line">    &apos;page&apos;,</div><div class="line">    type=int,</div><div class="line">    location=[&apos;args&apos;, &apos;header&apos;],</div><div class="line">    required=False</div><div class="line">)</div><div class="line">post_get_parser.add_argument(</div><div class="line">    &apos;user&apos;,</div><div class="line">    type=str,</div><div class="line">    location=[&apos;json&apos;, &apos;args&apos;, &apos;headers&apos;]</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>使用 parser<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from .parsers import post_get_parser</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    def get(self, post_id=None):</div><div class="line">        ...</div><div class="line">        # 使用 parser 解析参数</div><div class="line">        # 解析出来的可以像 dict 引用</div><div class="line">        # 例如 args[&apos;user&apos;]</div><div class="line">        args = post_get_parser.parse_args()</div></pre></td></tr></table></figure></p>
<ul>
<li>身份验证</li>
</ul>
<p>使用 access token 来进行身份认证，要完成身份认证要先通过一个 API 来进行登录验证，如果通过就返回 token，之后就根据 token 来进行相应的权限操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># parser 也是要定义的</div><div class="line">class AuthApi(Resource):</div><div class="line">    def post(self):</div><div class="line">        args = user_post_parser.parse_args()</div><div class="line">        user = User.query.filter_by(</div><div class="line">            username=args[&apos;username&apos;]</div><div class="line">        ).one()</div><div class="line"></div><div class="line">        # 检验密码</div><div class="line">        if user.verify_password(args[&apos;password&apos;]):</div><div class="line">            # 通过了才生成令牌</div><div class="line">            s = Serializer(</div><div class="line">                current_app.config[&apos;SECRET_KEY&apos;],</div><div class="line">                expires_in=600</div><div class="line">            )</div><div class="line">            # 返回令牌，注意 dumps 出来的数据是 byte 类型的，要根据编码改成 utf-8 才能成为 JSON 内容</div><div class="line">            return &#123;&quot;token&quot;: s.dumps(&#123;&apos;id&apos;: user.id&#125;).decode(&apos;utf-8&apos;)&#125;</div><div class="line"></div><div class="line">        else:</div><div class="line">            abort(401)</div></pre></td></tr></table></figure>
<p>验证令牌的话在 User 类中添加一个类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class User(db.Model, UserMixin):</div><div class="line">    ...</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def verify_auth_token(token):</div><div class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;])</div><div class="line"></div><div class="line">        try:</div><div class="line">            data = s.loads(token)</div><div class="line">        except SignatureExpired:</div><div class="line">            return None</div><div class="line">        except BadSignature:</div><div class="line">            return None</div><div class="line">        user = User.query.get(data[&apos;id&apos;])</div><div class="line">        return user</div></pre></td></tr></table></figure></p>
<p>要使用的话就在资源类的方法中调用这个类方法来返回 user 对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-RESTful-API&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 RESTful API&quot;&gt;&lt;/a&gt;再次理解 Flask 中 R
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="REST API" scheme="https://blog.patrickcty.cc/tags/REST-API/"/>
    
  </entry>
  
  <entry>
    <title>再次理解Flask中登录与用户角色</title>
    <link href="https://blog.patrickcty.cc/2017/08/08/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E7%99%BB%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2/"/>
    <id>https://blog.patrickcty.cc/2017/08/08/再次理解Flask中登录与用户角色/</id>
    <published>2017-08-08T12:31:17.000Z</published>
    <updated>2017-08-08T12:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中登录与用户角色"><a href="#再次理解-Flask-中登录与用户角色" class="headerlink" title="再次理解 Flask 中登录与用户角色"></a>再次理解 Flask 中登录与用户角色</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录由以下几个部分构成：</p>
<ul>
<li>填写表单</li>
<li>验证用户信息是否正确</li>
<li>保存登录状态</li>
</ul>
<h3 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h3><p>填写表单这个应该没什么好说的，但是可以让表单更高级——加入验证码。</p>
<p>在这里我是用的 GeeTest。</p>
<p>接入方法：</p>
<ul>
<li>在其官网下载对应语言的 SDK，其中 Python 的 SDK 包括一个 geetest 的包以及一个用来注入到 HTML 中的 js 文件</li>
<li><p>在 HTML 中给验证码留出相应的位置，第一个控标签除就是验证码所在标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;col s12&quot; id=&quot;embed-captcha&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;col s12&quot;&gt;</div><div class="line">    &lt;p id=&quot;wait&quot; class=&quot;show&quot; style=&quot;color: #ee6e73&quot;&gt;正在加载验证码......&lt;/p&gt;</div><div class="line">    &lt;p id=&quot;notice&quot; class=&quot;hide&quot; style=&quot;color: red&quot;&gt;请先拖动验证码到相应位置&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>引入所给 js 文件，并且进行初始化，这部分只用复制下面的结构然后稍微改动即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;js/gt.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">        var handlerEmbed = function (captchaObj) &#123;</div><div class="line">            $(&quot;#embed-submit&quot;).click(function (e) &#123;</div><div class="line">                var validate = captchaObj.getValidate();</div><div class="line">                if (!validate) &#123;</div><div class="line">                    $(&quot;#notice&quot;)[0].className = &quot;show&quot;;</div><div class="line">                    setTimeout(function () &#123;</div><div class="line">                        $(&quot;#notice&quot;)[0].className = &quot;hide&quot;;</div><div class="line">                    &#125;, 2000);</div><div class="line">                    e.preventDefault();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            // 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode</div><div class="line">            captchaObj.appendTo(&quot;#embed-captcha&quot;);</div><div class="line">            captchaObj.onReady(function () &#123;</div><div class="line">                $(&quot;#wait&quot;)[0].className = &quot;hide&quot;;</div><div class="line">            &#125;);</div><div class="line">            // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            // 获取id，challenge，success（是否启用failback）</div><div class="line">            url: &quot;/pc-geetest/register?t=&quot; + (new Date()).getTime(), // 加随机数防止缓存</div><div class="line">            type: &quot;get&quot;,</div><div class="line">            dataType: &quot;json&quot;,</div><div class="line">            success: function (data) &#123;</div><div class="line">                // 使用initGeetest接口</div><div class="line">                // 参数1：配置参数</div><div class="line">                // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件</div><div class="line">                initGeetest(&#123;</div><div class="line">                    gt: data.gt,</div><div class="line">                    challenge: data.challenge,</div><div class="line">                    product: &quot;embed&quot;, // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效</div><div class="line">                    offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注</div><div class="line">                    width: &apos;25%&apos;</div><div class="line">                    // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config</div><div class="line">                &#125;, handlerEmbed);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>验证验证码状态（其实这部分也不用添加，不过添加了能更进一步提升可靠性，具体参阅官方文档）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 这个视图函数必须添加</div><div class="line">@main_blueprint.route(&apos;/pc-geetest/register&apos;, methods=[&apos;GET&apos;])</div><div class="line">def get_pc_captcha():</div><div class="line">    gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">    status = gt.pre_process()</div><div class="line">    session[gt.GT_STATUS_SESSION_KEY] = status</div><div class="line">    response_str = gt.get_response_str()</div><div class="line">    return response_str</div><div class="line"></div><div class="line"></div><div class="line">@main_blueprint.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    form = LoginForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        # 这下面添加了能提升可靠性，也可以不添加</div><div class="line">        gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">        challenge = request.form[gt.FN_CHALLENGE]</div><div class="line">        validate = request.form[gt.FN_VALIDATE]</div><div class="line">        seccode = request.form[gt.FN_SECCODE]</div><div class="line">        status = session[gt.GT_STATUS_SESSION_KEY]</div><div class="line">        if status:</div><div class="line">            result = gt.success_validate(challenge, validate, seccode)</div><div class="line">        else:</div><div class="line">            result = gt.failback_validate(challenge, validate, seccode)</div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证用户信息"><a href="#验证用户信息" class="headerlink" title="验证用户信息"></a>验证用户信息</h3><p>平常我们都是在视图函数中来检验密码是否是正确，但实际上和验证表单内容是否合法一样，这个工作也可以在表单类中完成。</p>
<p>我们在视图函数中通过 form.validate_on_submit 来检查表单是否被成功提交，实际上在返回结果之前我们要先调用 form.validate 函数，也正是在这里面，我们完成对表单内容合法性和密码正确性的检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class LoginForm(FlaskForm):</div><div class="line">    username = StringField(&apos;用户名&apos;, [DataRequired(), Length(max=255)])</div><div class="line">    password = PasswordField(&apos;密码&apos;, [DataRequired()])</div><div class="line">    remember_me = BooleanField(&apos;记住登录状态&apos;)</div><div class="line"></div><div class="line">    def validate(self):  # 在 validate_on_submit 的时候会检查</div><div class="line">        check_validate = super(LoginForm, self).validate()</div><div class="line"></div><div class="line">        if not check_validate:</div><div class="line">            return False</div><div class="line"></div><div class="line">        user = User.query.filter_by(username=self.username.data).first()</div><div class="line">        if not user:</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        if not user.verify_password(self.password.data):</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        return True</div></pre></td></tr></table></figure>
<p>如果出现了错误则只用把它添加到相应表单的 errors 中去，然后就可以在 HTML 中显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;input-field col s12&quot;&gt;</div><div class="line">    &#123;&#123; form.password.label &#125;&#125;</div><div class="line">    &#123;&#123; form.password(class_=&apos;validate&apos;) &#125;&#125;</div><div class="line">    &#123;% if form.password.errors %&#125;</div><div class="line">        &#123;% for e in form.password.errors %&#125;</div><div class="line">            &lt;p class=&quot;help-block alert-danger&quot;&gt;&#123;&#123; e &#125;&#125;&lt;/p&gt;</div><div class="line">        &#123;% endfor %&#125;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="保存登录状态"><a href="#保存登录状态" class="headerlink" title="保存登录状态"></a>保存登录状态</h3><p>最基本的方法当然是使用 session 来保存，然后通过判断 session 是否有相应的信息来检查是否登录处于状态。</p>
<p>比较常用也是进阶的就是使用 flask-login 了。</p>
<p>使用 flask-login 需要根据模块来进行一定的配置：</p>
<ul>
<li>对 User 类实现特定的方法，这里可以通过继承 UserMixin 来简化，但是要注意如果用户 id 的格式和默认的不同则还是要重写 get_id 方法</li>
<li>定义登陆的视图，load_user 函数等<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">login_manger = LoginManager()</div><div class="line">login_manger.login_view = &apos;main.login&apos;</div><div class="line">login_manger.session_protection = &apos;strong&apos;</div><div class="line">login_manger.login_message = &apos;请登录以访问该页面&apos;</div><div class="line">login_manger.login_message_category = &apos;info&apos;</div><div class="line"></div><div class="line"></div><div class="line">@login_manger.user_loader</div><div class="line">def load_user(userid):</div><div class="line">    from .models import User</div><div class="line">    return User.query.get(userid)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><p>要使用用户权限，则要进行用户角色的相应配置，在这里可以使用 flask-principal 模块来对用户权限进行管理。</p>
<p>当然我们要先建立一张表来控制用户和用户角色的多对多关系，在建立数据库之后不要忘记初始化角色表。</p>
<p>flask-principal 的关键名词主要有 Identity，Permission，Need。其中 Identity 和 Permission 都是通过 Need 来实现功能。Need 则是一些 namedtuple（相当于 C 语言中的结构体），包括 method 和 value 两个属性，定义了每种身份可以干什么。</p>
<p>例如 UserNeed 的 method 默认则是 id，key 则应该传入对应用户的 id 值，而 RoleNeed 的 method 的默认值则是 role，key 的默认值应该是 role 的名称。其中 UserNeed 和 RoleNeed 是通过 partical 固定了 Need 的一个参数。点击查看 <a href="http://www.jb51.net/article/87059.htm" target="_blank" rel="external">nametuple</a> 和 <a href="http://www.wklken.me/posts/2013/08/18/python-extra-functools.html" target="_blank" rel="external">partical</a> 用法。</p>
<p>Identity 是通过 user.id 来进行初始化的，然后此时会自动调用自己定义的初始化函数把需要添加的 Need 添加进这个 Identity 中。</p>
<p>在 __init__.py 中定义这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@identity_loaded.connect_via(app)</div><div class="line">def on_identity_loaded(sender, identity):</div><div class="line">    identity.user = current_user</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;id&apos;):</div><div class="line">        identity.provides.add(UserNeed(current_user.id))</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;roles&apos;):</div><div class="line">        for role in current_user.roles:</div><div class="line">            identity.provides.add(RoleNeed(role.name))</div></pre></td></tr></table></figure></p>
<p>而当用户登录登出时 Identity 应该发生改变，此时应该调用 identity_changed 方法来发送信号，此时就会调用 on_identity_loaded 函数来进行新 Identity 的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">identity_changed.send(</div><div class="line">    current_app._get_current_object(),</div><div class="line">    identity=Identity(user.id)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>而 Permission 则是通过 Need 来进行初始化，这些 Need 就表示当前权限所需的角色，只有满足了相应的角色才能达到相应权限。</p>
<p>初始化 Permission<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div></pre></td></tr></table></figure></p>
<p>使用 Permission 的方法：</p>
<ul>
<li><p>使用初始化权限的装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@login_required</div><div class="line">@poster_permission.require(http_exception=403)</div><div class="line">def edit(id):</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
<li><p>使用 Permission.can() 来判断是否符合权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">permission = Permission(UserNeed(post.user.id))</div><div class="line"></div><div class="line"># 发布者和管理员都有权限</div><div class="line">if permission.can() or admin_permission.can():</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中登录与用户角色&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中登录与用户角色&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中登录与用户角色&quot;&gt;&lt;/a&gt;再次理解 Flask 中登录与用户角色&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>《卑鄙的我3》</title>
    <link href="https://blog.patrickcty.cc/2017/08/06/%E3%80%8A%E5%8D%91%E9%84%99%E7%9A%84%E6%88%913%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/06/《卑鄙的我3》/</id>
    <published>2017-08-06T12:26:34.000Z</published>
    <updated>2017-08-06T12:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《卑鄙的我-3》"><a href="#《卑鄙的我-3》" class="headerlink" title="《卑鄙的我 3》"></a>《卑鄙的我 3》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>又是一部新的卑鄙的我，当它上映的时候我就决定去看看，一是因为小黄人，再者则是格鲁在前作中给人的印象太深刻。</p>
<p>虽然在国内这部电影的名字被翻译成了神偷奶爸，但是我还是更愿意称它为卑鄙的我，但是当卑鄙的我不再卑鄙，这部电影又是否保留着原来的惊喜呢？</p>
<p>在刚开始看电影的时候我就有一种强烈的看过的感觉，原来是很久之前看的预告片，但回想起来看了预告片之后，正片反而没什么惊喜可言了……</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于上面的问题，答案是没有惊喜。在这一部里，格鲁已经从良，并因为任务失败被赶出了反恶人联盟。而此时格鲁则像一个遭遇了失业危机的中年男人，完全没有了作为一个反派的那种个性十足的感觉。</p>
<p>因为家庭元素的发展，特别是露西的出现，使得格鲁失去了重新成为坏人的可能，所以这一部的发展，也完全被这样的条件所限制住。但编剧为了冲破这样的限制，又让格鲁在他孪生弟弟面前演了一次坏人，不过这也无力回天，因为已经没有了坏人的灵魂，所以这部分注定不会那么精彩。</p>
<p>而作为本片的一大看点，小黄人的戏份却着实的少，甚至都没能出现在主线中。而小黄人的出走，似乎是编剧自己在吐槽格鲁从良这一设定。不过小黄人出现的地方还是保持了之前萌萌的风格，也算是本片为数不多的亮点了吧。</p>
<p>而露西和格鲁的女儿们的戏份简直可有可无，格鲁的女儿也没有把第一二部时的的萌萌的感觉再表现出来，它们的出场，似乎只是为了把时间给拖住，不然片长恐怕就不够了。</p>
<p>至于德鲁，不得不说人和人之间总是有差距 233。他的出场是一个亮点，然而这部分在预告片里面已经播出了，这就进一步减小了戏剧性……不过他的耍宝的风格还是带来了不少的欢乐，也正是有了他，才让格鲁的行动不那么轻松无趣，也让剧情不那么沉闷。我倒是很期待他在后作中和小黄人们一起四处做坏事，只是不知道他的技巧会不会有所长进 233，不然就 GG 了 233。至于德鲁的话，还是让他在家享受天伦之乐吧 233。</p>
<p>卑鄙的我系列其实到第二部就应该算作结束了，不过只要小黄人在，就不用担心没有故事可讲，期待小黄人大眼萌的续作～</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>7/10.</p>
<p>小黄人依旧精彩，但是德鲁已经失去了之前的魅力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《卑鄙的我-3》&quot;&gt;&lt;a href=&quot;#《卑鄙的我-3》&quot; class=&quot;headerlink&quot; title=&quot;《卑鄙的我 3》&quot;&gt;&lt;/a&gt;《卑鄙的我 3》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="小黄人" scheme="https://blog.patrickcty.cc/tags/%E5%B0%8F%E9%BB%84%E4%BA%BA/"/>
    
      <category term="卑鄙的我" scheme="https://blog.patrickcty.cc/tags/%E5%8D%91%E9%84%99%E7%9A%84%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>《蝙蝠侠：黑暗骑士》</title>
    <link href="https://blog.patrickcty.cc/2017/08/05/%E3%80%8A%E8%9D%99%E8%9D%A0%E4%BE%A0%EF%BC%9A%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/05/《蝙蝠侠：黑暗骑士》/</id>
    <published>2017-08-05T03:35:13.000Z</published>
    <updated>2017-08-05T03:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蝙蝠侠：黑暗骑士》"><a href="#《蝙蝠侠：黑暗骑士》" class="headerlink" title="《蝙蝠侠：黑暗骑士》"></a>《蝙蝠侠：黑暗骑士》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>都说诺兰是鬼才导演，这话真的不夸张。从我最早看的《蝙蝠侠：黑暗骑士的崛起》（那时候看的还是枪版，虽然画面模模糊糊，不过剧情真的感觉很不错，特别是蝙蝠侠在谷底挣扎的情景。不过因为年代久远，影片剧情都记不太清了，因此决定以后再刷一遍～），到之后看的《致命魔术》（当时真的感觉剧情碉堡了，不过因为是在学校看的，所以剧情可能有的地方错过了，同样决定再刷一遍～），再到之后看的《星际穿越》（这部充满物理知识的科幻片对于我这个理科男真的十分有吸引力，剧情也一如既往的神～），再就是之后看的《记忆碎片》（也是一部神片，拍摄手法真的是无敌，看完之后还是一脸懵逼，最终还是根据影评才梳理清楚了剧情 233），他的每一部电影都有不同的魔力，却又都有共同点，那就是剧情精彩，令人回味。</p>
<p>这晚我又十分想看电影，但又苦于近期没什么好看的电影，于是在豆瓣 Top 250 上寻找，看到了这一部之后我就知道我想看的是什么了。同时这一部是小丑加持，人们都说小丑塑造了反派的巅峰，之前小丑扮演者去世周年的时候还引发了一阵朋友圈悼念狂潮，这样的电影，当然要好好看一看～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>蝙蝠侠电影历来都是比较黑暗的，蝙蝠侠所在的城市高谭市给人的印象也总是充满了犯罪，即使有了蝙蝠侠的存在。而在本部电影中充满正义感的检察官哈维·登特的登场，使得蝙蝠侠的任务变得轻松起来。但是这个时候小丑出现了，小丑和蝙蝠侠就好像是正义和邪恶的两个极端。蝙蝠侠在现实生活中是一个亿万富翁，因此他成为蝙蝠侠的目的不是为了金钱和名誉，而是为了自己贯彻的理念，而类似的是，小丑嫌弃犯罪狂潮，也不是为了金钱地位，而是纯粹为了报复社会，让社会陷入混乱。也正是因为有了蝙蝠侠的映衬，小丑的形象才会这么丰满，但小丑也正是抓住了蝙蝠侠的弱点，才能如此肆无忌惮。</p>
<p>小丑是一个精通犯罪学的人，他能在一次次的行动中把所有人都戏耍得团团转，无论是各个黑帮大佬，还是警察局的各位，甚至连民众舆论以及蝙蝠侠都被他戏耍。从他第一次登场抢劫银行的情景就能察觉到，他抓住了同伙贪婪的心理，让他们除掉会分走自己钱的同伙，从而使受益者只有他一个。</p>
<p>小丑强就强大在他强大的威慑能力，他通过蝙蝠侠威慑了那一群黑帮大佬，使他们能与自己合作。而他通过同样的手段威慑了法官，警察局长他们身边的人，又用法官和局长的死亡进一步威慑了正义和群众。而他又通过“不交出蝙蝠侠则每天杀一个人”成功地把矛盾引向了蝙蝠侠，一瞬间保卫城市的黑暗骑士变成了威胁他们生存的存在。</p>
<p>此时还有两个关键，一个是哈维，一个是瑞秋。哈维是新上任到高谭市的白色骑士，是光明中的正义的象征，他为了正义不惧死亡，但这样的他实际上也并不是绝对正义，而“双面人”的称号也正是因为他的一些和正面形象完全不同的动作而形成的，这从他用私刑来逼供刺杀市长的犯人可以窥见——尽管硬币的两面都是正面，也就是说他并不会真的杀掉犯人。只是在这时他的另一面在外部环境的影响下控制得很好。</p>
<p>而小丑说过：“疯狂与混乱本身拥有着强大的引力。有时需要的只是轻轻一推。”，小丑要做的，就是轻轻地推动，让正义的象征哈维和蝙蝠侠堕入黑暗，那么他的目的就完美达到了。</p>
<p>故事真正的高潮是在刺杀市长事件之后蝙蝠侠被逼到了绝境，此时因为小丑的威慑，人民的矛盾都指向了蝙蝠侠，蝙蝠侠只得显出真身来平息民众的恐惧，而崇拜蝙蝠侠的哈维则决定以自己为诱饵，让蝙蝠侠抓住小丑。当蝙蝠侠就要抓到小丑的时候，小丑却利用了蝙蝠侠的底线——不杀人成功让蝙蝠侠没有撞向他而是偏离了方向。</p>
<p>而另一个关键瑞秋则是小丑用来操控蝙蝠侠和哈维的重要工具，因为两人都很爱她，她成为了两人的软肋。小丑就利用了这一点先让蝙蝠侠在哈维和瑞秋之间做出选择，只能拯救一个，而之后故意告诉错误地点的他则让蝙蝠侠没能救出所爱瑞秋而陷入了深深的自责，也让哈维精神崩溃。在这场事故中哈维的半边脸也被烧毁，成为了真正的“双面人”。</p>
<p>尽管小丑很想除掉蝙蝠侠，但是当真正想公布蝙蝠侠身份的人出现后他却要人们杀掉他，否则炸掉医院。当然从小丑的作风来不管结果如何，医院一定会被炸掉，因为他追求的是混乱和黑暗。哈维的黑暗，在和小丑的交谈中被真正触发了，他没有杀掉始作俑者小丑，却向间接害死瑞秋的人寻仇。最终哈维在处决戈登的时候被蝙蝠侠推下楼死亡，蝙蝠侠则背上了罪名，消失了……</p>
<p>小丑成功的地方就是他的疯狂，他用他疯狂却又实际上抓住弱点的行为来操控了其他人，达到自己的目的。而他的伎俩让蝙蝠侠陷入迷茫，让哈维堕入黑暗。虽然他最后败在了蝙蝠侠手上，但是实际上是他赢了。因为他所在意的，从在都不是他的性命，也正是这让他如此疯狂又可怕。而蝙蝠侠最后选择背负罪名，则让小丑胜利的影响降到了最低——民众没有失去战胜黑暗的信心。</p>
<p>而小丑也不是次次都胜利，在炸掉逃生船的社会实验中，最终两艘船都选择了不去按起爆按钮，这次人们没有被小丑威慑住，因为有更深的东西威慑到了他们——人性，按下了按钮则表示你要对另一条船的所有生命负责。因此即使是一开始吵着要按下按钮的秃头大叔，到最后真正有执行权的时候却也不敢下手。而更令我惊讶的是黑帮大佬在拿到起爆器之后居然直接将其丢向了窗外，这里真的值得深思。或许善恶之间真的没有那么多界限，所谓的善人，不也吵吵嚷嚷要按照小丑要求处决他人，而所谓的恶人，在最考验人性的地方却又安静了下来做出了令人意想不到的选择。</p>
<p>这部电影对人性的思考是十分深刻的，其中刻画的小丑，蝙蝠侠，哈维都十分成功，而网上的口碑也真的不是吹出来的。不过整体电影有点偏长，也有点过于神化小丑，但这些无伤大雅的小毛病也不应该被过多计较。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>9/10.</p>
<p>是一部值得思考的不一样的商业片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;a href=&quot;#《蝙蝠侠：黑暗骑士》&quot; class=&quot;headerlink&quot; title=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;/a&gt;《蝙蝠侠：黑暗骑士》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;head
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="蝙蝠侠" scheme="https://blog.patrickcty.cc/tags/%E8%9D%99%E8%9D%A0%E4%BE%A0/"/>
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中视图函数的用法</title>
    <link href="https://blog.patrickcty.cc/2017/08/02/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.patrickcty.cc/2017/08/02/再次理解Flask中视图函数的用法/</id>
    <published>2017-08-02T14:24:00.000Z</published>
    <updated>2017-08-02T14:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中视图函数的用法"><a href="#再次理解-Flask-中视图函数的用法" class="headerlink" title="再次理解 Flask 中视图函数的用法"></a>再次理解 Flask 中视图函数的用法</h1><h2 id="使用类描述视图"><a href="#使用类描述视图" class="headerlink" title="使用类描述视图"></a>使用类描述视图</h2><p>在 Flask 应用中，通常是用函数来描述视图的，但是如果多个函数都用到某些通用功能则用类实现视图就非常方便。</p>
<p>多个视图函数都要渲染模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">from flask.views import View</div><div class="line"></div><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">        super(GenericView, self).__init__()</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        page = 1</div><div class="line">        posts = Post.query.order_by(</div><div class="line">            Post.publish_time.desc()</div><div class="line">        ).paginate(page, 10)</div><div class="line">        recent, top_tags = sidebar_data()</div><div class="line"></div><div class="line">        return render_template(</div><div class="line">            self.template,</div><div class="line">            posts=posts,</div><div class="line">            recent=recent,</div><div class="line">            top_tags=top_tags</div><div class="line">        )</div><div class="line"></div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;home.html&apos;</div><div class="line">    )</div><div class="line">)</div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test2&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;index.html&apos;</div><div class="line">    )</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果要使用多种 HTTP 方法，则定义类属性 methods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    methods = [&apos;GET&apos;, &apos;POST&apos;]  # 定义为类属性</div><div class="line">    </div><div class="line">    def __init__(self, template):</div><div class="line">        ...</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        if request.method == &apos;GET&apos;:</div><div class="line">            ...</div><div class="line">        elif request.method == &apos;POST&apos;:</div><div class="line">            ...</div></pre></td></tr></table></figure></p>
<h2 id="使用方法视图"><a href="#使用方法视图" class="headerlink" title="使用方法视图"></a>使用方法视图</h2><p>方法视图允许把每种 HTTP 请求的处理函数写成一个同名的类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from flask.views import MethodView</div><div class="line"></div><div class="line">class UserView(MethodView):</div><div class="line">    def get(self):</div><div class="line">        ...</div><div class="line">    def post(self):</div><div class="line">        ...</div><div class="line">    def put(self):</div><div class="line">        ...</div><div class="line">        </div><div class="line">app.add_url_rule(&apos;/user&apos;, view_func=UserView.as_view(&apos;user&apos;))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中视图函数的用法&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中视图函数的用法&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中视图函数的用法&quot;&gt;&lt;/a&gt;再次理解 Flask 中视图函数的用法&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
</feed>
