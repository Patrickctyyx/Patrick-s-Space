<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2019-03-15T11:39:28.019Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最短的捷径就是绕远路</title>
    <link href="https://blog.patrickcty.cc/2019/03/13/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%8D%B7%E5%BE%84%E5%B0%B1%E6%98%AF%E7%BB%95%E8%BF%9C%E8%B7%AF/"/>
    <id>https://blog.patrickcty.cc/2019/03/13/最短的捷径就是绕远路/</id>
    <published>2019-03-13T05:48:41.000Z</published>
    <updated>2019-03-15T11:39:28.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.jnugeek.cn/image/mangas/3992.jpeg" alt="image"></p>
<p>“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大陆的期间，我一直都遵行着这个原则。也因为多亏有你陪伴，我才得以跨越这条漫漫长路。”  ——杰洛·齐贝林</p>
<p>杰洛的 Lesson 5 到底是什么意思，在看漫画的时候我就不明白，在之后这个问题又浮上我的心头，并又困扰了我许久。在参考了其他人的理解并结合自己的思考之后，我终于有了些端倪。</p>
<p>最令我困惑的就是杰洛的“在横跨这片大陆的期间，我一直都遵行着这个原则”这句话了。众所周知，杰洛在这次 SBR 大赛之中，从来都是抄捷径走。但实际上，这些所谓的捷径，或许就是“远路”。怎么理解呢？尽管这些路在距离上是最短的，但每一次都伴随着巨大的风险与挑战，稍有不慎就直接丧失比赛资格，输掉全盘的比赛了。所以这些道路尽管读作捷径，但是却写作需要勇气、果断与智慧的远路。也正是因为这样的“绕远路”，杰洛才能在比赛中拔得头筹。他没有波克洛克的强运，但他就是凭自己的努力，取得了领先的地位。</p>
<p><img src="https://static.jnugeek.cn/image/mangas/v2-f05fc60b0d4c75e3e4c01c143170a9c1_hd.jpg" alt="image"></p>
<p>纵观整部 SBR，我最喜欢的角色就是杰洛，一个追寻答案的人，一个良师益友。这部 SBR 我看的还是太匆忙，下次观看的时候我要专注于杰洛与乔尼的成长之上。</p>
<p>绕远路就是最短的捷径，可惜这个道理我没有早点领悟。</p>
<p>3.15</p>
<p>今天在思考中，我对这句话又有了新的理解。</p>
<p>一直以来，我都是一个喜欢抄近道的人，具体说来就是尽量的偷懒。不愿意去深入思考，不愿意去深入查找资料，于是就自己作出了很多让人后悔的决定。正是因为我大学生活之中抄捷径太多了，所以现在落到了一个尴尬的境地。和我比起来，熊楚原就是一个绕远路的人。于是现在的结果就是，熊楚原不仅比我有着更扎实同时更广的专业知识，而且在思想深度上也是我所不能企及的。</p>
<p>在编程方面，我坚信的一点就是“不要重复造轮子”，但是这句话是有适用对象的——是对那些对相关方面较为熟悉的人来说的。而对于接触一个领域的新手来说，造轮子的过程就是一个熟悉的过程，当你能自己独立地造出几个轮子，就说明你对这个领域已经有相当程度的了解了，这时候如果要开发一个项目或者工程的话就可以顺利地使用别人已经造好的轮子了。要不然可能会在你想不到的地方掉进坑，耗费更多的时间。很多时候一个简单的功能我宁可花很多时间来找相关的模块也不愿意自己动手实现一下——就算只有一行代码的事，想想真的有点本末倒置了。</p>
<p>一直以来在抄捷径的过程中，我饶了很多路，真的太讽刺了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.jnugeek.cn/image/mangas/3992.jpeg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.12随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/12/3-12%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/12/3-12随想/</id>
    <published>2019-03-12T01:13:46.000Z</published>
    <updated>2019-03-12T01:33:42.708Z</updated>
    
    <content type="html"><![CDATA[<p>前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。</p>
<p>文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人们在不需要受苦的时候去追求吃苦，那就是一种非常害人的思想了。</p>
<p>在一些影视剧里面，常常会出现“忆苦思甜”的场景：一家人坐在餐桌上，吃着菜杆子，讲述着以前的苦日子。从那个苦年代过来的人非常吃这一套，而且这样的氛围真真切切能让他们回忆起之前的经历，不过对于他们的子女，这就是一顿难吃的饭以及一些不知所云的经历。忆苦思甜不是这么来的，在优渥环境中长大的人是无法想象那种艰难的情景的，你也别想他们能从中学到珍惜现在。</p>
<p>要让他们珍惜当下，培养他们的同理心，最好的方法就是实践。有条件的话可以去偏远山区去探望那里的儿童，让子女亲自把物资交给他们，让他们亲自感受一下安稳的生活是并不是理所当然；即使去不了偏远山区也可以去孤儿院这些地方去看看。形式从来都没那么重要，重要的是一种真真切切的感情，你说这样就比吃菜杆子更加的苦吗？完全没有啊！但这样的效果却比吃菜杆子来的不知道有多好，甚至还可以在回程的路上，在他们还没有回到他们熟悉的舒服环境之前，再给他们讲讲过去的苦日子，这样一来就能让他们有更深的感触。</p>
<p>最后我想说的是，很多人的吃苦就是一种假把式，用来麻痹自己，让自己心安理得，真正是因为懒还是因为别的什么的原因个人自己心里都有数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。&lt;/p&gt;
&lt;p&gt;文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试准备指二零零七到二零一二上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/09/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E6%8C%87%E4%BA%8C%E9%9B%B6%E9%9B%B6%E4%B8%83%E5%88%B0%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%BA%8C%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/09/复试准备指二零零七到二零一二上机题/</id>
    <published>2019-03-09T03:21:35.000Z</published>
    <updated>2019-03-09T03:21:51.633Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程输出 出列编号的序列。</li>
</ol>
<p>例：</p>
<p>若 N=3,C=1,则出列编号的序列为 1，2，3</p>
<p>若 N=3,C=2,则出列编号的序列为 2，1，3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n, c;</div><div class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;</div><div class="line">        int out[1000] = &#123;0&#125;;</div><div class="line">        int cnt = n;  // 没有出列的人数</div><div class="line">        int num = 1;  // 报数</div><div class="line">        int no = 0;  // 排列编号</div><div class="line">        while (cnt) &#123;</div><div class="line">            if (out[no] == 1) &#123;</div><div class="line">                no = (no + 1) % n;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if (num == c) &#123;</div><div class="line">                cout &lt;&lt; no + 1 &lt;&lt; &apos; &apos;;</div><div class="line">                out[no] = 1;</div><div class="line">                num = 1;</div><div class="line">                cnt--;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            no = (no + 1) % n;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>输入一个循环数组（数组的最后一个元素的下一元素为数组的第一个元素），依次打印出 数组中所有元素的下一个比这个元素更大的值（按数组下标大小搜寻，可以循环），如果不 存在更大的元素，打印-1。</li>
</ol>
<p>例：</p>
<p>输入：</p>
<p>6</p>
<p>1 2 1 6 3 4</p>
<p>输出：2 6 6 -1 4 6 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n;</div><div class="line">    int a[1000];</div><div class="line">    while (cin &gt;&gt; n) &#123;</div><div class="line">        int mmax = -1;</div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            cin &gt;&gt; a[i];</div><div class="line">            if (a[i] &gt; mmax) &#123;</div><div class="line">                mmax = a[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if (a[i] == mmax) &#123;</div><div class="line">                cout &lt;&lt; -1 &lt;&lt; &apos; &apos;;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int next = (i + 1) % n;</div><div class="line">            while (1) &#123;</div><div class="line">                if (a[i] &lt; a[next]) &#123;</div><div class="line">                    cout &lt;&lt; a[next] &lt;&lt; &apos; &apos;;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                next = (next + 1) % n;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试准备之二零一三上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B8%89%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试准备之二零一三上机题/</id>
    <published>2019-03-07T13:46:47.000Z</published>
    <updated>2019-03-07T13:47:08.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>输出 100-1000 的所有平方回文数。</li>
</ol>
<p>平分回文数字是满足下列条件的整数：</p>
<p>（1）从左读与从右读都是一样的。</p>
<p>（2）为某一个数的平方。</p>
<p>例：121 是平方回文数。</p>
<ol>
<li>编程解决“八皇后问题”：即在一个 8*8 的矩形格子中排放 8 个皇后，要满足的条件包 括：任意两个皇后不能在同一行，同一列，也不能在同一条对角线上。</li>
</ol>
<p>要求编程给出解的个数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool is_huiwen(int num) &#123;</div><div class="line">    int x = num % 10;</div><div class="line">    int y = num / 100;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt; 1000; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; is_huiwen(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[8][8] = &#123;0&#125;;</div><div class="line">int col_flags[8] = &#123;0&#125;;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void queen(int row) &#123;</div><div class="line">    if (row == 8) &#123;</div><div class="line">        cnt++;</div><div class="line">        for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 8; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">        // 纵列上没有皇后</div><div class="line">        if (col_flags[i] == 1) continue;</div><div class="line">        // 左斜对角线上没有皇后</div><div class="line">        int flag = 0;</div><div class="line">        for (int j = 1; j + i &lt; 8; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i + j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        flag = 0;</div><div class="line">        // 右斜对角线没有皇后</div><div class="line">        for (int j = 1; j &lt;= i; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i - j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        arr[row][i] = 1;</div><div class="line">        col_flags[i] = 1;</div><div class="line">        queen(row + 1);</div><div class="line">        arr[row][i] = 0;</div><div class="line">        col_flags[i] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    queen(0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;输出 100-1000 的所有平方回文数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平分回文数字是满足下列条件的整数：&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之二零一四上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E5%9B%9B%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之二零一四上机题/</id>
    <published>2019-03-07T13:08:48.000Z</published>
    <updated>2019-03-07T13:09:10.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。</li>
</ol>
<p>（1）完全平方数。</p>
<p>（2）含有两位数字相同。</p>
<p>例：144，676…</p>
<ol>
<li>输入一串字符串，把下标为奇数的小写字母(从 0 开始编号)转换为大写字母。</li>
</ol>
<p>输出转换后的字符串。</p>
<h2 id="代码分别如下"><a href="#代码分别如下" class="headerlink" title="代码分别如下"></a>代码分别如下</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool has_same_nums(int num) &#123;</div><div class="line">    int x = num / 100;</div><div class="line">    int y = (num - x * 100) / 10;</div><div class="line">    int z = num - x * 100 - y * 10;</div><div class="line">//    cout &lt;&lt; x &lt;&lt; &apos; &apos; &lt;&lt; y &lt;&lt; &apos; &apos; &lt;&lt; z;</div><div class="line"></div><div class="line">    return x == y || x == z || y == z;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt;= 999; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; has_same_nums(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    string str;</div><div class="line">    int interval = &apos;a&apos; - &apos;A&apos;;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (i % 2 == 1) continue;</div><div class="line">            if (str[i] - &apos;a&apos; &gt;= 0 &amp;&amp; str[i] - &apos;z&apos; &lt;= 0) &#123;</div><div class="line">                str[i] -= interval;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cout &lt;&lt; str &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长连续数字</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之最长连续数字/</id>
    <published>2019-03-07T12:50:37.000Z</published>
    <updated>2019-03-07T12:50:47.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，</p>
<p>例：</p>
<p>输入：</p>
<p>ab125ff1234567#</p>
<p>输出：</p>
<p>1234567</p>
<p>开始位置为 8</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没啥好说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void longest_str(string str) &#123;</div><div class="line">    int max_len = 0, max_pos = 0;</div><div class="line">    int cur_num = 0, cur_pos = 0;</div><div class="line">    int flag = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; str.length() - 1; ++i) &#123;</div><div class="line">        // is number</div><div class="line">        if (str[i] - &apos;0&apos; &gt;= 0 &amp;&amp; str[i] - &apos;0&apos; &lt;= 9) &#123;</div><div class="line">            if (flag == 0) &#123;</div><div class="line">                flag = 1;</div><div class="line">                cur_pos = i;</div><div class="line">                cur_num = 1;</div><div class="line">            &#125; else &#123;</div><div class="line">                cur_num++;</div><div class="line">            &#125;</div><div class="line">            if (cur_num &gt; max_len) &#123;</div><div class="line">                max_len = cur_num;</div><div class="line">                max_pos = cur_pos;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;  // not number</div><div class="line">            flag = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; str.substr(max_pos, max_len) &lt;&lt; &quot; 开始位置为&quot; &lt;&lt; max_pos + 1 &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        longest_str(str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之棒球赛</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%A3%92%E7%90%83%E8%B5%9B/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之棒球赛/</id>
    <published>2019-03-07T12:35:20.000Z</published>
    <updated>2019-03-07T12:39:13.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：</p>
<ol>
<li>如果该字符串是数字：代表当轮比赛的得分情况。</li>
<li>如果该字符串是“+”：代表当轮比赛得分情况为上两轮之和。</li>
<li>如果该字符串是“C”：代表上一轮得分无效。</li>
<li>如果该字符串是“D”:代表当轮比赛得分为上一轮得分的两倍。</li>
</ol>
<p>你需要得出最后总的得分情况并返回结果。</p>
<p>例：</p>
<p>输入：52CD+</p>
<p>输出：30</p>
<p>解释：</p>
<p>第 1 轮得分 5 分，当前总共得分 5 分。</p>
<p>第 2 轮得分 2 分，当前总共得分 5+2=7 分。</p>
<p>第 3 轮取消上轮得分，当前总共得分 5 分。</p>
<p>第 4 轮获得上一轮双倍得分，当前总共得分 5+10=15 分。</p>
<p>第 5 轮获得上两轮得分之和，当前总共得分 15+5+10=30 分。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个==栈的应用==题，如果知道这一点解法就很简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    int stack[105];</div><div class="line"></div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        int top = 0;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (str[i] == &apos;C&apos;) &#123;</div><div class="line">                --top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;D&apos;) &#123;</div><div class="line">                stack[top] = 2 * stack[top - 1];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;+&apos;) &#123;</div><div class="line">                stack[top] = stack[top - 1] + stack[top - 2];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                stack[top++] = str[i] - &apos;0&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int sum = 0;</div><div class="line">        for (int i = 0; i &lt; top; ++i) &#123;</div><div class="line">            sum += stack[i];</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.7随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/3-7%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/3-7随想/</id>
    <published>2019-03-07T07:26:32.000Z</published>
    <updated>2019-03-07T07:42:51.372Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。</p>
<p>那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人们对这个国家的印象；另一方面国家的形象又能被个人的行为所影响，中国人在国外被认为素质低下，就是个人行为所产生的影响。</p>
<p>何为自我尊严呢？我和王小波想得不一样，我认为自尊就是问心无愧。古人被打板子，虽然外人看来很难看，但是如果是文死谏，我认为并没有丧失尊严；反之，皇帝老儿在殿堂之上骄纵作乐，看起来很风光，但是这就是尊严么？也不一定吧。</p>
<p>不过要说的话，很多尊严其实说白了就是面子，是给别人看的，而非问心无愧。这一套中国人是最擅长的，所以尊严这东西其实并不普遍。毕竟对于大多数人来说，过得舒服才是最重要的，只是有时候不得不追求一下所谓的尊严，因为如果你只秉持自尊的话，在这个社会上是寸步难行的。</p>
<p>王小波为了尊严不会在火车太挤的时候挤进去而且浑然无觉，但是总有人会为了回家而选择“丧失尊严”。这些其实都无关紧要，重要的是问心无愧就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。&lt;/p&gt;
&lt;p&gt;那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试上机准备之跳台阶</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之跳台阶/</id>
    <published>2019-03-06T13:57:00.000Z</published>
    <updated>2019-03-06T14:01:49.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1 阶台阶，也可以跳 n-2 阶台阶……也可以跳 1 阶</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>a[1] = 1, a[2] = 2.</p>
<p>对于三级台阶，可以第一步跳三步，方法为 1；可以第一步跳两步，还剩一步，方法和 a[3 - 2] 相同；也可以第一步跳一步，还剩两步，方法和 a[3 - 1] 相同。最终结果为 1 + 1 + 2 = 4 = 2^2</p>
<p>同理 a[4] = 1 + 1 + 2 + 4 = 8 = 2^3</p>
<p>a[n] = 2^(n - 1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之马跳棋</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E9%A9%AC%E8%B7%B3%E6%A3%8B/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之马跳棋/</id>
    <published>2019-03-06T13:43:50.000Z</published>
    <updated>2019-03-06T14:01:53.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的位）开始跳马，能够把棋盘的格子全部都走一遍，每个格子只允许走一次。</p>
<p>（1）输出一个如图 2 的解，左上角为第一步起点。</p>
<p>（2）总共有多少解。</p>
<p>P.S 国际象棋的棋子是在格子中间的。国际象棋中的“马走日”，如下图所示，第一步为[1,1], 第二步为[2,8]或[2,12]，第三步可以是[3,5]或[3,21]等，以此类推。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个常规的回溯题，要注意的就是一共有八个走的方向，在返回的时候记得还原原本的状态值。</p>
<p>一共有 304 解，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[5][5] = &#123;0&#125;;</div><div class="line">int vis_num = 1;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void horse_jump(int x, int y) &#123;</div><div class="line">    // 输出走法</div><div class="line">    if (vis_num == 25) &#123;</div><div class="line">        for (int i = 0; i &lt; 5; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 5; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">        cnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 右二下一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x + 2][y + 1] == 0) &#123;</div><div class="line">        arr[x + 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一下二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x + 1][y + 2] == 0) &#123;</div><div class="line">        arr[x + 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二上一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x - 2][y - 1] == 0) &#123;</div><div class="line">        arr[x - 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一上二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x - 1][y - 2] == 0) &#123;</div><div class="line">        arr[x - 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二下一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x - 2][y + 1] == 0) &#123;</div><div class="line">        arr[x - 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一下二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x - 1][y + 2] == 0) &#123;</div><div class="line">        arr[x - 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右二上一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x + 2][y - 1] == 0) &#123;</div><div class="line">        arr[x + 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一上二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x + 1][y - 2] == 0) &#123;</div><div class="line">        arr[x + 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    arr[0][0] = 1;</div><div class="line">    horse_jump(0, 0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长公共子串</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之最长公共子串/</id>
    <published>2019-03-06T01:58:30.000Z</published>
    <updated>2019-03-06T02:50:26.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。</p>
</blockquote>
<p>输入：</p>
<p>What’re your namess?</p>
<p>My namess are your.</p>
<p>输出：</p>
<p>reyour</p>
<p>namess</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最长公共子串/序列，是动态规划中一个非常经典的题型。但我之前接触的是最长公共子序列，子序列不要求序列的元素是相邻的，而子串需要元素是相邻的。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>两个循环，把序列 B 的每个元素开始的子串和 A 的所有元素进行比较，找出所有子串，从而找出最长子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void get_sub_str(string a, string b) &#123;</div><div class="line">    int len_a = a.length();</div><div class="line">    int len_b = b.length();</div><div class="line"></div><div class="line">    int start = 0, max_len = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; len_a; ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; len_b; ++j) &#123;</div><div class="line">            // 当找到相等的时候就顺着比下去，直到不相同</div><div class="line">            // 这里重新使用了一个变量 k，就不用改 i、j 了</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                int k = 1;</div><div class="line">                while (i + k &lt; len_a &amp;&amp; j + k &lt; len_b &amp;&amp; (a[i + k] == b[j + k])) &#123;</div><div class="line">                    ++k;</div><div class="line">                &#125;</div><div class="line">                if (k &gt; max_len) &#123;</div><div class="line">                    start = i;</div><div class="line">                    max_len = k;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = start; i &lt; start + max_len; ++i) &#123;</div><div class="line">        cout &lt;&lt; a[i];</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过上面这种实现只能输出第一个最长的子串，如果要输出所有最长子串，就要把所有有可能成为最长子串的子串保存下来，输出的时候再进行判断，只输出长度是最长的那些子串。</p>
<h3 id="动态规划-空间换时间"><a href="#动态规划-空间换时间" class="headerlink" title="动态规划-空间换时间"></a>动态规划-空间换时间</h3><p>我们可以用 m * n 的矩阵来存放相等的信息，如果 <code>arr[m][n] != 0</code> 则表明 <code>a[m] == b[n]</code>，子串就是斜对角线这些元素都不为零的那些位置。因此只用找最长的斜线即可。</p>
<p>为了简化找对角线的过程，我们可以让该点的元素值是左上方元素值加一，这样凭借元素值就知道序列的长度有多少了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 使用动态规划-空间换时间的方法</div><div class="line">void print_sub_str(string a, string b) &#123;</div><div class="line">    int arr[256][256] = &#123;0&#125;;</div><div class="line"></div><div class="line">    int max_len = 0;</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                // 根据斜上方的元素来赋值</div><div class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</div><div class="line">                    arr[i][j] = arr[i - 1][j - 1] + 1;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    arr[i][j] = 1;</div><div class="line">                &#125;</div><div class="line">                if (arr[i][j] &gt; max_len) &#123;</div><div class="line">                    max_len = arr[i][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 找到最有长度最长的子串</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (arr[i][j] == max_len) &#123;</div><div class="line">                // 要注意这里 substr 第二个参数是子串的长度！！！而非结束位置</div><div class="line">                cout &lt;&lt; b.substr(j - max_len + 1, max_len) &lt;&lt; endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是暴力法还是动态规划法都是有一定的技巧的。暴力法主要是注意一下变量是怎么安排的；动态规划法则要搞清楚是如何用时间换空间，如何减轻输出的计算量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
      <category term="算法" scheme="https://blog.patrickcty.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="华科" scheme="https://blog.patrickcty.cc/tags/%E5%8D%8E%E7%A7%91/"/>
    
      <category term="考研" scheme="https://blog.patrickcty.cc/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复试" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>3.5随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/05/3-5%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/05/3-5随想/</id>
    <published>2019-03-05T08:52:36.000Z</published>
    <updated>2019-03-06T14:02:29.947Z</updated>
    
    <content type="html"><![CDATA[<p>今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。</p>
<p>文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。</p>
<p>看到这个我就想到我小学学过的一篇课文，叫做《懒惰的智慧》，其大意就是现在社会的很多发明都是人们为了“偷懒”而产生的。一些机械化的事情我们虽然能做，但真的没必要和机器去争一个高低。</p>
<p>很多程序员都有这样的一个习惯，当遇到一个十分钟就可以完成的纯重复的工作的时候，他们一般不会去选择花十分钟机械地去完成，而是可能回去选择花二十分钟写一个脚本，再花一秒钟来跑这个脚本。</p>
<p>听起来又是另一个极端是不是？但这才是人区别于其他事物的一个重要特点。虽然看起来花费了更多的时间，但是在这个过程中他们可能又接触到了一些平常没怎么用的用法，熟悉了某些新知识；而如果去做机械的工作，就不会有这样的体验了，可能还会影响到心情。当然，对于一些怕麻烦，不想折腾的人来说，即使可能只用花五分钟写脚本，他们或许也不会愿意去写脚本。（其实我有很多时候也是这样的，不过经过多次尝试之后我发现还是写脚本要更加的愉悦，无论是身体上还是心灵上。）</p>
<p>我想说的是，人要找准自己的定位，我们没必要在自己不熟悉的领域和其他的东西来较劲，做好自己的本分工作就好，在一定的约束下，怎么舒服怎么来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。&lt;/p&gt;
&lt;p&gt;文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。&lt;/p&gt;
&lt;p&gt;看到这个我就想到我小学学过的一篇课文，叫
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于我犯二踩到Python环境坑的那些事</title>
    <link href="https://blog.patrickcty.cc/2019/03/05/%E5%85%B3%E4%BA%8E%E6%88%91%E7%8A%AF%E4%BA%8C%E8%B8%A9%E5%88%B0Python%E7%8E%AF%E5%A2%83%E5%9D%91%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://blog.patrickcty.cc/2019/03/05/关于我犯二踩到Python环境坑的那些事/</id>
    <published>2019-03-05T08:18:33.000Z</published>
    <updated>2019-03-05T08:39:03.504Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一个很傻逼的问题上卡了很长时间……现在一定要记录一下这些……同时也提醒以后不要像现在这么傻逼了……</p>
<p>首先这一切傻逼的根本原因都是因为我对 Linux/Unix 环境的一些基本设定很懵逼……</p>
<p>前段时间我的 Python3 环境突然消失不见（现在看来应该是我傻逼的改了环境变量自己不知道），于是我就装了 Anaconda。一开始用的还是很好的，直到那该死的 <code>conda install</code> 命令在 <code>Solving environment</code> 那个地方卡了超久超久，我又开始怀念我原本的 pip 了（其实 Anaconda 也可以用 pip 安装包，只是我傻逼不知道）。</p>
<p>在进行了一些令别人窒息和令我崩溃的操作之后我才知道并不是 Anaconda 把原本的路径给修改掉了，而是系统的寻找命令的机制使得输入 Python 出来的是 Anaconda 的 Python。</p>
<p>系统是根据 <code>$PATH</code> 的路径来寻找命令，越前面的路径越先被找到，比如以下的(忽略里面很多重复的路径……)</p>
<blockquote>
<p>~ echo $PATH<br>~ /usr/bin:/Users/patrick/anaconda3/bin:/Users/patrick/.nvm/versions/node/v8.3.0/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/anaconda3/bin:/anaconda2/bin:/Users/patrick/anaconda3/bin:/anaconda3/condabin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/sbin:/usr/local/sbin:/Users/patrick/anaconda3/bin</p>
</blockquote>
<p>路径之间是通过<code>:</code>隔开的。输入 <code>python</code> 命令的话，首先会在 <code>/usr/bin</code> 里面去寻找，没有的话才会到下一个里面去寻找。因为之前 Anaconda 是添加到最前面的，所以就会最先寻找。</p>
<p>最后的解决方案就是把环境变量改成上面这样，这样输入 <code>python</code> 命令就会使用系统自带的 python2，避免了一些依赖旧的 Python2 的包的不兼容，使用 <code>python3</code> 就会使用 Anaconda 的 Python，然后安装包还是使用 pip，这时候的 pip 也是 Anaconda 里面的了。</p>
<p>其实就是一很小的问题，不过因为我石乐志，卡了很久……下次再遇到问题的时候还是要先冷静下来，不然越急躁越容易走向错误的方向，浪费更多的时间……警醒警醒！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在一个很傻逼的问题上卡了很长时间……现在一定要记录一下这些……同时也提醒以后不要像现在这么傻逼了……&lt;/p&gt;
&lt;p&gt;首先这一切傻逼的根本原因都是因为我对 Linux/Unix 环境的一些基本设定很懵逼……&lt;/p&gt;
&lt;p&gt;前段时间我的 Python3 环境突然消失不见（现
    
    </summary>
    
      <category term="其他" scheme="https://blog.patrickcty.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Linux" scheme="https://blog.patrickcty.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>3.3随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/03/3-3%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/03/3-3随想/</id>
    <published>2019-03-03T06:21:53.000Z</published>
    <updated>2019-03-03T07:23:34.947Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了 Z 哥最新一期的视频，又是一篇满满的干货的视频，这次我决定不仅仅只是看，也要记录一下我自己的思考。</p>
<p>首先，何为一双好鞋？对我而言第一点就是帅，其次就是满足我的某种需求，比如：</p>
<ul>
<li>Ultra Boost：跑步</li>
<li>Air Jordan 11：体验 AJ 的最经典款</li>
<li>韦德全城：打篮球</li>
<li>Air Jordan 1：休闲穿搭，情侣鞋</li>
</ul>
<p>这些你对鞋的期待，反映在鞋的身上就是鞋的价值。但鞋的价格和价值很多情况下是不匹配的，比如大牌的某个毫无技术含量的休闲鞋是天价，而某国产品牌最高端的鞋款也才小几百。当然我们也不能仅仅按照物料成本来界定价格，物料成本只是一个基准，比物料成本高的价格才是你应该考虑的部分，这部分就是品牌溢价，包括品牌认知度，球星代言，科技加成，社交价值等等。你是否愿意花这么多钱为品牌溢价买单？如果答案是愿意，那么于你自己而言，就不算亏；如果答案是不愿意，与你自己而言就是亏——尽管所谓的亏可能会让你赚大钱，比如花高价买，然后以更高的价格倒卖。</p>
<p>然而，人总是不理性的，而且商家也在利用我们这一点，制造一些噱头来诱导消费，比如搞一些超限量，或者说是耍猴。这样就会让你有种买到就是赚到的感觉，实际上这个抢到的人不一定喜欢，喜欢的人不一定抢得到，最后最高兴的就是那些倒卖的贩子以及品牌自己了。所以就像 Z 哥一直说的，不是大爱我不买。</p>
<p>再者，追求利益是人的天性，靠球鞋来赚钱是可以的，也有很多贩子就是这样的，甚至很多玩鞋的也成了鞋贩子。但这样一来不近搅浑了球鞋市场，还让那些真正喜欢鞋的人很难受，就只有那些看见有好处捞一笔的贩子受益了。现在球鞋市场的繁荣只是暂时的，就像其他很多的市场一样，现在的所有炒作都是在给这个市场增加泡沫，当什么时候这些泡沫消散就是一个正常市场出现的时候。</p>
<p>关于应不应该通过这种说得好听叫把握机会，说得难听叫投机的方式来赚钱，我个人是不喜欢通过这种方式的。你们可以说我是懒，或是缺乏远见等等。但一是我真的很不喜欢这样折腾，因为一旦兴趣爱好和钱沾上关系，那它很大可能就会变质；二是这本来就是一个畸形的市场，很多人以为能进来捞钱，结果只是进来变成了韭菜。除非你真的对形势洞察得特别清晰，否则还是不要轻易趟这趟浑水，比如股市，比如区块链。</p>
<p>思维再发散一下，很多人在做选择的时候总是不经过思考，或是思考太浅，没有深入到事物的本质。当然我的大多数选择就是这样决定下来的，就比如最让我后悔的大学选择。选择什么样的大学，我们应该重点考虑这两个问题：</p>
<ul>
<li>读大学的目的是什么？<ul>
<li>学习？</li>
<li>结交人脉？</li>
<li>读研深造？</li>
<li>出国深造？</li>
<li>就业？</li>
<li>享受青春？</li>
</ul>
</li>
<li>大学的哪些因素能让我的目的更好的实现？<ul>
<li>品牌效应？</li>
<li>人脉资源？</li>
<li>硬件环境？</li>
<li>机会数量？</li>
</ul>
</li>
</ul>
<p>而另外的一些感性的因素，比如我喜欢某个城市，某个大学漂亮妹子比较多，某个大学食堂很好吃等等因素应该仅仅只是作为锦上添花的部分。但是我们往往会因为这些感性的因素来作出决定，比如我就因为我喜欢广州而只有暨大够分就来了这个计算机氛围极差的文科学校。诚然，由于信息的不对称，你可能需要耗费很大的力气才能完成挑选，但假如你真正花了很大力气来挑选，真正搞清楚自己的需求，你就不会因为另一个学校的伙食比较好而觉得遗憾了。</p>
<p>选大学，以及以后的选工作和选球鞋还不一样，不能仅仅因为“品牌溢价”而买单，这种涉及到你自身的前途的选择，就应该从未来发展的角度来考虑。这足够困难，因为几乎没有高中毕业的学生会想到考研保研的事情，他们更不会知道你所谓的一个差学校好专业会在调剂筛选、复试的时候就是比那些好学校的差专业要低一等。不过这也不是不能弥补的，人生中还是有很多节点能让你改变命运，只是你需要付出更多来弥补你之前的不恰当的选择罢了。</p>
<p>最重要的一点就是思考，无论干什么都要多思考，你思考得越透彻，越深入，你就越有可能把差的影响降到最低，甚至还能获得意想不到的收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了 Z 哥最新一期的视频，又是一篇满满的干货的视频，这次我决定不仅仅只是看，也要记录一下我自己的思考。&lt;/p&gt;
&lt;p&gt;首先，何为一双好鞋？对我而言第一点就是帅，其次就是满足我的某种需求，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ultra Boost：跑步&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="球鞋" scheme="https://blog.patrickcty.cc/tags/%E7%90%83%E9%9E%8B/"/>
    
      <category term="选择" scheme="https://blog.patrickcty.cc/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="思考" scheme="https://blog.patrickcty.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="ZGNB" scheme="https://blog.patrickcty.cc/tags/ZGNB/"/>
    
  </entry>
  
  <entry>
    <title>Screentone Removal 理解</title>
    <link href="https://blog.patrickcty.cc/2019/03/02/%E5%AE%9E%E7%8E%B0Screentone-Removal/"/>
    <id>https://blog.patrickcty.cc/2019/03/02/实现Screentone-Removal/</id>
    <published>2019-03-02T02:20:27.000Z</published>
    <updated>2019-03-02T02:27:40.377Z</updated>
    
    <content type="html"><![CDATA[<p>理解论文<a href="https://www.researchgate.net/publication/277653033" target="_blank" rel="external">《Separation of Manga Line Drawings and Screentones》</a>中的算法。</p>
<h2 id="Screentone-removal-mask"><a href="#Screentone-removal-mask" class="headerlink" title="Screentone removal mask"></a>Screentone removal mask</h2><h3 id="计算-LoG-过滤后的值"><a href="#计算-LoG-过滤后的值" class="headerlink" title="计算 LoG 过滤后的值"></a>计算 LoG 过滤后的值</h3><p>论文中采用高斯拉普拉斯滤波（Laplacian of Gaussian Filter）来作为去除网点的 Mask，这是由于 LoG 过滤器有以下特点：</p>
<ul>
<li>过滤之后，线条处值比较大，其他地方值比较小</li>
<li>过滤之后值为负数的像素不太可能是线条</li>
</ul>
<h3 id="处理过滤后图像"><a href="#处理过滤后图像" class="headerlink" title="处理过滤后图像"></a>处理过滤后图像</h3><ul>
<li>将过滤后图像中的负数置零</li>
</ul>
<h3 id="二值化过滤后的图像"><a href="#二值化过滤后的图像" class="headerlink" title="二值化过滤后的图像"></a>二值化过滤后的图像</h3><p>所谓二值化就是按照一个门槛值，把大于某个临界灰度值的像素灰度设为灰度极大值，把小于这个值的像素灰度设为灰度极小值。需要注意的是，二值化只能在灰度图片中进行。</p>
<p>论文中使用<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95" target="_blank" rel="external">大津法</a>产生自适应阈值。</p>
<h3 id="自适应选取窗口值算法"><a href="#自适应选取窗口值算法" class="headerlink" title="自适应选取窗口值算法"></a>自适应选取窗口值算法</h3><p>使用 LoG 需要接受窗口值来作为参数，LoG 也是基于高斯函数，即正态分布函数，正态分布函数需要接受 σ 作为参数。函数的标准差 σ 越大，函数越平缓（分布较为分散），σ 越小函数越尖（分布更集中）。</p>
<p>而窗口大小，也就是卷积核的长宽可以通过正态分布的特点来确定，因为太远的地方函数的数值可以忽略不计。二者相互换算的公式可以看<a href="https://blog.shinelee.me/2018/09-19-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%A0%87%E5%87%86%E5%B7%AE%E5%92%8C%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.html" target="_blank" rel="external">这篇博客</a>，具体公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\sigma = 0.3 \times ((ksize - 1) \times 0.5 - 1) + 0.8</div></pre></td></tr></table></figure>
<p>该算法则是为了自适应地选取窗口大小来计算 LoG 的值。</p>
<h4 id="评判标准与一些指标"><a href="#评判标准与一些指标" class="headerlink" title="评判标准与一些指标"></a>评判标准与一些指标</h4><ul>
<li>连通域标准（Connected  Component Criteria，CCC）</li>
<li>停止标准（Stop Criteria， STC）</li>
<li>连通分量数（Number of Connected Component， NCC）</li>
</ul>
<p>公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CCC_i = 1 - \frac&#123;NCC(M_&#123;LoG_i&#125;)&#125;&#123;NCC(M_&#123;LoG_&#123;i - 2&#125;&#125;)&#125;</div><div class="line"></div><div class="line">STC_i = \frac&#123;NCC(M_&#123;LoG_i&#125;)&#125;&#123;NCC(M_&#123;LoG_1&#125;)&#125; \times |NCC(M_&#123;LoG_i&#125;) - NCC(M_&#123;LoG_&#123;i - 2&#125;&#125;)|</div></pre></td></tr></table></figure>
<p>其中 <code>$CCC_i$</code> 显示随着 i 的增加连通域的下降，当其取得最大值的时候表示此时网点去除效果最好。论文中指出，当有多个峰值的时候，更大的 i 会有更好的结果，因此设置参数 β = 0.8 来获得更大的 i 值，称为松弛因子。</p>
<p><code>$STC_i$</code> 表示停止的条件，如果数值小于门槛值（一般设为 α = 0.8）就会停止。它用来显示当前 i 的连通区域的数量变化情况。</p>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>通过迭代，在 STC 大于门槛的情况下，取得最大的 CCC。</p>
<p>在得到最好的 i 值之后，论文中指出，实际情况当 i 比计算出来的值大一些时能取到更好的效果。</p>
<p>而当有黑色网点，且 i 过大时，线条会太粗，于是引入 <code>$i_{base}$</code> 来处理这种情况，让结果的线条更细。</p>
<p>以上公式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i_&#123;LoG&#125; += 4</div><div class="line"></div><div class="line">i_&#123;base&#125; = min(\frac&#123;i&#125;&#123;2&#125;, i_&#123;LoG&#125;)</div><div class="line"></div><div class="line">M_&#123;rm&#125; = M_&#123;LoG_i&#125; \wedge M_&#123;LoG_&#123;i_&#123;base&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://static.jnugeek.cn/image/notes/remove_mask.png" alt="result"></p>
<h2 id="Line-preserving-mask"><a href="#Line-preserving-mask" class="headerlink" title="Line preserving mask"></a>Line preserving mask</h2><h2 id="Mask-merging-for-reﬁning-line-extraction"><a href="#Mask-merging-for-reﬁning-line-extraction" class="headerlink" title="Mask merging for reﬁning line extraction"></a>Mask merging for reﬁning line extraction</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解论文&lt;a href=&quot;https://www.researchgate.net/publication/277653033&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Separation of Manga Line Drawings and Sc
    
    </summary>
    
      <category term="图像处理" scheme="https://blog.patrickcty.cc/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Manga" scheme="https://blog.patrickcty.cc/tags/Manga/"/>
    
      <category term="Image Processing" scheme="https://blog.patrickcty.cc/tags/Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>3.1随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/01/3-1%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/01/3-1随想/</id>
    <published>2019-03-01T08:02:34.000Z</published>
    <updated>2019-03-01T08:21:19.772Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了关于国学的两篇文章，王小波对国学进行了深刻的批判。</p>
<p>他认为，我们的国学有几方面的问题。首先是太注重实用性，国学中所包含的，大多是一些日常社会相关的伦理道德等，而出于兴趣而研究的则少之又少；再者，国学多年以来钻研的很多都是同一套东西——四书五经，很多人想用同一套东西来解释整个世界，而不是开拓新的领域；另一点是自视甚高，认为中华文化是历史最悠久的文化，全世界都理应从中学习；还有则是雷声大雨点小，人文学者动静不小但产出内容非常有限。</p>
<p>我对国学的理解还停留在高中的课文之中，一直以来，我都对儒家的那套思想不是很感冒，当然我也不愿意再去结合时代得出这种思想在当时是多么多么的先进。毕竟我不是人文学者，没必要强行去考虑这些我不感兴趣的文化。</p>
<p>不得不说，国学的内容还是有些太单调了，中国虽然有着悠久的历史，但是在自然科学上却没有留下多少的足迹。中国的读书人很多都要受到四书五经的“摧残”，一本教材用成百上千年，怎么想都觉得不对吧，这样的书籍与其说是知识不如说是精神的枷锁。</p>
<p>好在如今四书五经已经不是我们教育的重点了，我们的思想也在接受各种知识体系的洗涤，这对我们来说绝对是一件好事。对于后一代来说，应该灌输他们的不应该是某种特定的知识体系，而是要把他们的求知欲挖掘出来，没有那一股热情是做不成什么大事的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了关于国学的两篇文章，王小波对国学进行了深刻的批判。&lt;/p&gt;
&lt;p&gt;他认为，我们的国学有几方面的问题。首先是太注重实用性，国学中所包含的，大多是一些日常社会相关的伦理道德等，而出于兴趣而研究的则少之又少；再者，国学多年以来钻研的很多都是同一套东西——四书五经，很多人想
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>C 语言输入的一个坑</title>
    <link href="https://blog.patrickcty.cc/2019/03/01/C%E8%AF%AD%E8%A8%80%E8%BE%93%E5%85%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2019/03/01/C语言输入的一个坑/</id>
    <published>2019-03-01T02:19:18.000Z</published>
    <updated>2019-03-01T02:28:11.682Z</updated>
    
    <content type="html"><![CDATA[<p>原题如下：</p>
<blockquote>
<p>题目描述<br>不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。</p>
</blockquote>
<p>输入描述:</p>
<ul>
<li>每一行包括两个字符串，长度不超过100。</li>
</ul>
<p>输出描述:</p>
<ul>
<li>可能有多组测试数据，对于每组数据，不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。</li>
<li>输出连接后的字符串。</li>
</ul>
<p>这是个很简单的题，但是有一个坑。</p>
<p>通常我们 C 语言存放字符串要么是用字符数组要么是用指针，我第一反应就是用指针来存储，所以我写了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *a, *b;</div><div class="line">scanf(&quot;%s %s&quot;, a, b);</div></pre></td></tr></table></figure>
<p>但是当输入一行的时候会出现段错误。</p>
<p>这是因为 a b 都是未初始化的指针，如果打印二者的地址可以发现它们是相邻的</p>
<blockquote>
<p>0x7ffee27a5610 0x7ffee27a5608</p>
</blockquote>
<p>所以当你接受两个字符串的时候就很可能会出现段错误了。</p>
<p>使用长度固定的字符数组就能完美避免这个问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char a[105], b[105];</div><div class="line">scanf(&quot;%s %s&quot;, a, b);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述&lt;br&gt;不借用任何字符串库函数实现无冗余地接受两个字符串，然后把它们无冗余的连接起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一行包括两个字符串，长度不超过100。&lt;/l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2.28随想</title>
    <link href="https://blog.patrickcty.cc/2019/02/28/2-28%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/02/28/2-28随想/</id>
    <published>2019-02-28T01:30:45.000Z</published>
    <updated>2019-02-28T06:20:55.613Z</updated>
    
    <content type="html"><![CDATA[<p>今天看的是《中国知识分子与中古遗风》。</p>
<p>不知何时起，“公知”已经变成了一个贬义词，虽然我没有关注这些人，但有一些的睿智言论还是是不是会传到我的眼中。</p>
<p>就像文章里面说的一样，这些所谓的知识分子，认为自己有文化，站在伦理道德的制高点之上，去批判别人，针砭时弊——其实很多时候是站着说话不腰疼。经常拿出一些大道理来唬人，却没有什么真正有意义的讨论。</p>
<p>我觉得的话，还是心里的优越感在作怪，讨论是完全没问题的，但是颐指气使就显得太过嚣张，令人讨厌了。嚣张这事不仅仅是公知容易出现，就是一个学生会的小部长也容易有。</p>
<p>希望我能保持一颗平和的心态，不膨胀也不妄自菲薄，不过这又是一件难事了。</p>
<p>之后又看了《花剌子模信使问题》，这一篇可以充分体现王小波的思想是如何的活跃。</p>
<p>他把这样一个问题引申到了学术上，学术上也有花剌子模的问题，学者的研究究竟是应该纯粹，还是为了产生好消息？这貌似是一个很简单的问题，但是实际选择又其实是很难的。但更多的时候我们是没得选择的，如果不选择迎合，就是给自己找麻烦。所以当看到耍滑头的时候，我们应该抱着人艰不拆的心态来看待，谁没做过违心的事没说过违心的话呢？</p>
<p>最可怕的就是，你不知道你自己是不是身在花剌子模，意思就是你在自己不知道的情况下做出了耍滑头的事情。</p>
<p>不过作为一个还未踏上社会的乳臭未干的毛头小子，现在讨论这种事情也只是空口无凭，只能祈祷自己所处的环境能够好一点，自己不会成为花剌子模信使，也不会遇上花剌子模君王。</p>
<p>P.S. 经过了这几天的学习（？还是划水），我发现了我还是过于依赖搜索引擎和现有的模块，很多东西我都是做一个伸手党，把东西要到了就不管了。这样就明明是最近才用到的东西，却还是得再去谷歌一次……虽然我记忆力不好，但是我觉得更多情况下是我压根没有去使用我的记忆力……哎，得多动动脑筋了，说不定我的脑袋就是这样生锈的呢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看的是《中国知识分子与中古遗风》。&lt;/p&gt;
&lt;p&gt;不知何时起，“公知”已经变成了一个贬义词，虽然我没有关注这些人，但有一些的睿智言论还是是不是会传到我的眼中。&lt;/p&gt;
&lt;p&gt;就像文章里面说的一样，这些所谓的知识分子，认为自己有文化，站在伦理道德的制高点之上，去批判别人，
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>《阿丽塔：战斗天使》</title>
    <link href="https://blog.patrickcty.cc/2019/02/27/%E3%80%8A%E9%98%BF%E4%B8%BD%E5%A1%94%EF%BC%9A%E6%88%98%E6%96%97%E5%A4%A9%E4%BD%BF%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2019/02/27/《阿丽塔：战斗天使》/</id>
    <published>2019-02-27T06:17:38.000Z</published>
    <updated>2019-02-27T06:48:50.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总体感觉"><a href="#总体感觉" class="headerlink" title="总体感觉"></a>总体感觉</h2><p>这部电影比我想象中的要好不少，可能因为在看之前看到了许多批评，比如故事很差，感情很尬等等问题。我看起来反而觉得并没有他们说的那么严重的问题。</p>
<p>首先很明显这是系列电影的开山之作，所以交代背景和世界观用了一些篇幅，阿丽塔从懵懂无知到变强也花了一些篇幅，因此不可避免的前面有些平淡；再加上到了最后大 Boss 和阿丽塔都还没碰面过，所以也没有太大的高潮可言。</p>
<p>至于感情戏，我觉得一点都不尬，最后男主的死（？存疑）是一个比较好的展开。在阿丽塔懵懂无知的时候，总要有个人引领她成长，开阔她的眼界。很明显这个人的另一个角色不应该是父亲，而是恋人更为合适。至于我为什么觉得男主的死亡反而是一件好事，那是因为，首先男主的能力值和阿丽塔差了太多，整部电影中男主基本上就是围观群众 + 连小怪都打不过的这样一个角色。这样的一个存在会严重影响阿丽塔的表现，其中我还真的担心她把自己的心掏给男主了……而男主的死亡反而是她成长的一个契机，那个最重要的人的去世会给她带来更加充足的动力，从而极大地推动剧情。</p>
<p>如果要说不足的话那一定就是那些反派太弱了，特别是格鲁依什卡，送了三次，除了第二次好一点之外，其他都被秒杀；还有就是全场最佳二五仔扎潘了，实力嘴炮 + 送神器，为阿丽塔之后超神的表现做出了重要助攻。另外不仅仅是反派，其他的人物也都太没有存在感了。不过这也没办法，就像一开始说的，这是系列的开山之作，而且阿丽塔太强了，和其他人完全不在一个档次上……之后的撒冷篇应该在这个方面有大的提升。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>评分的话我个人认为：8 / 10。剧情平淡，世界观表现令人惊喜，没有大的槽点，结局也不算太突兀，比《复仇者联盟 3》的懵逼结局好多了……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总体感觉&quot;&gt;&lt;a href=&quot;#总体感觉&quot; class=&quot;headerlink&quot; title=&quot;总体感觉&quot;&gt;&lt;/a&gt;总体感觉&lt;/h2&gt;&lt;p&gt;这部电影比我想象中的要好不少，可能因为在看之前看到了许多批评，比如故事很差，感情很尬等等问题。我看起来反而觉得并没有他们说的
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="科幻" scheme="https://blog.patrickcty.cc/tags/%E7%A7%91%E5%B9%BB/"/>
    
      <category term="漫改" scheme="https://blog.patrickcty.cc/tags/%E6%BC%AB%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>2.27随想</title>
    <link href="https://blog.patrickcty.cc/2019/02/27/2-27%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/02/27/2-27随想/</id>
    <published>2019-02-27T05:54:18.000Z</published>
    <updated>2019-02-27T06:12:20.607Z</updated>
    
    <content type="html"><![CDATA[<p>又看了一遍《特立独行的猪》，第一次看的时候我还感慨这只猪真聪明，不过这次看的时候我倒是想到了《少年派》里面那个动物的故事。究竟是真的有这样的猪，又或者是有这样一个特立独行的人，还或者这是王小波在那个年代所憧憬的样子？这些都不重要，但在那个时代，这样的特立独行就是那个让人喘不过气的日子中的一阵清风，一股清流了。</p>
<p>顺便，把《少年派》添加到待看清单了，之前一次看不是特别懂，也特别赶，是时候重新回顾一下了，这次要带着自己的思考进行。</p>
<p>对于另一篇文章《&lt;我的精神家园&gt;序》，有几句话我觉得深有其然，在此摘录下：</p>
<blockquote>
<p>假如一个社会的宗旨就是反对有趣，那它比寒冰地狱又有不如。在这个领域里发议论的人总是在说：这个不宜提倡，那个不宜提倡。仿佛人活着就是为了被提倡。要真是这样，就不如不活。罗素先生说，参差多态乃是幸福的本源——弟兄姐妹们，让我们睁开眼睛往周围看看，所谓的参差多态，它在哪里呢。</p>
</blockquote>
<p>现在整个社会的参差多态比起之前的时代确实有了不小的进步，但是一些人的思想还停留在之前的时代，真是为他们的孩子感到悲哀。我也知道，面对与自己的认知相冲突的事物是多么的不爽，但你可以不喜欢，但是不能随便评判。参差多态需要我们对与自己观念不同的人和事物的包容甚至是忍受。</p>
<p>我也要时刻提醒自己，求同存异，只有蠢人才会无时无刻不用自己的价值观去约束别人的行为。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又看了一遍《特立独行的猪》，第一次看的时候我还感慨这只猪真聪明，不过这次看的时候我倒是想到了《少年派》里面那个动物的故事。究竟是真的有这样的猪，又或者是有这样一个特立独行的人，还或者这是王小波在那个年代所憧憬的样子？这些都不重要，但在那个时代，这样的特立独行就是那个让人喘不
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
</feed>
