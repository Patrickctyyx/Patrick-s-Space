<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2018-05-01T08:43:54.480Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Truffle 框架开发 Dapp 中的注意事项</title>
    <link href="https://blog.patrickcty.cc/2018/05/01/Truffle%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91Dapp%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://blog.patrickcty.cc/2018/05/01/Truffle框架开发Dapp中的注意事项/</id>
    <published>2018-05-01T08:43:03.000Z</published>
    <updated>2018-05-01T08:43:54.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Truffle 是开发 Ethereum 的一个框架。</p>
<h2 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>智能合约使用的是 solidity 语言，这个语言在一些地方与平常使用的高级语言不同，因而可能会遇到一些坑。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>solidity 中变量分为两类：memory 和 storage，前者就类似于我们平常语言中的变量，存放在内存中，在调用结束后就会释放掉。</li>
<li>而 storage 类型的变量则会存放在区块链中，因而它实际表示的是指针，也正是因为这个原因，这两种变量不能混合使用。</li>
<li>另外，定义在 Contract 函数之外的变量默认是 storage 类型的。</li>
</ul>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>solidity 中 event 的作用就是把发生的事件记录在区块链上成为日志。事件可以通过 web3 来监听。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 定义事件</div><div class="line">event transfer(address indexed _from, address indexed _to, uint indexed value);</div><div class="line"></div><div class="line">// 事件发生，新版本需要加入 emit 关键词</div><div class="line">emit transfer(msg.sender, current, value);</div></pre></td></tr></table></figure>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapping(address =&gt; User) userPool;</div></pre></td></tr></table></figure>
<ul>
<li>solidty 中的映射不需要初始化，而且对于不在映射中的内容，通过 m[key] 来调用并不会返回类似于 null 的内容，而是会返回这个类型的默认值，比如 uint 返回的就是 0，因而要检查是否在映射中的时候可能需要辅助的属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Num &#123;</div><div class="line">    uint count,</div><div class="line">    bool inMap</div><div class="line">&#125;</div><div class="line"></div><div class="line">mapping(uint =&gt; Num) numMap;</div><div class="line"></div><div class="line">if (numMap[1].inMap) &#123; 在映射中 &#125;</div><div class="line">else &#123; 不在映射中 &#125;</div></pre></td></tr></table></figure>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><ul>
<li>solidity 中不能直接使用 <code>==</code> 来比较字符串，需要一个一个字符来比较或者来比较二者的 hash 值：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keccak256(str1) == keccak256(str2)</div></pre></td></tr></table></figure>
<h4 id="msg-sender-amp-amp-tx-origin"><a href="#msg-sender-amp-amp-tx-origin" class="headerlink" title="msg.sender &amp;&amp; tx.origin"></a>msg.sender &amp;&amp; tx.origin</h4><ul>
<li>在用户调用合约的时候，msg.sender 和 tx.origin 都是用户的地址</li>
<li>在合约调用合约的时候，msg.sender 是 合约的地址，而 tx.origin 是用户</li>
</ul>
<p>这个一定要注意，我就在这里卡了很久。</p>
<h4 id="三个常用方法"><a href="#三个常用方法" class="headerlink" title="三个常用方法"></a>三个常用方法</h4><h5 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h5><p>里面是一个 bool 表达式，为真的时候才会执行下面的内容。用来检查不严重的错误，可以退回 gas。</p>
<h5 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h5><p>这个方法和 require 类似，但是一般是用来检查严重的错误，会拿走 gas。</p>
<h5 id="revert"><a href="#revert" class="headerlink" title="revert()"></a>revert()</h5><p>这个方法里面没有参数，会终止并且恢复之前的状态。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>solidity 数组可以定义不定长的数组，但是要初始化空的不定长数组则要使用 new </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 这里默认是长度为一的数组</div><div class="line">// 但是可以通过两种方法来改变：</div><div class="line">// 1. 直接改变长度：list.length++</div><div class="line">// 2. 通过 push 来增加元素 list.push(123)</div><div class="line">uint[] list = new int[](1);</div></pre></td></tr></table></figure>
<h2 id="truffle-常用命令"><a href="#truffle-常用命令" class="headerlink" title="truffle 常用命令"></a>truffle 常用命令</h2><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truffle compile</div></pre></td></tr></table></figure>
<p>这个命令用来把合约编译成 EVM 可以读懂的语言</p>
<h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truffle migrate</div></pre></td></tr></table></figure>
<p>这个命令用来把合约部署到区块链上，在修改合约之后就不用再次编译，直接使用这个命令部署即可</p>
<p>如果想清除掉之前的数据而不像删除掉编译已生成的 build 则可以加一个 <code>--reset</code> 参数</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truffle test</div></pre></td></tr></table></figure>
<p>这个命令会运行 test 文件夹中的单元测试，其中单元测试文件要以 Test 作为开头，单元测试方法需要以 test 开头</p>
<h2 id="在-js-中调用合约"><a href="#在-js-中调用合约" class="headerlink" title="在 js 中调用合约"></a>在 js 中调用合约</h2><h3 id="创建-web3-对象"><a href="#创建-web3-对象" class="headerlink" title="创建 web3 对象"></a>创建 web3 对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (typeof web3 !== &apos;undefined&apos;) &#123;</div><div class="line">    App.web3Provider = web3.currentProvider;</div><div class="line">    web3 = new Web3(web3.currentProvider);</div><div class="line">&#125; else &#123;</div><div class="line">    App.web3Provider = new Web3(new Web3.providers.HttpProvider(&apos;http://localhost:7545&apos;));</div><div class="line">    web3 = new Web3(web3.web3Provider);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果已经存在就直接绑定，不存在的话就根据本地的内容来创建再绑定。</p>
<h3 id="读取合约"><a href="#读取合约" class="headerlink" title="读取合约"></a>读取合约</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$.getJSON(&apos;TeamMarket.json&apos;, function(data) &#123;</div><div class="line">    var TMArtifact = data;</div><div class="line">    App.contracts.TeamMarket = TruffleContract(TMArtifact);</div><div class="line"></div><div class="line">    App.contracts.TeamMarket.setProvider(App.web3Provider);</div><div class="line"></div><div class="line">    App.initCompetitions();</div><div class="line">    </div><div class="line">    return App.markJoined();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里的 json 文件是编译所产生的，其中要注意 getJSON 中的 JSON 是大写的，不然就会出现傻逼的错误（说的就是我……）。</p>
<p>另外在 HTML 部分记得要引入 truffle 相应的 js 文件。</p>
<h3 id="和合约交互"><a href="#和合约交互" class="headerlink" title="和合约交互"></a>和合约交互</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">web3.eth.getAccounts(function(error, accounts) &#123;</div><div class="line">    if (error) &#123;</div><div class="line">        console.log(error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var account = accounts[0];</div><div class="line"></div><div class="line">    App.contracts.TeamMarket.deployed().then(function(instance) &#123;</div><div class="line">        TMInstance = instance;</div><div class="line"></div><div class="line">        return TMInstance.createUser(name, email, major);</div><div class="line">    &#125;).then(function () &#123;</div><div class="line">        alert(&quot;创建账号成功，等待写入区块链&quot;);</div><div class="line">    &#125;).catch(function(err) &#123;</div><div class="line">        alert(&quot;有错误发生，创建账号失败&quot;);</div><div class="line">        console.log(err.message);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里是通过 web3 接口来读取用户信息，返回的是一个 list，一般第一个就是当前用户</p>
<p>然后获取合约的实例<code>App.contracts.TeamMarket.deployed()</code>，这里是一个 Promise，在 then 里面就已经获取到了相应的实例，然后再通过这个实例来调用合约里面的方法就可以了。</p>
<p>不过在调用合约之后的 then 中不知道为什么有时候不会执行里面的语句……还得研究研究……</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="truffle-js"><a href="#truffle-js" class="headerlink" title="truffle.js"></a>truffle.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  networks: &#123;</div><div class="line">    development: &#123;</div><div class="line">      host: &quot;127.0.0.1&quot;,</div><div class="line">      port: 7545,</div><div class="line">      network_id: &quot;*&quot;,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里是配置区块链网络</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;teamseeker&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;&quot;,</div><div class="line">  &quot;main&quot;: &quot;truffle.js&quot;,</div><div class="line">  &quot;directories&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;test&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;dev&quot;: &quot;lite-server&quot;,</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;lite-server&quot;: &quot;^2.3.0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;dependencies&quot;: &#123;</div><div class="line">    &quot;web3&quot;: &quot;^1.0.0-beta.34&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里更多是运行的 js 的一系列配置了，比如在这里配置了成序运行所使用的服务器 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Truffle 是开发 Ethereum 的一个框架。&lt;/p&gt;
&lt;h2 id=&quot;编写合约&quot;&gt;&lt;a href=&quot;#编写合约&quot; class=&quot;h
    
    </summary>
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/categories/BlockChain/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="Truffle" scheme="https://blog.patrickcty.cc/tags/Truffle/"/>
    
      <category term="Contract" scheme="https://blog.patrickcty.cc/tags/Contract/"/>
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>Python协程</title>
    <link href="https://blog.patrickcty.cc/2018/04/27/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>https://blog.patrickcty.cc/2018/04/27/Python协程/</id>
    <published>2018-04-27T07:36:07.000Z</published>
    <updated>2018-04-27T07:37:02.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><p>如果把一个可迭代对象比作一辆装有电池的四驱车，那么四驱车的马达会在电池电量耗尽之时才会停止；但是 generator 则像是一个发条小车，它每次都只会在拧动发条之后才会前进相应的距离。这个发条就是“yield” 关键字。</p>
<h3 id="作为可迭代对象"><a href="#作为可迭代对象" class="headerlink" title="作为可迭代对象"></a>作为可迭代对象</h3><p>generator 也是一个可迭代对象，它可以通过类似于列表生成式的方式来定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g = (x for x in range(10))</div></pre></td></tr></table></figure>
<p>需要注意的是这里的括号是小括号，如果是中括号的话生成的就是一个普通的列表了。</p>
<p>在这里获得 g 的所有结果有两种方法，一种是多次使用十次 next() 来依次生成每个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">0</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">1</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">2</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">4</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">5</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">6</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">7</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">8</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">9</div><div class="line">&gt;&gt;&gt; next(g)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">StopIteration</div></pre></td></tr></table></figure>
<p>如果调用的太多了就会产生错误。</p>
<p>第二种就是直接把 g 作为可迭代对象在 for in 中循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for num in g:</div><div class="line">    print(num)</div></pre></td></tr></table></figure>
<h3 id="作为函数"><a href="#作为函数" class="headerlink" title="作为函数"></a>作为函数</h3><p>我们还可以把一个函数作为 generator 来使用，这里就需要使用我们的 yield 发条来进行改造了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def count(mmax):</div><div class="line">    for i in range(mmax):</div><div class="line">        yield i</div></pre></td></tr></table></figure>
<p>作为函数也同样有两种用法：使用 next 调用和直接放入 for in 循环中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 方法一</div><div class="line">c = count(10)</div><div class="line">next(c)</div><div class="line">next(c)</div><div class="line">...</div><div class="line"></div><div class="line"># 方法二</div><div class="line">for num in count(10):</div><div class="line">    print(num)</div></pre></td></tr></table></figure>
<p>这里最令人费解的就是 yield 关键字了，在 generator 运行的过程中，当执行到 yield 的时候，程序就会暂停下来，返回 yield 后面对应的值。只有调用 next() 之后才会继续从刚才停下的地方开始执行直到遇到下一个 yield 又再次停止。</p>
<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><p>Coroutine 叫做协程，又叫做微线程。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行<a href="https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/" target="_blank" rel="external">【1】</a>。</p>
<p>Coroutine 分为三个阶段：</p>
<ul>
<li>generator 变形 yield/send()</li>
<li>@asyncio.coroutine 以及 yield from</li>
<li>async/await</li>
</ul>
<h3 id="generator-变形-yield-send"><a href="#generator-变形-yield-send" class="headerlink" title="generator 变形 yield/send()"></a>generator 变形 yield/send()</h3><p>这一阶段和 generator 不同的是对 yield 的用法进行了扩展，除了 yield 除了可以返回数据之外还可以接收数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># getData 是接收到的数据，returnData 是发送出去的数据</div><div class="line">getData = yield returnData</div></pre></td></tr></table></figure>
<p>我们知道 generator 是通过 next() 或者直接迭代来得到下一个结果，而这里则是通过 coroutine.send() 来得到下一个结果，或者更准确的来说是让子程序继续往后执行，但要注意的是在初始化也就是第一次调用的时候要使用 coroutine.send(None)，这里其实是启动 generator。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def funA():</div><div class="line">    while True:</div><div class="line">        r = yield &apos;fine, thank you！&apos;</div><div class="line">        print(r)</div><div class="line">        </div><div class="line">def funB(c):</div><div class="line">    # 启动 generator</div><div class="line">    c.send(None)</div><div class="line">    i = 0</div><div class="line">    while i &lt; 3:</div><div class="line">        r = c.send(&apos;how are you？&apos;)</div><div class="line">        print(r)</div><div class="line">        i += 1</div><div class="line">    # 关闭 funA</div><div class="line">    c.close()</div><div class="line">    </div><div class="line">c = funA()</div><div class="line">funB(c)</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果为：<br>how are you?<br>fine, thank you!<br>how are you?<br>fine, thank you!<br>how are you?<br>fine, thank you!</p>
</blockquote>
<p>在这里 funB 通过 send 给 funA 发送信息，之后 funB 通过 yield 回复信息给 funA，但这两者在发送的同时（其实是之后）也可以读取到相应的信息。</p>
<p>运行的流程是这样的：</p>
<ul>
<li>funB 启动了 generator</li>
<li>funA 运行到 yield 处向 funA 发送 ‘fine, thank you！’，然后切换到 funB</li>
<li>funB 运行到 send() 向 funA 发送了 ‘how are you？’，切换回 funA</li>
<li>funA 从 yield 接收到 funB 的消息，继续运行到 yield 处向 funA 发送 ‘fine, thank you！’，然后切换到 funB</li>
<li>funB 接收到 funA 的消息，继续运行到 send() 向 funA 发送了 ‘how are you？’，切换回 funA</li>
<li>重复以上过程直到 funB 使用 c.close() 关闭 funA，运行结束</li>
</ul>
<p>需要注意的是其实 send() 和 yield 的作用是非常类似的，只不过 send() 是主动方，yield 是被动方。</p>
<h3 id="asyncio-coroutine-以及-yield-from"><a href="#asyncio-coroutine-以及-yield-from" class="headerlink" title="@asyncio.coroutine 以及 yield from"></a>@asyncio.coroutine 以及 yield from</h3><p>在 send() 和 yield 部分是由明显的主动被动关系，但是在这里则更多的是一种并列关系，这里要处理的问题是在一方进行 io 操作时另一方能充分利用这段空闲的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import asyncio</div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def funA():</div><div class="line">    print(&apos;hello, world!&apos;)</div><div class="line">    yield from asyncio.sleep(1)</div><div class="line">    print(&apos;hello, again!&apos;)</div><div class="line">    </div><div class="line">@asyncio.coroutine</div><div class="line">def funB():</div><div class="line">    print(&apos;are you ok?&apos;)</div><div class="line">    yield from asyncio.sleep(1)</div><div class="line">    print(&apos;hello, thank you! thank you very much!&apos;)</div><div class="line">    </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [funA(), funB()]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>are you ok?<br>hello, world!<br>hello, thank you! thank you very much!<br>hello, again!</p>
</blockquote>
<p>这里 funA funB 是作为两个互相独立的 task 来运行的，yield 后面紧接着的是一个协程的函数过程，这就是说在这里 CPU 空闲出来了，于是切换给另一个 task 来执行。注意的是这里的 funA() funB() 其实都是 generator，因而并不会马上执行。</p>
<p>这里的运行过程是这样的：</p>
<ul>
<li>我们首先获得了当前的 event loop，然后将 funA funB 两个 task 放在其中，通过 asyncio.wait() 来执行</li>
<li>首先被调用的是 funB，它运行到 yield 处阻塞，此时切换到 funA 执行</li>
<li>同理，funA 也是运行到 yield 处阻塞，此时切换到 funB 执行</li>
<li>funB 继续执行直到完成释放资源，此时再次切换到 funA 执行直到结束</li>
<li>所有任务完成，run_until_complete() 返回，接下来可以关掉 event loop 了</li>
</ul>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>而 async/await 与 generator 变形 yield/send() 的区别就没有之前两者区别那么大了，async/await 对之前的形式进行了优化，让 coroutine 的代码更简洁易读。</p>
<p>如果要使用 async/await 就只用：</p>
<ol>
<li>把 @asyncio.coroutine 替换为 async（在 def 前面）</li>
<li>把 yield from 替换为 await</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import asyncio</div><div class="line"></div><div class="line">async def funA():</div><div class="line">    print(&apos;hello, world!&apos;)</div><div class="line">    await asyncio.sleep(1)</div><div class="line">    print(&apos;hello, again!&apos;)</div><div class="line">    </div><div class="line">async def funB():</div><div class="line">    print(&apos;are you ok?&apos;)</div><div class="line">    await asyncio.sleep(1)</div><div class="line">    print(&apos;hello, thank you! thank you very much!&apos;)</div><div class="line">    </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [funA(), funB()]</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<p>这样一看确实简洁了不少，也不会和 generator 中的 yield 搞混淆了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用这些高级方法，我们 Python 程序的效率可以进一步提高，特别是充分地利用了 io 的时间。</p>
<h2 id="更多示例代码"><a href="#更多示例代码" class="headerlink" title="更多示例代码"></a>更多示例代码</h2><h3 id="生成器生成杨辉三角"><a href="#生成器生成杨辉三角" class="headerlink" title="生成器生成杨辉三角"></a>生成器生成杨辉三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def yanghuiTri(mmax):</div><div class="line">    tri = [[1], [1, 1]]</div><div class="line">    yield tri[0]</div><div class="line">    yield tri[1]</div><div class="line">    r = 2</div><div class="line">    while r &lt; mmax:</div><div class="line">        row = [1]</div><div class="line">        </div><div class="line">        for i in range(1, r):</div><div class="line">            row.append(tri[r - 1][i - 1] + tri[r - 1][i])</div><div class="line">        row.append(1)</div><div class="line">        tri.append(row)</div><div class="line">        yield tri[r]</div><div class="line">        r += 1</div><div class="line"></div><div class="line"></div><div class="line">for l in yanghuiTri(10):</div><div class="line">    print(l)</div></pre></td></tr></table></figure>
<h3 id="asyncio-coroutine-获取网页头部"><a href="#asyncio-coroutine-获取网页头部" class="headerlink" title="@asyncio.coroutine 获取网页头部"></a>@asyncio.coroutine 获取网页头部</h3><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090954004980bd351f2cd4cc18c9e6c06d855c498000" target="_blank" rel="external">来源</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import asyncio</div><div class="line"></div><div class="line"># 如果要使用 async/await 就只用：</div><div class="line"># 1. 把 @asyncio.coroutine 替换为 async（在 def 前面）</div><div class="line"># 2. 把 yield from 替换为 await</div><div class="line"></div><div class="line"></div><div class="line">@asyncio.coroutine</div><div class="line">def wget(host):</div><div class="line">    print(&apos;wget %s...&apos; % host)</div><div class="line">    # asyncio.open_connection 返回一个 (reader, writer) 的二元组</div><div class="line">    # 来建立连接</div><div class="line">    connet = asyncio.open_connection(host, 80)</div><div class="line">    # yield from 一般是 io 请求，其实更准确的来说也是一个 coroutine，如果不是的话就会报错</div><div class="line">    # 此时程序直接进入另一个 task</div><div class="line">    # 等执行完返回值后再继续切换回来</div><div class="line">    reader, writer = yield from connet</div><div class="line">    header = &apos;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&apos; %host</div><div class="line">    # 发送 HTTP 请求</div><div class="line">    # 因为传输的是字节，因而要 encode</div><div class="line">    writer.write(header.encode(&apos;utf-8&apos;))</div><div class="line">    # 这里也是 io 请求，清空缓冲区</div><div class="line">    yield from writer.drain()</div><div class="line">    while True:</div><div class="line">        line = yield from reader.readline()</div><div class="line">        # 回答报文头部和正文之间间隔了一个 \r\n（字节形式的）</div><div class="line">        if line == b&apos;\r\n&apos;:</div><div class="line">            return</div><div class="line">        # Python rstrip() 删除 string 字符串末尾的指定字符（默认为空格）</div><div class="line">        # decode 是因为数据是以字节流来传输的</div><div class="line">        print(&apos;%s header &gt; %s&apos; % (host, line.decode(&apos;utf-8&apos;.rstrip())))</div><div class="line">    # 断开 TCP</div><div class="line">    writer.close()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [wget(host) for host in [&apos;www.sina.com.cn&apos;, &apos;www.sohu.com&apos;, &apos;www.163.com&apos;]]</div><div class="line"># asynico.wait 来让任务阻塞时能唤醒另一个任务</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<h3 id="asyn-await-获取网页头部"><a href="#asyn-await-获取网页头部" class="headerlink" title="asyn/await 获取网页头部"></a>asyn/await 获取网页头部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import asyncio</div><div class="line"></div><div class="line">async def wget(host):</div><div class="line">    print(&apos;wget %s...&apos; % host)</div><div class="line">    # asyncio.open_connection 返回一个 (reader, writer) 的二元组</div><div class="line">    # 来建立连接</div><div class="line">    connet = asyncio.open_connection(host, 80)</div><div class="line">    # await 一般是 io 请求</div><div class="line">    # 此时程序直接进入另一个 task</div><div class="line">    # 等执行完返回值后再继续切换回来</div><div class="line">    reader, writer = await connet</div><div class="line">    header = &apos;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&apos; %host</div><div class="line">    # 发送 HTTP 请求</div><div class="line">    # 因为传输的是字节，因而要 encode</div><div class="line">    writer.write(header.encode(&apos;utf-8&apos;))</div><div class="line">    # 这里也是 io 请求，清空缓冲区</div><div class="line">    await writer.drain()</div><div class="line">    while True:</div><div class="line">        line = await reader.readline()</div><div class="line">        # 回答报文头部和正文之间间隔了一个 \r\n（字节形式的）</div><div class="line">        if line == b&apos;\r\n&apos;:</div><div class="line">            return</div><div class="line">        # Python rstrip() 删除 string 字符串末尾的指定字符（默认为空格）</div><div class="line">        # decode 是因为数据是以字节流来传输的</div><div class="line">        print(&apos;%s header &gt; %s&apos; % (host, line.decode(&apos;utf-8&apos;.rstrip())))</div><div class="line">    # 断开 TCP</div><div class="line">    writer.close()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">tasks = [wget(host) for host in [&apos;www.sina.com.cn&apos;, &apos;www.sohu.com&apos;, &apos;www.163.com&apos;]]</div><div class="line"># asynico.wait 来让任务阻塞时能唤醒另一个任务</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;generator&quot;&gt;&lt;a href=&quot;#generator&quot; class=&quot;headerlink&quot; title=&quot;generator&quot;&gt;&lt;/a&gt;generator&lt;/h2&gt;&lt;p&gt;如果把一个可迭代对象比作一辆装有电池的四驱车，那么四驱车的马达会在电池电量耗尽之时才
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《头号玩家》——我为什么觉得它那么精彩</title>
    <link href="https://blog.patrickcty.cc/2018/04/07/%E3%80%8A%E5%A4%B4%E5%8F%B7%E7%8E%A9%E5%AE%B6%E3%80%8B%E2%80%94%E2%80%94%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A7%89%E5%BE%97%E5%AE%83%E9%82%A3%E4%B9%88%E7%B2%BE%E5%BD%A9/"/>
    <id>https://blog.patrickcty.cc/2018/04/07/《头号玩家》——我为什么觉得它那么精彩/</id>
    <published>2018-04-07T14:40:53.000Z</published>
    <updated>2018-04-07T14:45:22.525Z</updated>
    
    <content type="html"><![CDATA[<p>前几天我跟风去看了最近大热的电影《头号玩家》，整部电影的观感可以用一个词来形容：酣畅淋漓！那么究竟为什么我会觉得它那么精彩呢？</p>
<p>首先就像知乎里面的大家说的那样：认同感。从小到大，对于游戏，大多数人的印象都是精神鸦片以及类似的贬义词。但这整部电影是以游戏世界绿洲为背景的，这种设定是对游戏无声的肯定，也切切实实让我们也有了认同感，游戏在这里并不是鸦片，而是整个世界中不可或缺甚至是最重要的部分。</p>
<p>其次就是主角的身份了，主角是一个普通人，就和我们大家一样，这一点抹掉了通常的这种题材电影中主角和观众的距离。而主角的神勇同时也在表明着我们也能一样神勇，这种映射使得影片的代入感很强，观看时沉浸度也很高，更容易体会主角的感情以及电影的内容。</p>
<p>再者则是爱情与友情了，在游戏中也一样能收获到甜美的爱情以及坚定的友情。就像上一点所说，主角离我们很近，主角的爱情和友情一样会被映射到我们自己的身上。试问这样的爱情和友情谁不想拥有呢（特别对于单身狗）？在这里的爱情尤其的甜，特别是主角和女主在现实生活中见面的时候，对我来说这个场景甚至比许多爱情电影还要甜。为什么呢？因为虚拟场景中的恋爱是和现实中的恋爱有着巨大的鸿沟的，这种鸿沟的跨越，难道不令人激动么！更何况游戏中的妹子在现实中不仅是妹子而且还那么美丽而性感（醒醒，在网络中找不到的！）！</p>
<p>P.S. 真的太喜欢女主了！越看越顺眼！无论是游戏里还是游戏外！！！</p>
<p>除此之外，游戏中的各种彩蛋也是加分项，看到自己熟识的其他电影游戏中的角色与元素出现在现在大屏幕上，认同感再一次得到了加强，这就使得观影体验进一步的提高，观影的兴致也就更加高涨了~即使有不熟悉或者不认识相应的元素，但是帅不就够了么！比如看见高达出现在真人电影中真的太帅了！除了帅之外，同样的角色从动画到电影是一种全新的体验，是另一种诠释方式，这种令人耳目一新的感觉真的太棒了！</p>
<p>总之，无限加强的代入感和无限缩小的距离感使得电影仿佛多了一个维度，正是这多出的维度让电影变得更加精彩~至少对于我来说是这样的！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天我跟风去看了最近大热的电影《头号玩家》，整部电影的观感可以用一个词来形容：酣畅淋漓！那么究竟为什么我会觉得它那么精彩呢？&lt;/p&gt;
&lt;p&gt;首先就像知乎里面的大家说的那样：认同感。从小到大，对于游戏，大多数人的印象都是精神鸦片以及类似的贬义词。但这整部电影是以游戏世界绿洲
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="虚拟现实" scheme="https://blog.patrickcty.cc/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"/>
    
      <category term="游戏" scheme="https://blog.patrickcty.cc/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="幸福" scheme="https://blog.patrickcty.cc/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>《三体》——科技外壳下对人性的深刻剖析</title>
    <link href="https://blog.patrickcty.cc/2018/04/07/%E3%80%8A%E4%B8%89%E4%BD%93%E3%80%8B%E2%80%94%E2%80%94%E7%A7%91%E6%8A%80%E5%A4%96%E5%A3%B3%E4%B8%8B%E5%AF%B9%E4%BA%BA%E6%80%A7%E7%9A%84%E6%B7%B1%E5%88%BB%E5%89%96%E6%9E%90/"/>
    <id>https://blog.patrickcty.cc/2018/04/07/《三体》——科技外壳下对人性的深刻剖析/</id>
    <published>2018-04-07T12:45:07.000Z</published>
    <updated>2018-04-07T12:50:02.890Z</updated>
    
    <content type="html"><![CDATA[<p>初读《三体》，最吸引我的是其中的硬科幻，也就是它在科幻中融入的大量的科学知识，也因为如此小说新奇而同时贴合实际。</p>
<p>再读《三体》，书中深层的对人性的剖析则更加令我深思。特别是人性的反复无常在希望与绝望的交织中显露无疑。</p>
<p>如果要选出《三体》三部曲中的三个核心人物，那绝对是第一部的叶文洁，第二部黑暗森林的罗辑，第三部死神永生的程心。</p>
<p>三者都在不同程度上改变了人类文明的命运，前者是彻底打破了人类文明的安逸，将人类文明暴露在了狩猎者面前；中者则是彻底揭露了人类文明的幼稚，但同时又用自己强大的精神力震慑住了狩猎者，将人类文明稳定在了深渊边缘不至于堕入万劫不复的境地；后者则是人类文明中幼稚的代表体，也正是这份幼稚，让人类没能在黑暗森林中幸存下来。</p>
<p>罗辑这个人是三部曲中最重要的角色，也同时是最能反映人性的角色。他出生于黄金时代，在危机纪元被委以重任，成为担任拯救全人类任务的“面壁者”。而此时的他只是一个浑浑噩噩过日子的普通人，面对面壁者这种沉重而又孤独却同时权力巨大的身份时他选择了任何普通人都会去选择的逃避。</p>
<p>但他可是救世主啊，他可是担负着拯救全人类的愿景呀，于是那些要被他拯救的人类中断了他的幸福生活并将他逼上了绝境。但可笑的是，当他抛却一切得到解答，同时进入冬眠等待实验结果之时，等待他的却是被全人类当做笑话。</p>
<p>多亏了他玩世不恭的性格，他并没有因此而被巨大的反差带来的失落所击垮。事实上也正是因为他的性格，他才能挺过作为面壁者初期那巨大的压力，换做是另外一个普通人可能已经崩溃或者迷失自我了。除了罗辑自身的性格，大史的存在也为稳定罗辑的精神起了重要的作用，在性格上这两人比较类似，都是那种活在当下不为外界所影响的类型，而这种性格在任何情况下都能舒适地活下去。（多么希望我也是这样的性格啊。</p>
<p>然而命运似乎要给那些过河拆桥的人类一个教训，在末日之战中，人类重新回想起来了几个世纪以前初次面对三体人的恐怖。于是理所当然的，人类紧紧抓住那根救命稻草，因而那个“笑话”又重新成为了救世主。不过跌宕起伏的地位并非是一无是处，它使得罗辑的精神力更加强大，强大到足以突破三体世界的封锁和整个三体世界相抗衡。这是多么强大的一股精神力量啊，用一己之力，将最糟糕的局势反转，将人类的生活拉回正轨，为人类营造了七十年的和平时间。</p>
<p>从来没有一个人是生而为救世主的，也同样没有一个人是生而为毁灭者的。这其中一定起源于某种品质——在罗辑身上是坦然面对生活，在灭霸身上是对死亡的爱；然后再在磨砺中加以强化，直到最后铸成坚不可摧的信念，或者是恶意；前者使罗辑维持住了人类的命运，后者使灭霸毁灭了无数文明。但磨砺的过程一定是极其痛苦的，甚至是压倒性的绝望，这些我们都无法想象，因为面对容易得多的困难，我们尚被压得喘不过气来。</p>
<p>对于罗辑，我只有无上的敬佩可以向他表达。</p>
<p>而程心则是把最后一根稻草放到骆驼身上的那个人。尽管人类的毁灭和她有着直接的关系，但这是全体人类的责任，而不是她的全责。人类总喜欢把命运寄托在少数人的手上，前有罗辑，后有程心。但这样做的坏处就是把鸡蛋放在一个篮子里面——只要这个篮子出现了问题那就是灾难性的后果。</p>
<p>程心并不是一个十恶不赦的恶人，相反她是一个极度善良的人，只是她生在了错误的年代。面对前所未见的凶恶敌人，人类依旧选择了用善良来面对，结果就只能是灭亡，而这样的选择几乎是无法改变的，在人类中没有足够大的力量可以左右整个人类的选择，连罗辑也不可以，因为人类的善良是基于他们的自信，或者更准确的来说是来源于自己的无知与自大。而这自大则是因为人类进步得太快而忘乎所以。</p>
<p>或许如果让章北海作为人类世界的最高领袖人类的被毁灭的命运才会改变吧。</p>
<p>而对于现在，三体对我来说最大的启发就是：做一个罗辑和大史那样的人，不以物喜，不以己悲，创造属于自己生活；做一个程心那样的人，奉献自己，兼济天下。前者出世，后者入世；但有趣的是，在小说中，出世者拯救世界，入世者将世界带往毁灭，不过这也与我们现在的生活无关了。</p>
<p>回到人性，那些或令人肃然起敬，或令人哭笑不得，或令人心生鄙夷的结果都是人性的表达，而无分好坏。但事实上对于人性，我们可以加以约束，让自己不像狂风中的小草，随风摇曳，而像扎根于土地的大树，岿然不动。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初读《三体》，最吸引我的是其中的硬科幻，也就是它在科幻中融入的大量的科学知识，也因为如此小说新奇而同时贴合实际。&lt;/p&gt;
&lt;p&gt;再读《三体》，书中深层的对人性的剖析则更加令我深思。特别是人性的反复无常在希望与绝望的交织中显露无疑。&lt;/p&gt;
&lt;p&gt;如果要选出《三体》三部曲中的
    
    </summary>
    
      <category term="书籍" scheme="https://blog.patrickcty.cc/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
      <category term="三体" scheme="https://blog.patrickcty.cc/tags/%E4%B8%89%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>《声之形》——将也的自我救赎之路</title>
    <link href="https://blog.patrickcty.cc/2018/03/16/%E3%80%8A%E5%A3%B0%E4%B9%8B%E5%BD%A2%E3%80%8B%E2%80%94%E2%80%94%E5%B0%86%E4%B9%9F%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E%E4%B9%8B%E8%B7%AF/"/>
    <id>https://blog.patrickcty.cc/2018/03/16/《声之形》——将也的自我救赎之路/</id>
    <published>2018-03-16T08:29:02.000Z</published>
    <updated>2018-03-16T08:31:19.787Z</updated>
    
    <content type="html"><![CDATA[<p>做了那么过分事情的他，能被原谅么，这是将也一直以来的心结，也是在自我了结之前最想知道的问题。那最后他为什么没有自我了结呢？可能正是因为他知道了这个心结有解开的可能性。而在这之后，男主的自我救赎之路就开始了。</p>
<p>校园霸凌是一个世界性的问题，而男主的心结也是由此而生，因为做得太过分，他自己也变成了被霸凌的对象，甚至之后还因此封闭了自我。</p>
<p>而男主去解开心结的方法是去赎罪，尽管他不愿承认。幸好硝子天性善良选择接纳了他，并在他的努力下重新维系起了之前断掉的关系。但这些人中只有佐原依旧善待硝子，其他人对待硝子的态度并没有发生什么改变。</p>
<p>在看的时候，我以为电影是两条线进行：将也找回自我的线以及硝子改变对自我看法的线。但我为硝子感到可悲，她的那些朋友到最后也没有深入她的内心，也没有人告诉她她有那么一颗温柔而强大的内心，值得活在这个世界上，被这个世界善待。不是因为她而让这个世界变得黑暗，而是因为这个世界的恶意一直让她陷入黑暗。令人遗憾的是到最后男主也只是真心说出了抱歉而没有解开女主的心结。</p>
<p>虽然最后女主已经不再想着轻生，也好像变得开朗，但我为什么却还是为女主感觉那么悲伤呢。愿所有硝子都能被温柔以待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了那么过分事情的他，能被原谅么，这是将也一直以来的心结，也是在自我了结之前最想知道的问题。那最后他为什么没有自我了结呢？可能正是因为他知道了这个心结有解开的可能性。而在这之后，男主的自我救赎之路就开始了。&lt;/p&gt;
&lt;p&gt;校园霸凌是一个世界性的问题，而男主的心结也是由此而生
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="日漫" scheme="https://blog.patrickcty.cc/tags/%E6%97%A5%E6%BC%AB/"/>
    
      <category term="校园霸凌" scheme="https://blog.patrickcty.cc/tags/%E6%A0%A1%E5%9B%AD%E9%9C%B8%E5%87%8C/"/>
    
      <category term="自我救赎" scheme="https://blog.patrickcty.cc/tags/%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>春节档电影</title>
    <link href="https://blog.patrickcty.cc/2018/03/14/%E6%98%A5%E8%8A%82%E6%A1%A3%E7%94%B5%E5%BD%B1/"/>
    <id>https://blog.patrickcty.cc/2018/03/14/春节档电影/</id>
    <published>2018-03-14T01:21:02.000Z</published>
    <updated>2018-03-14T01:21:59.783Z</updated>
    
    <content type="html"><![CDATA[<p>春节档电影总是有限，这次一共有四部，其中西游记题材的真的是看烂了，于我而言完全没有观看的欲望。另外的三部中我看了两部，这两部都给了我相应的惊喜。</p>
<p>首先看的是《唐2》，整部电影的节奏把握得很好，观众看起来比较畅快，里面的喜剧元素也让人比较轻松，刘昊然推理时候的场景简直科技感炸裂，看得也非常过瘾。剧情方面在看的时候也没发现明显的槽点，不过事后看大家的评论才知道原来推理有这么多漏洞 233，不过作为一个非推理迷，剧情还是比较让人满意的。评分的话我个人觉得可以有 8/10。</p>
<p>接下来看的是《红海》，这一部是春节档中口碑最好的一部，看完之后觉得真的很良心，战斗场面逼真度极高且恢弘，人物表现丰满，就是整体一直维持在高强度的节奏看完之后个人感觉很累……还有给血腥场面的特写真的有点尺度太大了啊……整体评分的话 8.5/10，不适合带着孩子老人去看，一部不作的主旋律好片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节档电影总是有限，这次一共有四部，其中西游记题材的真的是看烂了，于我而言完全没有观看的欲望。另外的三部中我看了两部，这两部都给了我相应的惊喜。&lt;/p&gt;
&lt;p&gt;首先看的是《唐2》，整部电影的节奏把握得很好，观众看起来比较畅快，里面的喜剧元素也让人比较轻松，刘昊然推理时候的场
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="喜剧" scheme="https://blog.patrickcty.cc/tags/%E5%96%9C%E5%89%A7/"/>
    
      <category term="战争片" scheme="https://blog.patrickcty.cc/tags/%E6%88%98%E4%BA%89%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>《黑豹》</title>
    <link href="https://blog.patrickcty.cc/2018/03/14/%E3%80%8A%E9%BB%91%E8%B1%B9%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2018/03/14/《黑豹》/</id>
    <published>2018-03-14T01:14:26.000Z</published>
    <updated>2018-03-14T01:17:26.329Z</updated>
    
    <content type="html"><![CDATA[<p>对我来说，看电影的话，要看就要看好电影，但这好电影的标准不知何时已经变成了让我觉得有意思的电影，而相对的，电影的逻辑严密性，主题反而没那么重要了。</p>
<p>而这部《黑豹》，对我来说则无疑是一部好电影。整部电影最精彩的部分就是瓦坎达的科技了，因为有了万能的振金，被外界视作贫困潦倒的第三世界国家实际上是一个科技高度发达的不为外界所知的文明国度。</p>
<p>不得不说振金的设定真的非常巧妙，影片中出现的能远程驾驶的控制器，能防止子弹和碰撞的汽车，自由伸缩的长矛，可以掀翻无敌汽车的手部“空气炮”，看似毛毯却可以当做盾牌的奇妙物件以及强度甚至比钢铁侠战甲还要高的黑豹战斗服（最重要的是不用躲在角落换衣服了 233），这些科技产物绝对是一场视觉盛宴，极具观赏性。</p>
<p>而剧情方面就没有科技来得那么精彩了，因为电影的核心所在应该是想要表达的主题：能力越大，责任越大，与其独善其身，更应兼济天下。而大反派就是因为前代想“独善其身”而造成的畸形产物，主角的任务就是弥补父亲以前的错误。也正是因为主题，影片中花大量的篇幅引导我们思考是应该独善其身还是应该站出来兼济天下，而大反派的戏份也因此比较有限，与主角的碰撞也比较草率地结束了，尽管反派塑造的很好很有魅力，但却有虎头蛇尾的嫌疑。</p>
<p>有一个问题是主角团这边形象没有其他的漫威电影来得高大，主角的魅力也没怎么凸显出来，至少远远没有《美国队长 1》那么好，不过后面的《复仇者联盟 3》黑豹还有不少戏份，希望到时候黑豹的形象能更加丰满高大。</p>
<p>评分 8/10，影片中的高科技元素是家分店，主题的表达也是可圈可点，但是因此而削弱了人物形象的塑造有点得不偿失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对我来说，看电影的话，要看就要看好电影，但这好电影的标准不知何时已经变成了让我觉得有意思的电影，而相对的，电影的逻辑严密性，主题反而没那么重要了。&lt;/p&gt;
&lt;p&gt;而这部《黑豹》，对我来说则无疑是一部好电影。整部电影最精彩的部分就是瓦坎达的科技了，因为有了万能的振金，被外界视
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="超级英雄" scheme="https://blog.patrickcty.cc/tags/%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84/"/>
    
      <category term="漫威" scheme="https://blog.patrickcty.cc/tags/%E6%BC%AB%E5%A8%81/"/>
    
  </entry>
  
  <entry>
    <title>《奇迹男孩》</title>
    <link href="https://blog.patrickcty.cc/2018/01/31/%E3%80%8A%E5%A5%87%E8%BF%B9%E7%94%B7%E5%AD%A9%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2018/01/31/《奇迹男孩》/</id>
    <published>2018-01-31T15:56:44.000Z</published>
    <updated>2018-01-31T15:59:23.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>当你因为先天缺陷而导致面容与常人不同时，你是选择封闭自己还是敞开怀抱？当你的孩子你因为先天缺陷而导致面容与常人不同时，你会怎样对待他？当你拥有一个因为先天缺陷而导致面容与常人不同的弟弟，而且这个弟弟从父母那里剥夺走了原本属于你的爱与关心，你会怎么做？如果你遇到了这样的同学，他因为先天缺陷而导致面容与常人不同，你会怎么对待他？</p>
<p>影片对这些问题进行了探讨，交出来的答卷确实也相当有水平。</p>
<p>首先我们从父母的角度来看。对于这样与众不同的孩子，他们并没有一到年龄就将他交给学校，我想他们也明白，童年产生的阴影可能会影响一辈子，因而他们选择在家里对孩子进行早教，同时在这个过程中也仍保留着对孩子性格的引导——让他知道他仍是一个正常孩子。这些举措确实有效，不仅给了他一个相对快乐的童年，还进行了充分的积累来让他能相对安稳地踏进真正的社会。</p>
<p>而这一天也终于到来，影片中说得很有道理的一点是：在某些方面，成年人社会比小孩社会要好过，因为小孩不懂得隐藏自己的情绪，而小孩子面对与自己不同的事物，通常采取的措施是排斥、孤立与嘲笑。因而校园霸凌与孤立成为了奥吉面临的最大的问题，而这些问题是普遍存在于所有的中小学学校中的。</p>
<p>我记得在小学的时候，我们班有一个吴同学，可能因为他是务工子弟的儿子，他身上的衣服和鞋子总是感觉破破烂烂的，并有些脏，也有一些同学说他“臭”，但这臭是否是真实存在的我其实也不清楚。就是因为他的这些不同之处，他受到了我们班的一些不良同学的排挤，就像是电影里的朱利安所做的类似的事情。我们都知道，为了合群或是出于其他的一些原因，学校中跟风的行为非常普遍，我也因此对吴同学采取疏远的态度，甚至有一次还将他推下了升旗台……但尽管如此，在之后我还去他家玩过，也曾有一段时间和他在一起玩，虽然关系并没有密切到和电影中杰克与奥吉的关系那样。因为不想成为被孤立的人，我也加入了孤立他的人群中，而我们班其他同学的想法似乎和我也相同，因此吴同学自始至终都受到了排挤与霸凌。</p>
<p>我们的奥吉在进学校之际就因为外貌而遭受了类似的对待，但和吴同学不同的是，在受到排挤之际，有同学不害怕也被孤立，站了出来和奥吉交朋友，也正是在这个过程中，奥吉自身的优点也为人所知，其他人也不再因为他的与众不同外貌而排斥他了。</p>
<p>首先站出来的是杰克威尔，但是他依然害怕被孤立，因而在他和朱利安他们一起的时候说出了迎合他们的话语，而正是这句话是深深刺痛了奥吉的内心；真正让奥吉敞开心扉的是莎莫，比起杰克是因为奥吉的帮助而开始与他相处，莎莫是在奥吉最为脆弱的时候出现在了奥吉的身边，并让奥吉知道了友谊的真正感觉，同时也将他从背叛的阴影之中解救出来。</p>
<p>如果当时我们班里面有人更勇敢一点，如果那个勇敢的人就是我，那么就可以让吴同学的小学生活更加好一点，只是合群的魔爪钳住了我们，将我们和吴同学放在了对立的位置……</p>
<p>接着我们来到姐姐的角度。一般在拥有多个孩子的家庭里面，最受宠的都是最小的那个。在本部影片中，更小的孩子还拥有先天缺陷而需要父母亲更多的关爱，因而姐姐得到的爱就更少了。尽管我是独生子女不存在这样的问题，但是如果让我面临这样的情况那我的内心一定相当郁闷甚至导致我不给弟弟好脸色看。然而影片中的姐姐隐藏了自己的情绪，一方面不给爸爸妈妈添麻烦，另一方面又尽自己所能来照顾与众不同的弟弟。</p>
<p>姐姐这部分最让我印象深刻的是在万圣节的这天，本来是她和妈妈的独处被弟弟所破坏，尽管姐姐很生气，但是面对更加伤心的弟弟，她压下了自己的情绪，而去想方设法安慰弟弟，让他走出家门，走出了郁闷。由此看来弟弟的健康成长中姐姐也是功不可没的呢。</p>
<p>虽然姐姐足够好，但是这部分父母亲还是有点失职，即使有个特殊的孩子要照顾，但也不能忽视了那个乖巧懂事的另一个孩子的存在，尽管那个孩子看起来足够坚强，似乎并不需要心疼。姐姐的那场演出让父母知道了他们一直忽视的姐姐的优秀，也让他们察觉到了他们所存在的对姐姐的关心太少的问题。</p>
<p>接下来则是米兰达的角度。米兰达突然的冷漠态度原来是为了圆上自己身世的幌子，而正是这个身世，让米兰达在夏令营中成为最受欢迎的人。这无疑也是群体中经常出现的另一个问题，每个人都想受到其他人的关注，而这份关注需要相应的基础来支撑，如果没有相应的基础则需要一定的代价来进行交换，米兰达交换的筹码则是自己最真挚的友谊。但在经历了那么多之后，米兰达终于明白了，最珍贵的应该是友谊，而不是那泡沫般的受欢迎，也正是米兰达的醒悟，让姐姐得以在家人面前展示自己从而让父母认识到了自己一直以来对姐姐的忽视。</p>
<p>影片是从多个人物的角度来讲述故事，不过主要的故事都围绕在奥吉的身上。这样的讲述手法给故事设置了很多矛盾冲突，又在之后一一进行解决，让故事充满波折又引人思考，除此之外，影片对我一开始提的问题的思考也非常深刻，是一部非常用心的影片。</p>
<p>插点题外话，这部电影是我和我表弟一起看的，看的时候电影院中基本上都是家长带着孩子看。一开始我还以为这会是一部非常扯的亲子向电影，但最终看下来我实在是收获良多。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>9/10.</p>
<p>内容有趣而令人感动，主题也比较深刻，感情也非常充沛，非常值得一看！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;当你因为先天缺陷而导致面容与常人不同时，你是选择封闭自己还是敞开怀抱？当你的孩子你因为先天缺陷而导致面容与常人不同时，你会怎样对待他？当你拥
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="爱" scheme="https://blog.patrickcty.cc/tags/%E7%88%B1/"/>
    
      <category term="友情" scheme="https://blog.patrickcty.cc/tags/%E5%8F%8B%E6%83%85/"/>
    
      <category term="励志" scheme="https://blog.patrickcty.cc/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>《神秘巨星》</title>
    <link href="https://blog.patrickcty.cc/2018/01/31/%E3%80%8A%E7%A5%9E%E7%A7%98%E5%B7%A8%E6%98%9F%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2018/01/31/《神秘巨星》/</id>
    <published>2018-01-31T02:38:44.000Z</published>
    <updated>2018-01-31T02:42:48.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这是阿米尔汗的另一部新作，也正是冲着阿米尔汗这个名字，我果断地贡献了一份电影票。而看完这部电影之后我感觉它确实没有让我失望。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>阿米尔汗的每部电影都反映着一个或多个印度中存在的不好的社会现象，而这次他对准的是印度的重女轻男的思想以及婚姻不平等，而这样的主题是通过小女孩对梦想的追求来表现的。</p>
<p>影片中最大的冲突就是小女孩对梦的追求与父亲不允许的冲突，影片中的父亲是一个大男子主义严重到不允许其他女人有违逆他的想法，如果有就施以暴力。而最可怕的是，这个父亲还是家庭里面的经济支柱，而毫无经济实力的母子只能逆来顺受。</p>
<p>影片中对家庭暴力的刻画还是非常到位的，甚至都让我感觉不寒而栗。也正是在家庭暴力与对梦想的阻挠两方面的共同作用下，促使了小女孩的觉醒，而另一个关键则是母亲的觉醒，但母亲则需要考虑更多实际的问题，因而对小女孩提出的离婚的要求她并没有一开始就答应，而是在将要离开印度之时才做出选择。</p>
<p>影片中最剧烈的两个冲突也即为母子觉醒的导火线，第一个是在父亲发现母亲项链消失的真相之后砸掉电脑以及最后在机场想要丢掉吉他，其中后者也是全剧中的最高潮，母亲也终于甩掉来了一直以来的懦弱以及物质的包袱而去拥抱一个未知但是有着无穷潜力的未来。</p>
<p>片中让我比较印象深刻的另一个角色就是钦腾了，这个小男孩实力告诉了我们撩妹的精髓所在，即使被嫌弃他也不放弃而是依然如故，最终他们终于修成正果（虽然我觉得有些勉强）。无论如何钦腾的性格真的是非常适合追妹子，比我好多了 233，要是我有他的一半那我一定能追到妹子 233。</p>
<p>影片中刻画得最好的是母亲这一形象，她全心全意地爱着自己的两个孩子，对女儿的爱表现得尤为明显。她非常爱女儿，对女儿的要求是有求必应，但这些仍被限制在了父亲允许的前提下，而也正是在这样的条件下，面对女儿让她离婚的请求，她才不去答应，因为这样的未来是没有物质的保障的，这样可能使女儿过得更差，因而她宁可忍受家暴也要让女儿有一个有保障的生活，因而当女儿的吉他弦被剪断她也忍了，因而当女儿的电脑被砸她也没有选择离婚。而当将离开印度之时，当她从电视和路人口中真正感受到女儿的音乐天赋时，这时候当父亲要扔掉那个被称作是“垃圾”的吉他，要彻底断绝女儿的音乐梦想，母亲终于抛弃了之前的想法与顾虑，在大众的“保护”下勇敢站了出来，选择了离开，她完成了觉醒，也选择了一条可能会艰难但是却有可能无比辉煌的道路。</p>
<p>而我们的阿米尔汗在这部电影中只是一个配角，影片中对他的描写是先抑后扬，就是这样的一个刻薄、自大、花心、惹人讨厌的人，却帮助小女孩一步一步完成了救赎，也找到了自己的初心。这个角色整体刻画得还不错，只是有些地方让人感觉用力过猛。</p>
<p>整部电影的硬伤还是不少的，但这位并不妨碍它想要表达的追求梦想、鼓励家庭暴力的受害者拿起法律的武器来反抗、追求男女平等的思想。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10.</p>
<p>整体观影体验还不错，就是一些硬伤使得这部电影的剧本方面还有进步的空间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;这是阿米尔汗的另一部新作，也正是冲着阿米尔汗这个名字，我果断地贡献了一份电影票。而看完这部电影之后我感觉它确实没有让我失望。
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="梦想" scheme="https://blog.patrickcty.cc/tags/%E6%A2%A6%E6%83%B3/"/>
    
      <category term="反对家庭暴力" scheme="https://blog.patrickcty.cc/tags/%E5%8F%8D%E5%AF%B9%E5%AE%B6%E5%BA%AD%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="男女平等" scheme="https://blog.patrickcty.cc/tags/%E7%94%B7%E5%A5%B3%E5%B9%B3%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>《寻梦环游记》</title>
    <link href="https://blog.patrickcty.cc/2018/01/18/%E3%80%8A%E5%AF%BB%E6%A2%A6%E7%8E%AF%E6%B8%B8%E8%AE%B0%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2018/01/18/《寻梦环游记》/</id>
    <published>2018-01-18T11:32:51.000Z</published>
    <updated>2018-01-18T11:36:20.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这部电影上映的时候还是在 2017.11.24，那时候因为种种原因我想看但是一直没有去看。现在我终于考完了，于是赶紧趁还没下线去电影院观看了~</p>
<p>看这部电影的时候中途放映机还坏了一会 233，不过即使没有画面，听着英文还是听得懂的 233。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>为什么想看这部电影呢？很大程度上在于我之前看的影评，那么这部电影究竟有没有影评中所说的那么好呢？下面会给出答案。</p>
<p>迪士尼和皮克斯的动画电影从来没有让人失望过，这次也是一样，无论是从主题上，画面上还是剧情上都依旧让人赞叹不已。</p>
<p>剧情中最大的冲突在于我们的主人公米格的音乐梦。米格的曾曾祖父因为去搞音乐了而离家而去再也没有回来，而这个家被曾曾祖母依靠做鞋子而一手支撑起来了，但同时曾曾祖母也认为音乐是一个诅咒，不允许家族中再出现音乐相关的内容。正因为此，家族的约束和小男孩的音乐梦发生了激烈的冲突。</p>
<p>让人眼前一亮的是，上面的这些剧情介绍是用一种特别的方式表达出来的——剪纸风格，这样的风格完美地符合了亡灵节的主题，同时又不落俗套。</p>
<p>故事的第一阶段是少年的觉醒阶段，从完全被家里人所控制无从实现自己的音乐，到萌生反抗的想法再到受到鼓舞决定不顾家人的反对勇敢去实现梦想。也正是因为有了这样的转变，少年才能无意中接触到亡灵世界。</p>
<p>而亡灵世界无疑是“炫技”的极限了，恢弘的亡灵国度通过高超的动画技术被表现得淋漓尽致。</p>
<p>第二个阶段则是米格寻找歌神。米格之所以进入亡灵世界是因为受到了诅咒，必须要得到亲人的祝福才能回到原本世界，而亲人们却同样反对他的音乐梦想，因而米格要想坚持音乐梦想则需要得到歌神，也就是他认为的曾曾祖父的帮助。</p>
<p>在剧情方面，电影故意让观众以为歌神才是米格真正的曾曾祖父，但之后却来了个大反转——原来米格真正的曾祖父并不是歌神，而是那个过不了关无法看望亲人的埃克托，歌神也没有他向外界表现得那么美好，他的成功原来建立在谋杀并且占有埃克托的成果的基础上。</p>
<p>在寻找歌神的这个过程中，米格终于展现出了自己的音乐才华，也完成了蜕变——变得自信而坚定，也从埃克托那里找到了亲情的真谛。其实关于歌神真正的面目影片中已经有铺垫：歌神的演唱会他自己却不去参加排练，而是交给其他的人员来进行，而一个稍微敬业一点的明星都不会做出这么不负责的举动。</p>
<p>第三个阶段则是回到家人的身边。埃克托的真实身份米格已经了解，但是他却一直没有被她老婆所原谅，而在这个阶段中那股仇恨终于被爱所消解，歌神的真实面目也展现在了大众面前，但这时埃克托却因为快被遗忘而即将消失，米格也在日出之前勉强回到了原本世界。</p>
<p>这部分的“战斗”部分让人印象深刻，影片充分利用了骨头的特点，将手臂拆下来当做双节棍等来使用这些非常“骨头”的场景真的非常符合世界的设定，也让人会心一笑。</p>
<p>最后一个阶段是音乐唤醒亲情。在埃克托即将被遗忘之际，米格使用埃克托的吉他，用那首写给 Coco 的《Remember Me》，成功将 Coco 的记忆唤醒，同时也消解了家庭中对音乐的误解。</p>
<p>最后的结局还是非常圆满的，歌神的真实身份，埃克托的故事也为大家所知晓，米格的音乐梦想也得以继续，Coco 也终于和埃克托团聚。</p>
<p>何为亲情？亲情应该是相互扶持的同时又相互谅解，尊重梦想，尊重家庭成员的感受这才是真正的亲情所拥有的样子。尽管伊梅尔达一开始对埃克托非常恨，恨他理开这个家不再回来，但是尽管如此，深埋着的爱并没有随之消散，而是等待着爆发的那一刻，影片想表达的亲情从这里也表现得淋漓尽致。</p>
<p>现在回到开始的那个问题：这部电影究竟有没有影评中所说的那么好呢？其实比起来还差了一点点，因为亲情这个主题实在是有些老套，但是它仍然是一部质量极佳的作品，绝对值回票价。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>9/10.</p>
<p>影片整体质量很高，不过比起之前的《头脑总动员》的精妙的设定还稍微差了一点，但无论如何仍然是一部无可挑剔的高质量影片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;这部电影上映的时候还是在 2017.11.24，那时候因为种种原因我想看但是一直没有去看。现在我终于考完了，于是赶紧趁还没下
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="亲情" scheme="https://blog.patrickcty.cc/tags/%E4%BA%B2%E6%83%85/"/>
    
      <category term="梦想" scheme="https://blog.patrickcty.cc/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《敦刻尔克》</title>
    <link href="https://blog.patrickcty.cc/2018/01/13/%E3%80%8A%E6%95%A6%E5%88%BB%E5%B0%94%E5%85%8B%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2018/01/13/《敦刻尔克》/</id>
    <published>2018-01-13T02:41:36.000Z</published>
    <updated>2018-01-13T02:46:09.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>上次看完电影写感受还是 8.26 的《十万个冷笑话 2》了。不知不觉中，坚持了那么久的习惯就突然被终止了，就像我在另外方面的坚持，也是戛然而止。</p>
<p>现在又是考试周期间，但是如今我却不向大一的时候那么从容，曾经的“大靠大玩，小考小玩”对现在的我已然成为了过去完成时，以前的“考试电影周”亦是不复存在。</p>
<p>这学期的我的心态经历了过山车，从充满动力及幸福，到煎熬，到后来的一直的隐性自暴自弃，消极，以及现在都持续影响着我的浮躁……</p>
<p>无论如何，电影感想又开始了，闲话少叙，进入正题。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这是诺兰继《星际穿越》之后的又一部执导作品。诺兰可以说是我最喜欢的导演了，他的作品独特的风格使得每篇作品都有一种和普通影片截然不同的观影感受，这也是我最欣赏的地方。</p>
<p>而这部《敦刻尔克》，描写的是战争，虽然不能发挥出之前的悬疑感，但是诺兰的风格还是让这部影片独具特色。</p>
<p>影片拥有三条主线，分别为空海陆，对应的是一小时，一天，十天。比较遗憾的是在看电影的地方我并没有注意到这个时间的关系，因而诺兰精密的安排我没有完全把握住。不过最后三条主线交汇到一条还是让我把握到了命运的气息。</p>
<p>我觉得这部电影想描述的最重要的不是战争，而是人。从电影刚开始的时候主角的丢枪逃跑，到之后为了生存的各种努力，都让我们感受到了战争的残酷，生存的艰难，以及战场上人的实际身理与心理状况。</p>
<p>而海上这条线则表示得更加淋漓尽致：为了向证明自己价值的乔治，因为炮弹而极度害怕的士兵，因为乔治受伤而从愤怒到最后转为体谅的彼得，从始至终都沉稳的道森先生。尽管失去了乔治，但他们所在的这艘小船将许许多多的被困在敦刻尔克的士兵带回了家，也让他们不再重蹈道森先生儿子的覆辙了。</p>
<p>而空中的这条线却更加含蓄，片尾法里亚选择不去跳伞而被俘虏这个表现得最为淋漓尽致。在击落这么多架敌机之后，法里亚面对油已经耗尽的飞机，没有选择跳伞而是随着飞机一起滑翔直到降落，是为了不让这架英国最新研制的喷火战机被德国人所得到而研究，也是为了给正在撤退的士兵带来希望，将他们从压抑中给解救出来。</p>
<p>除开人物之外，本片的配乐也是一大亮点，我是在寝室用头戴耳机来听的，配合着电影压抑的氛围，配乐更进一步渲染了这种气氛，因此整部影片看完我整个人是极度疲惫的，这种疲惫是精神上的，也间接让我感受了历史上真是存在的压抑的微小的一部分。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10。</p>
<p>这依然是一部典型的诺兰式电影，虽然情节不及之前来得酣畅淋漓，但是看完之后还是让人感触良多，依然保持了一贯的高质量。</p>
<p>电影中生存是一件如此困难的事情，而我们呢，或许真的是只有当将要失去的时候才能感受到宝贵的地方吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;上次看完电影写感受还是 8.26 的《十万个冷笑话 2》了。不知不觉中，坚持了那么久的习惯就突然被终止了，就像我在另外方面的
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="战争" scheme="https://blog.patrickcty.cc/tags/%E6%88%98%E4%BA%89/"/>
    
      <category term="历史" scheme="https://blog.patrickcty.cc/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java Spring Boot 笔记</title>
    <link href="https://blog.patrickcty.cc/2018/01/03/JavaSpringBoot%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.patrickcty.cc/2018/01/03/JavaSpringBoot笔记/</id>
    <published>2018-01-03T08:51:26.000Z</published>
    <updated>2018-01-03T08:52:31.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collection、Map、Set-与-List"><a href="#Collection、Map、Set-与-List" class="headerlink" title="Collection、Map、Set 与 List"></a>Collection、Map、Set 与 List</h2><ul>
<li>Collection（容器）是集合接口，保存一组对象（Object）</li>
<li>Map 类似于 Python 的 dict，用来保存映射，HashMap 是 Map 的一种实现</li>
<li>List 类似于 Python 数组，用下标来取值，LinkedList、Vector 都是其实现</li>
<li>Set 是集合，只能通过游标来取值，HashMap 是其的一种实现</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>平常的对象和函数都是接受固定类型的变量作为参数，但是泛型接受的参数可以是不确定的，可以接受任意数据类型的变量作为参数，当然除了基本类型</p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional 对象相当于是一个容器，它的值可以为 null。如果值存在则 isPresent() 方法会返回 true，此时调用 get() 方法就会返回容器中的对象。</p>
<p>这个类的主要作用就是把 null 用容器装起来了，可以不用显示地进行控制检测，可以有效解决空指针异常。</p>
<h2 id="jsonignore"><a href="#jsonignore" class="headerlink" title="@jsonignore"></a>@jsonignore</h2><p>在 JSON 返回的时候，有些值我们不想让它显示给客户端，比如密码，因此可以用这个注释来忽视掉这些属性</p>
<h2 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h2><p>JavaBeans 是 Java 中一种特殊的类，其中：</p>
<ul>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ul>
<p>这样做是因为 Java 语言欠缺属性、事件、多重继承功能。</p>
<h2 id="gt-表达式"><a href="#gt-表达式" class="headerlink" title="-&gt; 表达式"></a>-&gt; 表达式</h2><p>和 JS 类似，Java 的 -&gt; 表达式定义的也是一个匿名函数，在这里叫做 Lambda 表达式，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; expression</div><div class="line">或</div><div class="line">(parameters) -&gt;&#123; statements; &#125;</div></pre></td></tr></table></figure>
<p>表达式的特点为：</p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>这个方法是用来把参数包装成一个 List，可以接受数组作为参数。</p>
<h2 id="Spring-Boot-关键构件"><a href="#Spring-Boot-关键构件" class="headerlink" title="Spring Boot 关键构件"></a>Spring Boot 关键构件</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>类似于 Flask 中的 Model 类，用来表示数据库的结构。</p>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>直接与数据库进行交互，类似于 Flask 中的 db.session 需要自己定义相应的方法来实现一些对数据库的 CURD 操作。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>相当于 Flask 中的 view，表示业务逻辑的代码</p>
<h2 id="SQL-Dialect"><a href="#SQL-Dialect" class="headerlink" title="SQL Dialect"></a>SQL Dialect</h2><p>不同的 SQL 数据库都有不同的 SQL 扩展，这种扩展就是“方言”</p>
<h2 id="SQL-Server-中文显示为问号"><a href="#SQL-Server-中文显示为问号" class="headerlink" title="SQL Server 中文显示为问号"></a>SQL Server 中文显示为问号</h2><p>这个是字符集(collate)顺序的锅，默认的字符集不显示中文，我使用了下面的语句来更改数据库的字符集顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter database dbname collate Chinese_PRC_CI_AS</div></pre></td></tr></table></figure>
<p>以及下面的语句更改表中列的字符集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table tbname alter column clname cltype collate Chinese_PRC_CI_AS</div></pre></td></tr></table></figure>
<p>结果改了之后查询以及插入值再查询后依然是问号，但是重新创建数据库之后就可以正确显示中文了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create database dbname collate chinese_prc_ci_as</div></pre></td></tr></table></figure>
<p>真的好坑，不知道是不是我人品比较差不能直接修改。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://zhidao.baidu.com/question/51161338.html" target="_blank" rel="external">https://zhidao.baidu.com/question/51161338.html</a></li>
<li><a href="https://stackoverflow.com/questions/16685269/error-on-renaming-database-in-sql-server-2008-r2" target="_blank" rel="external">https://stackoverflow.com/questions/16685269/error-on-renaming-database-in-sql-server-2008-r2</a></li>
</ul>
<h2 id="List-用法"><a href="#List-用法" class="headerlink" title="List 用法"></a>List 用法</h2><h3 id="取出-List-中的元素"><a href="#取出-List-中的元素" class="headerlink" title="取出 List 中的元素"></a>取出 List 中的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.get(1)  // 数字为 index</div></pre></td></tr></table></figure>
<h3 id="检查-List-是否为空"><a href="#检查-List-是否为空" class="headerlink" title="检查 List 是否为空"></a>检查 List 是否为空</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.isEmpty()</div></pre></td></tr></table></figure>
<h3 id="查看-List-的大小"><a href="#查看-List-的大小" class="headerlink" title="查看 List 的大小"></a>查看 List 的大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.size()</div></pre></td></tr></table></figure>
<h2 id="JPA-中的查询方法"><a href="#JPA-中的查询方法" class="headerlink" title="JPA 中的查询方法"></a>JPA 中的查询方法</h2><p>和 SQLAlchemy 类似，除非指定返回一个结果，JPA 中返回的结果也是按照集合来表示的，因此也要用 List 等来保存结果。</p>
<p>如果指定了 <code>findFirstByXXX</code> 或者 <code>findOneByXXX</code> 就可以只返回一个结果。</p>
<h2 id="RequestBody-的用法"><a href="#RequestBody-的用法" class="headerlink" title="@RequestBody 的用法"></a>@RequestBody 的用法</h2><p>在 REST 应用中，我们一般接受 JSON 作为传入的参数，使用 @RequestBody 之后就只能接受 JSON 作为参数了，不能接受 form-data 等，而此时的 Content-Type 要为 application/json</p>
<p>这个地方和 Python 的还不一样，Flask-RestFul 不仅仅可以接受 JSON 作为参数，还可以解析出很多其他种类的数据。</p>
<p>如果直接使用相应的 Entity 作为参数，那这样的参数就只能识别 form-data，而其他的都不能识别了。</p>
<p>参考教程：<a href="http://blog.csdn.net/rickyit/article/details/70242218" target="_blank" rel="external">http://blog.csdn.net/rickyit/article/details/70242218</a></p>
<h2 id="JPA-使用-DateTime-与-数据库相联系"><a href="#JPA-使用-DateTime-与-数据库相联系" class="headerlink" title="JPA 使用 DateTime 与 数据库相联系"></a>JPA 使用 DateTime 与 数据库相联系</h2><p>在 Java 中直接使用 Date 来新建一个实时间的变量，然后在数据库里面对应的就是 DateTime 类型的了。</p>
<p>其中数据库时间戳类型要根据 @Temporal 注解来指定，相应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Column(name=&quot;DATE_CREATED&quot;)</div><div class="line">@Temporal(TemporalType.TIMESTAMP)</div><div class="line">private java.util.Date dateCreated;</div></pre></td></tr></table></figure>
<p>参考教程：<a href="https://stackoverflow.com/questions/9409342/handle-datetime-in-jpa2" target="_blank" rel="external">https://stackoverflow.com/questions/9409342/handle-datetime-in-jpa2</a></p>
<h2 id="JPA-中的一对多关系"><a href="#JPA-中的一对多关系" class="headerlink" title="JPA 中的一对多关系"></a>JPA 中的一对多关系</h2><p>使用 @OneToMany 以及 @ManyToOne 注解来定义，详细教程看<a href="http://www.cnblogs.com/luxh/archive/2012/05/27/2520322.html" target="_blank" rel="external">这个</a>和<a href="http://www.cnblogs.com/luxh/archive/2012/05/27/2520501.html" target="_blank" rel="external">这个</a>，其中双向映射是可以从任意一个对象引用另一个对象，而单向则是只有一边才可以</p>
<h2 id="JPA-设置默认时间"><a href="#JPA-设置默认时间" class="headerlink" title="JPA 设置默认时间"></a>JPA 设置默认时间</h2><p>每次插入数据时候生成的时间用 @CreationTimestamp 来表示，每次更新数据生成的时间用 @UpdateTimestamp 来表示</p>
<p>参考教程：<a href="http://blog.csdn.net/sushengmiyan/article/details/50360451" target="_blank" rel="external">http://blog.csdn.net/sushengmiyan/article/details/50360451</a></p>
<h2 id="fastjson-使用"><a href="#fastjson-使用" class="headerlink" title="fastjson 使用"></a>fastjson 使用</h2><p>fastjson 是阿里所编写的 Java 处理 JSON 的模块，据说有超高的速度。</p>
<p>Maven 依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.2.41&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>把 JSON 字符串解析为 JSON 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSONObject jsonResult = JSONObject.parseObject(strResult);</div></pre></td></tr></table></figure>
<p>把 JSON 字符串解析为 JSON 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSONArray jsonArray = JSONObject.parseArray(strResult)</div></pre></td></tr></table></figure>
<p>把 Map 转换为 JSON 字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map param&lt;String, Object&gt; = ...;</div><div class="line">String JSONString = JSON.toJSONString(param);</div></pre></td></tr></table></figure>
<h2 id="HTTPClient-发送-HTTP-请求"><a href="#HTTPClient-发送-HTTP-请求" class="headerlink" title="HTTPClient 发送 HTTP 请求"></a>HTTPClient 发送 HTTP 请求</h2><h3 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="Get-请求"><a href="#Get-请求" class="headerlink" title="Get 请求"></a>Get 请求</h3><p>建立 HTTP 客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CloseableHttpClient client = HttpClients.createDefault();</div></pre></td></tr></table></figure>
<p>建立 Get 请求:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpGet getRequest = new HttpGet(url);</div></pre></td></tr></table></figure>
<p>发送 Get 请求并且保存返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpResponse response = client.execute(getRequest);</div></pre></td></tr></table></figure>
<p>获取状态码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.getStatusLine().getStatusCode()</div></pre></td></tr></table></figure>
<h3 id="Post-请求"><a href="#Post-请求" class="headerlink" title="Post 请求"></a>Post 请求</h3><p>建立客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CloseableHttpClient client = HttpClients.createDefault();</div></pre></td></tr></table></figure>
<p>建立 Post 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpPost postRequest = new HttpPost(url);</div></pre></td></tr></table></figure>
<p>构建 Post JSON 请求体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Object&gt; param = new LinkedHashMap&lt;String, Object&gt;();</div><div class="line">param.put(&quot;appid&quot;, &quot;wxgegfegffe&quot;);</div></pre></td></tr></table></figure>
<p>把 Map 转换为 JSON 字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String JSONString = JSON.toJSONString(param);</div></pre></td></tr></table></figure>
<p>设置实体编码，防止中文乱码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringEntity entity = new StringEntity(JSONString, &quot;utf-8&quot;);</div></pre></td></tr></table></figure>
<p>设置 HTTP 中的编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">entity.setContentEncoding(&quot;UTF-8&quot;);</div><div class="line">entity.setContentType(&quot;application/json&quot;);</div></pre></td></tr></table></figure>
<p>把实体包含到 Post 请求中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">postRequest.setEntity(entity);</div></pre></td></tr></table></figure>
<p>发送 HTTP 请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HttpResponse response = client.execute(postRequest);</div></pre></td></tr></table></figure></p>
<h2 id="构建-token"><a href="#构建-token" class="headerlink" title="构建 token"></a>构建 token</h2><h3 id="Maven-依赖-1"><a href="#Maven-依赖-1" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.nimbusds&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;nimbus-jose-jwt&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="生成-token"><a href="#生成-token" class="headerlink" title="生成 token"></a>生成 token</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// Generate random 256-bit (32-byte) shared secret</div><div class="line">SecureRandom random = new SecureRandom();</div><div class="line">byte[] sharedSecret = new byte[32];</div><div class="line">random.nextBytes(sharedSecret);</div><div class="line"></div><div class="line">// Create HMAC signer</div><div class="line">// 需要接受一个 256-bit 的内容作为参数</div><div class="line">JWSSigner signer = new MACSigner(sharedSecret);</div><div class="line"></div><div class="line">// Prepare JWT with claims set</div><div class="line">// 也就是封装进去的一些信息</div><div class="line">JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()</div><div class="line">    .subject(&quot;alice&quot;)</div><div class="line">    .issuer(&quot;https://c2id.com&quot;)</div><div class="line">    .expirationTime(new Date(new Date().getTime() + 60 * 1000))</div><div class="line">    .build();</div><div class="line"></div><div class="line">// 使用 HAMC 来保护这个 claimSet</div><div class="line">// HAMC 是 hash-based message authentication code</div><div class="line">SignedJWT signedJWT = new SignedJWT(new JWSHeader(JWSAlgorithm.HS256), claimsSet);</div><div class="line"></div><div class="line">// Apply the HMAC protection</div><div class="line">signedJWT.sign(signer);</div><div class="line"></div><div class="line">// Serialize to compact form, produces something like</div><div class="line">// eyJhbGciOiJIUzI1NiJ9.SGVsbG8sIHdvcmxkIQ.onO9Ihudz3WkiauDO2Uhyuz0Y18UASXlSc1eS0NkWyA</div><div class="line">// 这就是生成的 token</div><div class="line">String token = signedJWT.serialize();</div></pre></td></tr></table></figure>
<h3 id="验证-token"><a href="#验证-token" class="headerlink" title="验证 token"></a>验证 token</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// On the consumer side, parse the JWS and verify its HMAC</div><div class="line">signedJWT = SignedJWT.parse(token);</div><div class="line"></div><div class="line">// 通过这个共享密码来检测</div><div class="line">JWSVerifier verifier = new MACVerifier(sharedSecret);</div><div class="line"></div><div class="line">// assert 是 Junit 中的方法</div><div class="line">// 如果共享密码是正确的那么这个结果就为真</div><div class="line">assertTrue(signedJWT.verify(verifier));</div><div class="line"></div><div class="line">// Retrieve / verify the JWT claims according to the app requirements</div><div class="line">// 和 Python 相应的模块不同，这里要手动进行相应的检验</div><div class="line">assertEquals(&quot;alice&quot;, signedJWT.getJWTClaimsSet().getSubject());</div><div class="line">assertEquals(&quot;https://c2id.com&quot;, signedJWT.getJWTClaimsSet().getIssuer());</div><div class="line">assertTrue(new Date().before(signedJWT.getJWTClaimsSet().getExpirationTime()));</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Collection、Map、Set-与-List&quot;&gt;&lt;a href=&quot;#Collection、Map、Set-与-List&quot; class=&quot;headerlink&quot; title=&quot;Collection、Map、Set 与 List&quot;&gt;&lt;/a&gt;Collection、
    
    </summary>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/categories/Web/"/>
    
    
      <category term="Java" scheme="https://blog.patrickcty.cc/tags/Java/"/>
    
      <category term="Spring Boot" scheme="https://blog.patrickcty.cc/tags/Spring-Boot/"/>
    
      <category term="Hibernate" scheme="https://blog.patrickcty.cc/tags/Hibernate/"/>
    
      <category term="REST" scheme="https://blog.patrickcty.cc/tags/REST/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>GoNetwork 学习</title>
    <link href="https://blog.patrickcty.cc/2018/01/03/GoNetwork%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.patrickcty.cc/2018/01/03/GoNetwork学习/</id>
    <published>2018-01-03T08:50:37.000Z</published>
    <updated>2018-01-03T08:51:00.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="off-chain-state-channel-与闪电网络"><a href="#off-chain-state-channel-与闪电网络" class="headerlink" title="off-chain state channel 与闪电网络"></a>off-chain state channel 与闪电网络</h2><p>off-chain state channel 是一种区块链上的解决方案，目的是为了解决区块链的扩展性、高延迟。交易费用问题，它通过在用户之间建立通道进行多次交易，最终的结果再放到链上。</p>
<p>雷电（Radien）网络和闪电（lightening）网络都是状态通道的实现方法，不过前者是基于以太坊，后者是基于比特币。</p>
<p>在状态通道中转移的相当于是支票，如果要兑换支票的话还是要去银行（区块链），但是兑换的时候状态通道就会关闭，而理论上状态通道开得越久越好。创建状态通道需要先在主链上初始化一个固定的金额，之后就是通道中对这个金额的分配了。</p>
<p>生命周期：</p>
<ol>
<li>由两个或两个以上的参与者公开的对初始状态达成一致，即一个状态通道开启。（在一笔交易中，涉及到的资金将交给交给第三方委托或者智能合约去临时封存），比如去银行开卡，你是用户，银行是服务，双方确认初始金额是0元无异议后，就开启一个通道。</li>
<li>参与方之间可以更新最近的每笔交易状态，状态本身存储在本地。</li>
<li>当参与方的任何一方将交易状态最终公布，则状态通道关闭。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="http://gocofe.com/2017/06/%E8%B0%88%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93%EF%BC%88state-channels%EF%BC%89/" target="_blank" rel="external">http://gocofe.com/2017/06/%E8%B0%88%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8A%E7%9A%84%E7%8A%B6%E6%80%81%E9%80%9A%E9%81%93%EF%BC%88state-channels%EF%BC%89/</a></li>
<li><a href="http://ethfans.org/posts/raiden-network" target="_blank" rel="external">http://ethfans.org/posts/raiden-network</a></li>
<li><a href="https://raiden.network/faq.html" target="_blank" rel="external">https://raiden.network/faq.html</a></li>
<li><a href="http://www.8btc.com/ln-rn-corda" target="_blank" rel="external">http://www.8btc.com/ln-rn-corda</a></li>
</ul>
<h2 id="GoNetwork-白皮书"><a href="#GoNetwork-白皮书" class="headerlink" title="GoNetwork 白皮书"></a>GoNetwork 白皮书</h2><p>白皮书主要讲述了是其应用与商业计划，其中是基于 state channel 来实现的 scalability，mobile 部分体现在他们部署他们的解决方案到移动的游戏应用中（作为一种支付方式）</p>
<p>自己的思考：</p>
<p>GoNetwork 和雷电网络与闪电网络类似，都是基于状态通道，这的确是一种不用改变区块链本身存储结构而提高区块链扩展性的好方法，同时也加快了处理的速度，而安全性也能通过签名来实现；而把产品与游戏进行结合也是一种好的推广方法，依赖于移动端也在无形中降低了用户门槛。</p>
<p>不过因为状态通道的建立还是需要在主链上添加 TX，因此当真的突然产生了大量的通道可能还是会造成整个网络的拥堵，不过如果这种情况出现的概率不高的话那么不处理也不会有太大的影响。</p>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h3 id="The-Quest-for-Scalable-Blockchain-Fabric-Proof-of-Work-vs-BFT-Replication"><a href="#The-Quest-for-Scalable-Blockchain-Fabric-Proof-of-Work-vs-BFT-Replication" class="headerlink" title="The Quest for Scalable Blockchain Fabric: Proof-of-Work vs. BFT Replication"></a>The Quest for Scalable Blockchain Fabric: Proof-of-Work vs. BFT Replication</h3><ol>
<li>the GHOST (Greedy Heaviest-Observed Sub-Tree) rule：产生了 fork 之后通过权衡子树来解决，而不是选择最长的区块。<br>这个方法通过提高区块链性能来增加可扩展性但不影响存储</li>
<li>BlockChain-NG：挖出矿的成为 leader，leader 可以添加 microblock（通过时间戳来判断有效性）到链上，这些链不受 PoW 挖掘的限制，而只是被拼凑在一起。<br>microblock 提高了吞吐量并且降低了延迟，也同样不减少存储</li>
<li>加上支链成为有向无环图<br>这个方法提高了并性能力从而提高了处理速度，同样不减少存储</li>
</ol>
<h3 id="Bitcoin-NG-A-Scalable-Blockchain-Protocol"><a href="#Bitcoin-NG-A-Scalable-Blockchain-Protocol" class="headerlink" title="Bitcoin-NG: A Scalable Blockchain Protocol"></a>Bitcoin-NG: A Scalable Blockchain Protocol</h3><p>即为上面所提到的</p>
<h3 id="The-Bitcoin-Lightning-Network-Scalable-Off-Chain-Instant-Payments"><a href="#The-Bitcoin-Lightning-Network-Scalable-Off-Chain-Instant-Payments" class="headerlink" title="The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments"></a>The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments</h3><p>比特币的闪电网络，使用了状态通道来提高可扩展性，这个方法也减小了区块链上的存储</p>
<h3 id="On-Scaling-Decentralized-Blockchains"><a href="#On-Scaling-Decentralized-Blockchains" class="headerlink" title="On Scaling Decentralized Blockchains"></a>On Scaling Decentralized Blockchains</h3><p>块大小和时间间隔的重新参数化来解决可扩展性问题，这个方法不影响存储</p>
<h3 id="Notes-on-Scalable-Blockchain-Protocols"><a href="#Notes-on-Scalable-Blockchain-Protocols" class="headerlink" title="Notes on Scalable Blockchain Protocols"></a>Notes on Scalable Blockchain Protocols</h3><p>通过“采样和回退”游戏实现可伸缩的区块链共识：将交易拆分成影响区块链状态的小部分的 collations，并要求为了使交易的 collation 有效，必须通过从大型验证池随机获取的固定大小的样本的验证。</p>
<p>这个方法不影响存储，但是提高了速度和可扩展性</p>
<h3 id="When-Mobile-Blockchain-Meets-Edge-Computing-Challenges-and-Applications"><a href="#When-Mobile-Blockchain-Meets-Edge-Computing-Challenges-and-Applications" class="headerlink" title="When Mobile Blockchain Meets Edge Computing: Challenges and Applications"></a>When Mobile Blockchain Meets Edge Computing: Challenges and Applications</h3><p>通过使用边缘计算来将区块链运用于移动端，没有提高区块链的可扩展性也没有减少存储</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;off-chain-state-channel-与闪电网络&quot;&gt;&lt;a href=&quot;#off-chain-state-channel-与闪电网络&quot; class=&quot;headerlink&quot; title=&quot;off-chain state channel 与闪电网络&quot;&gt;&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Java 连接 SQL Server</title>
    <link href="https://blog.patrickcty.cc/2018/01/03/%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5SQLServer/"/>
    <id>https://blog.patrickcty.cc/2018/01/03/使用Java连接SQLServer/</id>
    <published>2018-01-03T08:48:37.000Z</published>
    <updated>2018-01-03T08:49:39.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载配置-JDBC-驱动"><a href="#下载配置-JDBC-驱动" class="headerlink" title="下载配置 JDBC 驱动"></a>下载配置 JDBC 驱动</h2><p>在 MS 官网下载 JDBC 驱动，链接<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=21599" target="_blank" rel="external">点这里</a>。</p>
<p>Windows 版下载 exe 包，运行完成解压。然后把 Microsoft SQL Server JDBC Driver 3.0\sqljdbc_3.0\chs\auth\x64\sqljdbc_auth.dll文件 复制到C:\Windows\SysWOW64目录下。（64bit系统）</p>
<p>将 Microsoft SQL Server JDBC Driver 3.0\sqljdbc_3.0\chs\sqljdbc4.jar 包导入到项目中。我是使用 IntelliJ，参考<a href="http://zyjustin9.iteye.com/blog/2172445" target="_blank" rel="external">这个教程</a>。</p>
<h2 id="使用-Java-连接"><a href="#使用-Java-连接" class="headerlink" title="使用 Java 连接"></a>使用 Java 连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">import java.sql.*;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Connection conn = null;  // 存储连接</div><div class="line">        Statement stmt = null;  // SQL 语句相关</div><div class="line">        ResultSet rs = null;  // 执行结果，只有查询语句才有结果</div><div class="line">        // 数据库 url，用来连接 SQL Server</div><div class="line">        // 注意这里不能使用 Windows 验证，因此要自己创建 login</div><div class="line">        String url = &quot;jdbc:sqlserver://localhost:1433;&quot; +</div><div class="line">                &quot;databaseName=学生-课程;user=patrickcty;password=patrickcty&quot;;</div><div class="line">        try &#123;</div><div class="line">            // 导入驱动</div><div class="line">            Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;);</div><div class="line">            conn = DriverManager.getConnection(url);  // 建立连接</div><div class="line"></div><div class="line">            // 连接检测</div><div class="line">            if (conn != null) &#123;</div><div class="line">                System.out.println(&quot;Success connected!&quot;);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                System.out.println(&quot;Not connected!&quot;);</div><div class="line">            &#125;</div><div class="line">            // 创建语句对象</div><div class="line">            stmt = conn.createStatement();</div><div class="line">            String sql = &quot;select * from student&quot;;</div><div class="line">            // 查询语句用这个方法</div><div class="line">            // 结果保存在 rs 中</div><div class="line">            rs = stmt.executeQuery(sql);</div><div class="line">            while (rs.next()) &#123;</div><div class="line">                System.out.println(&quot;学号：&quot; + rs.getString(1) + &quot;姓名：&quot; + rs.getString(2));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 插删改用这个方法</div><div class="line">            sql = &quot;insert into student values (&apos;2015000021&apos;, &apos;开普勒&apos;, &apos;男&apos;, 25, &apos;物理系&apos;)&quot;;</div><div class="line">            stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">            sql = &quot;update student set sdept = &apos;文学系&apos; where sname = &apos;卡莲&apos;&quot;;</div><div class="line">            stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">            sql = &quot;delete from student where sname = &apos;开普勒&apos;&quot;;</div><div class="line">            stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">            sql = &quot;select * from student&quot;;</div><div class="line">            rs = stmt.executeQuery(sql);</div><div class="line">            while (rs.next()) &#123;</div><div class="line">                System.out.println(&quot;学号：&quot; + rs.getString(1) + &quot;姓名：&quot; + rs.getString(2));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sql = &quot;create table test (id int)&quot;;</div><div class="line">            stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">            sql = &quot;select * from sysobjects where xtype=&apos;U&apos;&quot;;</div><div class="line">            rs = stmt.executeQuery(sql);</div><div class="line">            while (rs.next()) &#123;</div><div class="line">                System.out.println(&quot;表名：&quot; + rs.getString(1));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            sql = &quot;drop table test&quot;;</div><div class="line">            stmt.executeUpdate(sql);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        catch (Exception ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        // 关闭各种连接</div><div class="line">        finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (rs != null) &#123;</div><div class="line">                    rs.close();</div><div class="line">                &#125;</div><div class="line">                if (stmt != null) &#123;</div><div class="line">                    stmt.close();</div><div class="line">                &#125;</div><div class="line">                if (conn != null) &#123;</div><div class="line">                    conn.close();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            catch (Exception ex) &#123;</div><div class="line">                ex.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li><p>查询的时候报错“sqlserver 服务器主体无法在当前安全上下文下访问数据库”</p>
<blockquote>
<p>问题在于这个账号没有要查询的表的权限……想当然地一维这个账号有这个权限……</p>
</blockquote>
</li>
<li><p>打开 SQL Server Browser 遇到的各种问题</p>
<blockquote>
<p>为什么要打开 SQL Server Browser 呢？因为我已开始想用 IntelliJ 中的数据库工具来连接 SQL Server，而这个工具需要使用这个服务，但是按照<a href="https://blog.jetbrains.com/datagrip/2016/06/21/connecting-datagrip-to-ms-sql-server/" target="_blank" rel="external">教程</a>来在打开服务的时候无法执行，最后参照<a href="http://blog.csdn.net/u012586848/article/details/46860839" target="_blank" rel="external">这个教程</a>打开了这个服务。结果最后才发现已经有了 SSMS 根本没必要再多此一举做这个工作……所以头脑一定要冷静，不然很容易就做了无用功……<br>然后 SQL Server Browser 其实是用在一个物理服务器上有多个 SQL Server 实例的时候，这个服务确保客户端能访问到正确的实例。</p>
</blockquote>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/freeabyss/archive/2013/04/15/3187065.html" target="_blank" rel="external">http://www.cnblogs.com/freeabyss/archive/2013/04/15/3187065.html</a></li>
<li><a href="http://www.cnblogs.com/chenxizhang/archive/2009/06/30/1514202.html" target="_blank" rel="external">http://www.cnblogs.com/chenxizhang/archive/2009/06/30/1514202.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载配置-JDBC-驱动&quot;&gt;&lt;a href=&quot;#下载配置-JDBC-驱动&quot; class=&quot;headerlink&quot; title=&quot;下载配置 JDBC 驱动&quot;&gt;&lt;/a&gt;下载配置 JDBC 驱动&lt;/h2&gt;&lt;p&gt;在 MS 官网下载 JDBC 驱动，链接&lt;a href=&quot;h
    
    </summary>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://blog.patrickcty.cc/tags/Java/"/>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="SQL Server" scheme="https://blog.patrickcty.cc/tags/SQL-Server/"/>
    
  </entry>
  
  <entry>
    <title>首次接触智能合约遇到的坑</title>
    <link href="https://blog.patrickcty.cc/2017/12/03/%E9%A6%96%E6%AC%A1%E6%8E%A5%E8%A7%A6%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2017/12/03/首次接触智能合约遇到的坑/</id>
    <published>2017-12-03T03:26:06.000Z</published>
    <updated>2017-12-03T03:29:31.421Z</updated>
    
    <content type="html"><![CDATA[<p>在很多的教程中，都是使用如下方法来编译 sol 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contract = eth.compile.solidity(contractSource).test</div></pre></td></tr></table></figure>
<p>但这样会报错：</p>
<blockquote>
<p>Error: The method eth_getCompilers does not exist/is not available</p>
</blockquote>
<p>原因在于在最新的 API 中这个方法已经被抛弃了，因此我们只能手动编译代码再创建一个合约类了。</p>
<p>编译的方法可以直接用 solc 命令来编译，不过直接在 <a href="https://ethereum.github.io/browser-solidity/" target="_blank" rel="external">remix</a>——可以看做一个在线的 Solidity IDE 中编译会比较方便。</p>
<p>编译之后记录下 abi 以及编译后的二进制代码，然后使用下面语句初始化智能合约类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yourContract = web3.eth.contract(your_abi)</div></pre></td></tr></table></figure>
<p>再用智能合约类来创建一个智能合约的实例并且部署到区块链上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var ss = browser_ballot_sol_smartsponsorContract.new(</div><div class="line">   _benefactor,  // 接受钱的人</div><div class="line">   &#123;</div><div class="line">     from: therunner,  // 智能合约发起者 </div><div class="line">     data: theBinaryCode</div><div class="line">     gas: &apos;4700000&apos;  // 需要的手续费</div><div class="line">   &#125;, function (e, contract)&#123;</div><div class="line">    console.log(e, contract);</div><div class="line">    if (typeof contract.address !== &apos;undefined&apos;) &#123;</div><div class="line">         console.log(&apos;Contract mined! address: &apos; + contract.address + &apos; transactionHash: &apos; + contract.transactionHash);</div><div class="line">    &#125;</div><div class="line"> &#125;)</div></pre></td></tr></table></figure>
<p>之后就只需要使用 <code>loadScript</code> 来加载出合约了。</p>
<p>注意：当合约已经被部署到区块链上就不能再修改了，如果要再次访问就要通过 abi 与 address 了，如果不记得这些的话就无法再次访问到合约了。</p>
<h2 id="无法正常连接"><a href="#无法正常连接" class="headerlink" title="无法正常连接"></a>无法正常连接</h2><p><a href="http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum" target="_blank" rel="external">在之前的教程</a>中我们要使用 <code>geth attach</code> 命令来连接到相应的网络中，但是直接使用这个命令的话会提示无法找到 ipc 文件。</p>
<p>报错的原因在于直接使用这条命令连接的默认的公有链，但是我们想连接的是自己定义的私有链，因此我们要用私有链接的 ipc 来进行连接。</p>
<p>首先要启动我们的私有连，在启动之后会有如下的提示信息：</p>
<blockquote>
<p>IPC endpoint opened: /Users/patrick/Music/BlockChain/data/geth.ipc<br>Welcome to the Geth JavaScript console!</p>
<p>instance: Geth/v1.7.2-stable-1db4ecdc/darwin-amd64/go1.9<br>coinbase: 0xea21220a7ab78b50107734d7a4a6ca19cc39f595<br>at block: 139 (Fri, 01 Dec 2017 23:55:34 CST)<br> datadir: /Users/patrick/Music/BlockChain/data<br> modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</p>
</blockquote>
<p>这里第一行的 ipc 就是我们所需要的私有链的地址，然后使用如下命令就可以连接上私有链了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; geth attach ipc:/the/path/of/the/ipc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多的教程中，都是使用如下方法来编译 sol 代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术-智能合约-以太坊（译文修改版）</title>
    <link href="https://blog.patrickcty.cc/2017/12/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%88%E8%AF%91%E6%96%87%E4%BF%AE%E6%94%B9%E7%89%88%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/12/03/区块链技术-智能合约-以太坊（译文修改版）/</id>
    <published>2017-12-03T03:24:20.000Z</published>
    <updated>2017-12-03T03:25:16.397Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅仅是出于学习的目的，对 King Wang 的译文中的代码部分根据当前版本的工具进行了更新。</p>
<hr>
<p>本文征得IBM的Glynn Bird同意翻译发表。虽然文章没有很深的理论，但是它用简洁的语言描述了区块链技术，智能合约，以及以太坊。文章用了一个可以运行的慈善募捐实例，把以太坊最核心的功能做了演示。</p>
<hr>
<p>区块链(BlockChain)技术吸引了大量的关注，原因不仅是它作为账本来纪录交易，成为加密货币(例如比特币)的引擎；更重要的是，它可以封装代码和数据，成为“智能合约”(Smart Contract)。本文介绍开源区块链技术的一种：以太坊(Ethereum), 并且以慈善募捐为例构建一个智能合约，来演示这种技术的强大之处。</p>
<h2 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h2><p>区块链是一种数据结构，把数据按时间顺序存储在可以无限伸长的链表中，就像一个账本。区块链数据结构通过分布式，无中心“主”节点，点对点的计算机网络来维护。链表中的每个区块包含一定数量的交易，交易代表数据库状态的改变，例如，钱从一个帐号转到另一个。交易由网络中的多个节点验证，并且最终存储在区块链的区块里面。每个区块包含一个签名哈希(Signed Hash)，包含的是链表中前一个区块的内容。遍历整个区块链可以验证：某个区块的哈希确实是存储在链表中后一个区块里。区块链用图来表示是这样子的：</p>
<p>The Genesis Block是最原始的区块。H()是哈希。Transaction是交易。Time是时间轴，从原始区块链到无限。</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/56f449a7d8e9486784757e9ddc7294d6.png" alt="区块链结构"></p>
<p>区块链包含一系列价值的转移，从一个地址转到另一个。一个地址代表系统中唯一的一个帐号。地址实际上是一个公钥，它的对应私钥属于创建账号的那个用户。没有用账户的私钥做数字签名，价值就不能从那个账户中转移。</p>
<p>在加密保护交易的同时，区块链还提供数据库状态的分布共识。它保证价值转移要么发生一次，要么不发生。应用开发人员可以放心：因为数据一旦存储，就不能修改，可以信赖。区块链网络抽取一个计算机节点，在区块链中产生下一个区块，这个节点要花费大量的算力解决一个数学任务，这个节点是事先未知的。这个节点找到了问题的解答，可以命名下一个区块并发布，网络中的其它节点验证这个发布的区块。由于证明了工作量(Proof of Work)， 赢得发布的节点得到两种奖励：获得新铸成的加密货币，以及从创建交易的一方收取费用。这个过程称为“挖矿”，它的目的是：</p>
<ol>
<li>铸成新的加密货币，而产生货币的速率是受严格控制的</li>
<li>奖励“矿工”，“矿工”验证了交易以及在网络中达成共识</li>
</ol>
<p>实践中，有非常快的特殊硬件，挖矿就有优势，所以就有了“军备竞赛”：矿工们采用越来越多的硬件，来维持同样的获取货币的速率。</p>
<p>比特币是最有名的区块链的实用例子。比特币是可以交换真实货币的加密货币。它可以通过区块链交易，在比特币账号(钱包)之间转移。本文写作时，比特币点对点网络有7000个节点。</p>
<h2 id="以太坊和智能合约"><a href="#以太坊和智能合约" class="headerlink" title="以太坊和智能合约"></a>以太坊和智能合约</h2><p>区块链吸引应用开发人员的主要的性质有：</p>
<ol>
<li>区块链由别人运营。如果你的应用把数据存在大家都用的区块链，它就不需要为数据提供存储机制。区块链中的节点提供存储有激励：收交易费和有机会铸新币。</li>
<li>区块链提供分布共识机制，你自己做很难。</li>
<li>区块链为用户提供匿名机制。一个账号身份标识(ID)是个公钥,它不一定和人直接相关。</li>
<li>“价值”可以从一个账号转移到另一个，但是费用要小于传统的真实货币转账机制。</li>
<li>如果某个区块链受信赖，那么存储在那个区块链的交易也受信赖。</li>
</ol>
<p>以太坊采用区块链的原理，又增加了在区块链上创建智能合约：智能合约是一种应用，它能保存价值，存储数据，封装代码，执行计算任务。类似比特币，以太坊也含有货币，称为以太(ether)。以太是计算机节点挖出来的，由节点验证交易，交易存储在分布共识的区块链中。以太可以在账户(公钥)之间以及智能合约之间转移。</p>
<p>智能合约允许匿名的几方进入约束协议，每个参与方对交易完全知情。价值可以在账户间转移，或者放在智能合约中的第三方托管（escrow ）。由于合约就是代码，开发者想做什么应用，就能做得出，你的想象力是唯一的限制。</p>
<h2 id="智能合约的例子：智能赞助-smartSponsor"><a href="#智能合约的例子：智能赞助-smartSponsor" class="headerlink" title="智能合约的例子：智能赞助(smartSponsor)"></a>智能合约的例子：智能赞助(smartSponsor)</h2><p>在本文的剩余部分，我们构建一个智能合约，它可以让持有账户的用户做以下互动:</p>
<ol>
<li>一个慈善机构搞募捐，称为受益者thebenefactor</li>
<li>一个赞助实施方为这个慈善机构募捐，称为实施者therunner</li>
<li>想要提供赞助的用户，称为赞助者thesponsor</li>
<li>一个以太坊区块链的挖矿节点，验证交易，称为矿工theminer</li>
</ol>
<p>我们的称为智能赞助(smartSponsor)的合约(contract)是:</p>
<ol>
<li>实施者therunner通过一个募捐活动为慈善机构募捐</li>
<li>构建合约时，实施者therunner命名接受募捐的受益者thebenefactor</li>
<li>实施者therunner然后邀请用户提供赞助，用户调用智能合约的函数(function), 这个函数的功能是从赞助者thesponsor的账号转移以太到合约(contract)中，这些以太沉淀在合约中，直到有回调发生</li>
<li>在合约的整个生命周期，各方都可以看到谁是受益者thebenefactor，募到了多少以太，从谁哪儿募到(当然赞助者thesponsor可以匿名)</li>
</ol>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/eb0bdd5098014980a8bcf3c24cc3ba94.png" alt="合约模型"></p>
<p>合约定了以后，两种现象必有其一：</p>
<p>1.募捐照计划实施，实施者指示合约把全部募捐转移给受益者</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/69ad085d0f94498d8d4e70a7be0be2f6.png" alt="合约模型2"></p>
<p>2.因为某种原因募捐实施不了，实施者指示合约把赞助者承诺的募捐退还</p>
<p><img src="http://upyun-assets.ethfans.org/uploads/photo/image/8fb34f670a0447f581c0b675d5651929.png" alt="合约模型3"></p>
<p>以太坊允许智能合约用代码定义，代码使用一种叫Solidity的编程语言。这是一种类似Java的语言。合约就像Java类，区块链交易存储在成员变量中，可以调用合约的方法来查询合约，或者改变合约的状态。由于区块链的拷贝分布在网络中所有的节点，任何人可以查询合约来获取合约中的公有信息。</p>
<p>我们的合约会包含以下方法：</p>
<ol>
<li>smartSponsor –合约的构造器。它初始化合约的状态。合约的构建者命名账户的地址，这个账户会在合约提款时得益。</li>
<li>pledge –可以被任何捐赠以太的赞助者调用。赞助者可以提供支持募捐的信息，但这个不是必需的。</li>
<li>getPot –返回合约中当前的以太总量。</li>
<li>refund –把承诺的募捐退还给赞助者。只有合约的拥有者能够调用这个方法。</li>
<li>drawdown –把合约中的全部募捐转移到受益者账户。同样，只有合约的拥有者能够调用这个方法。</li>
</ol>
<p>我们的想法是合约要有约束：如果赞助者把以太转移到合约，除非整个合约退回，否则赞助者不能取回。如此，所有的数据都公开可取，意思是任何能够访问以太坊的人，通过合约的代码，能够看到谁设置了合约，谁是受益者，谁承诺了哪一笔捐赠。</p>
<p>重要的是，所有改变合约状态的操作(构建，承诺，退还，或者把合约中的全部募捐转移到受益者账户)都需要在区块链中创建交易。这就意味着，交易被“挖矿”和区块被存储以前，数据还没有被存储。有些操作只是读取已经存在的合约状态(getPot或者读取公共成员变量)，这些操作不需要挖矿。这点重要而微妙：写操作很慢(我们必须等到挖矿完成)。或许写操作结果最终进不了区块链(如果你的代码抛出一个异常或者有其他的错误)，需要调用者给矿工干活的激励。这在以太坊术语中称为gas。所有写操作需要支付gas来改变区块链的状态。</p>
<p>我们有幸不需要加入太坊网络和购买以太，就能使用相同的软件，配置一个本地测试区块链，运行一个矿工来产生自己所谓的以太。这样我们不用浪费真的以太，来测试我们的代码。</p>
<h2 id="Solidity-代码"><a href="#Solidity-代码" class="headerlink" title="Solidity 代码"></a>Solidity 代码</h2><p>这里是用Solidity语言写的我们的智能合约的全部代码：（注：这是修改后的代码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line">// Smart contract to allow someone to organise a sponsored event for charity</div><div class="line">// Glynn Bird - 2016</div><div class="line"></div><div class="line">contract smartSponsor &#123;</div><div class="line">  address public owner;</div><div class="line">  address public benefactor;</div><div class="line">  bool public refunded; </div><div class="line">  bool public complete;</div><div class="line">  uint public numPledges;</div><div class="line">  struct Pledge &#123;</div><div class="line">    uint amount;</div><div class="line">    address eth_address;</div><div class="line">    bytes32 message;</div><div class="line">  &#125;</div><div class="line">  mapping(uint =&gt; Pledge) public pledges;</div><div class="line">  </div><div class="line">  // constructor</div><div class="line">  function smartSponsor(address _benefactor) public &#123;</div><div class="line">    owner = msg.sender;</div><div class="line">    numPledges = 0;</div><div class="line">    refunded = false;</div><div class="line">    complete = false;</div><div class="line">    benefactor = _benefactor;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // add a new pledge</div><div class="line">  function pledge(bytes32 _message) public payable &#123;</div><div class="line">    if (msg.value == 0 || complete || refunded) revert();</div><div class="line">    pledges[numPledges] = Pledge(msg.value, msg.sender, _message);</div><div class="line">    numPledges++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getPot() public constant returns (uint) &#123;</div><div class="line">    return this.balance; </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // refund the backers</div><div class="line">  function refund() public &#123;</div><div class="line">    if (msg.sender != owner || complete || refunded) revert();</div><div class="line">    for (uint i = 0; i &lt; numPledges; ++i) &#123;</div><div class="line">      pledges[i].eth_address.transfer(pledges[i].amount);</div><div class="line">    &#125;</div><div class="line">    refunded = true;</div><div class="line">    complete = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // send funds to the contract benefactor</div><div class="line">  function drawdown() public &#123;</div><div class="line">    if (msg.sender != owner || complete || refunded) revert();</div><div class="line">    benefactor.transfer(this.balance);</div><div class="line">    complete = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Pledge结构描述一个捐赠，记录赞助者的账号，赞助值，和一个消息字符串</li>
<li>pledges数组记录一组Pledge</li>
<li>所有contract的成员变量都是公共的，因此它们的getter是自动产生的<br>有些函数调用throw来避免在出错时，数据被存储到区块链<br>请注意，代码没有提及交易，区块，gas，或者区块链以及加密货币的任何术语。代码仅仅存储成员变量的状态。以太坊仅仅创建了必要的交易，提交给网络验证(本例采用了我们的测试网络)，然后存储到区块链。所有复杂的东西，都避免让我们看到。结果我们的代码很少(50行)，又容易理解。</li>
</ul>
<p>这个很重要，因为智能合约就是信赖的共享；合约中的所有参与方应该清楚他们的承諾，募捐去了哪里，谁可以做哪些操作。代码越简单，越容易验证合约是否值得信赖。</p>
<h2 id="运行智能合约"><a href="#运行智能合约" class="headerlink" title="运行智能合约"></a>运行智能合约</h2><p>要运营合约，先要把以太坊跑起来。我的Ubuntu服务器安装指南在<a href="https://github.com/glynnbird/smartsponsor。" target="_blank" rel="external">https://github.com/glynnbird/smartsponsor。</a> 我使用的是IBM的Bluemix虚拟机(译注：这个不是必须的)，再用apt-get加些需要的包。</p>
<p>假定你根据我的安装指南，在你的测试网络创建了4个以太坊账号，以及配置了一个挖矿进程， 我们可以拷贝smartSponsor代码，在以太坊控制台执行（也就是说打开了两个窗口，一个用来挖矿另一个执行导入合约的代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; git clone https://github.com/glynnbird/smartsponsor.git  // 注：代码有修改</div><div class="line">&gt; cd smartsponsor</div><div class="line">&gt; geth attach</div></pre></td></tr></table></figure>
<p>从geth控制台，执行和以太坊API交互的JavaScript命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; loadScript(&quot;./smartsponsor.js&quot;)</div><div class="line">Contract transaction send: TransactionHash: 0xe797ce5c1e5eeaae6e4bd09ad6564f9deba1beeeb7f09b6c16eec728584e370c waiting to be mined...</div><div class="line">true</div><div class="line">&gt; Contract mined! Address: 0x15590c0417f6421fd35e113db0fdb2055df2344b</div><div class="line">[object Object]</div></pre></td></tr></table></figure>
<p>其中 JavaScript 文件修改成了<a href="https://www.zybuluo.com/PatrickCtyyx/note/972386" target="_blank" rel="external">这篇文章</a>的情况。</p>
<p>smartsponsor.js文件创建了一些变量，它们是我们创建的4个以太坊坊账号的地址(theminer, therunner, thebenefactor, thesponsor),这样接下来的代码片段中，谁做了什么，就容易理解了。该文件还包含一系列的指令，用来编译Solidity源码，构建smartSponsor合约，产生therunner合约实例，确保合约的受益者是thebenefactor。</p>
<p>直到交易被挖矿了，合约才变活。这个需要几秒或几分钟，取决于运行计算机的速度。让我们来观察一下合约（合约赋给了变量ss）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; ss</div><div class="line">&#123;</div><div class="line">  address: &quot;0xe021f45922e141f5e17d05a4b2721ec972065960&quot;,</div><div class="line">  transactionHash: &quot;0x77ba5bc77f0a62888c08084a7c00cf00b6cc024f88f988e9daada751788c8693&quot;,</div><div class="line">  allEvents: function(),</div><div class="line">  benefactor: function(),</div><div class="line">  complete: function(),</div><div class="line">  drawdown: function(),</div><div class="line">  getPledge: function(),</div><div class="line">  getPot: function(),</div><div class="line">  numPledges: function(),</div><div class="line">  owner: function(),</div><div class="line">  pledge: function(),</div><div class="line">  refund: function(),</div><div class="line">  refunded: function()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到合约有一个address，意味着它能收发以太值，以及一个transactionHash，用它来找到区块链中的位置。公共的，可对合约调用的函数也列出了。现在让我们调用几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; ss.benefactor()</div><div class="line">&quot;0x63de8807ac0bd63be460be0de250749c4df1dcb0&quot;</div><div class="line">&gt; ss.owner()</div><div class="line">&quot;0x458305055882d53663b41a00eebd0b657469843f&quot;</div><div class="line">&gt; ss.getPot()</div><div class="line">0</div><div class="line">&gt; ss.numPledges()</div><div class="line">0</div><div class="line">&gt; ss.complete()</div><div class="line">False</div></pre></td></tr></table></figure>
<p>我们可以看到合约的拥有者和受益者是不同的账号(分别是therunner和thebenefactor)，合约的状态初始化为没有募捐和赞助。从自己的区块链拷贝做读操作，是免费的，所以我们不需要提供gas。</p>
<p>接下来我们寄给thesponsor账号一些钱，原先账号是没有以太的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(thesponsor,&quot;password&quot;);</div><div class="line">&gt; eth.sendTransaction(&#123;from: theminer, to: thesponsor, value: 100000000000000000&#125;);</div><div class="line">&quot;0xd4fc641311e31abb6546c3503c367c6ac971b0ad9cb4bcd4c56597e3b98d6d7a&quot;</div><div class="line">&gt; eth.getBalance(theminer);</div><div class="line">4.9524805801917e+22</div><div class="line">&gt; eth.getBalance(thesponsor);</div><div class="line">100000000000000000</div></pre></td></tr></table></figure>
<p>接下来认证thesponsor用户，给我们的智能合约赞助一些钱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(thesponsor,&quot;password&quot;);</div><div class="line">true</div><div class="line">&gt; ss.pledge(&quot;Good luck with the run!&quot;, &#123;from: thesponsor, value: 10000000, gas: 3000000&#125;);</div><div class="line">&quot;0xc0880c4151946014389e135bcbefe39fb8f786e9e3e0ce077fa5f967e2a31ab3&quot;</div></pre></td></tr></table></figure>
<p>价值参数是我们希望转移到合约的以太数量。10000000似乎很大，但单位是wei。1个以太有1000000000000000000个wei！</p>
<p>返回值是交易标识。我们必须等到交易存储到区块链，才能看到合约状态改变了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; ss.getPot()</div><div class="line">10000000</div><div class="line">&gt; ss.numPledges()</div><div class="line">1</div><div class="line">&gt; ss.pledges(0)</div><div class="line">[10000000, &quot;0x225905462cf12404757852c01edfd2ec0bf0dbe9&quot;, &quot;0x476f6f64206c75636b2077697468207468652072756e21000000000000000000&quot;]</div></pre></td></tr></table></figure>
<p>调用pledges(0)返回第一个捐赠pledge，包含它的价值，赞助者的地址，和消息(以一串字节表示).我们可以不断地调用pledge函数来增加捐赠，并观察pot变大。在7个赞助者捐赠以后，我们有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; ss.getPot()</div><div class="line">70000000</div></pre></td></tr></table></figure>
<p>请注意，合约得到了赞助者承诺的全部以太数量，但是赞助者的账号被扣除了比承诺稍多一点的价值。为什么？因为调用pledge函数的操作，必须提供gas作为动力。<br>当实施者准备完成合约，只需调用drawdown函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; personal.unlockAccount(therunner,&quot;password&quot;);</div><div class="line">true</div><div class="line">&gt; ss.drawdown(&#123;from: therunner, gas:3000000&#125;);</div><div class="line">&quot;0x082424d8057b8c250f8b86cda05211628bb3bae513ce27bf6194445ae035a3c4&quot;</div></pre></td></tr></table></figure>
<p>合约挖矿完成后，我们应该看到受益者的账号收到了合约的捐赠数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; eth.getBalance(thebenefactor);</div><div class="line">70000000</div><div class="line">&gt; ss.getPot()</div><div class="line">0</div></pre></td></tr></table></figure>
<h3 id="补充：在另一个窗口中打开智能合约："><a href="#补充：在另一个窗口中打开智能合约：" class="headerlink" title="补充：在另一个窗口中打开智能合约："></a>补充：在另一个窗口中打开智能合约：</h3><p>如果想在另一个窗口中打开此智能合约则需要记录下合约的 abi 以及 address:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; abi = your_abi</div><div class="line">&gt; sample = eth.contract(abi)</div><div class="line">&gt; ss2 = sample.at(&quot;your_address&quot;)</div><div class="line">&gt; ss2.getPot</div><div class="line">0</div></pre></td></tr></table></figure>
<p>智能合约在合约里的第三方托管记录多个捐赠，要么转移到受益者，要么退还给赞助者。代码确保只有合约的创建者可以退还捐赠，或者全部转移给受益者，并且防止合约完成后再加捐赠。整个过程中，合约的状态可以被各方查询，这些都包含在50行代码里面！</p>
<p>用geth行命令工具执行的命令实际上是Javascript语句。你用自己的客户端代码同样可以调用远端API,和真实(或测试)网络进行交互。这样，创建基于互联网的智能合约前端就很简单。</p>
<p>你用Mist浏览器可以创建帐户，查看和操作合约，就像一个智能合约的应用商店。Mist设想了很多计划，但目前它是一个相对简单的钱包应用，以及合约浏览器。</p>
<h2 id="区块链仅仅是一个分布式数据库？"><a href="#区块链仅仅是一个分布式数据库？" class="headerlink" title="区块链仅仅是一个分布式数据库？"></a>区块链仅仅是一个分布式数据库？</h2><p>区块链是一种按时间顺序存储数据的账本，它是跨越多个结点的分布式数据库。但和Cloudant分布式数据库的意义不同：它并不是把数据分割成片，使工作量散布，从而每片就能搞定一部分。它的网络中，所有节点必须处理所有的数据变化。还有，挖矿的节点执行工作量证明(proof-of-work)，来证明节点有资格实施所预计的改变，这个造成写数据的过程极度缓慢，以太坊每秒只能处理20-30个交易(不是每个用户20-30个交易，而是全部区块链)。</p>
<p>以太坊不仅是一个数据仓库。它增加了新的功能：在区块链中封装代码和数据。这样参与各方可以确信一个合约能够说到做到。与签过名的纸上合约，律师，公证，银行，保险，清算相比，大有不同。</p>
<h2 id="区块链和智能合约能做什么？"><a href="#区块链和智能合约能做什么？" class="headerlink" title="区块链和智能合约能做什么？"></a>区块链和智能合约能做什么？</h2><p>以太坊只是智能合约平台的一种，用它可以构建基于区块链的应用。最合适的用例有：</p>
<ul>
<li>从一方转移价值到另一方</li>
<li>一方或几方需要匿名</li>
<li>价值必须存储在合约本身，并且存储一段时间</li>
<li>希望避免转移真实货币产生的交易费用 需要建立共识 </li>
<li>希望显示公开性，把状态存储在公共域</li>
<li>需要确保物理或虚拟材料的来源和真实性</li>
</ul>
<p>马上想到的应用有：拍卖，借贷，遗嘱，注册，众筹，股权，和投票。</p>
<p>从金钱和计算角度看，写操作是很贵的，所以智能合约多用在写操作少，但是数据价值高的应用。尽管读操作是免费的，只存在一些简单的查询操作。你可以给存储的数据加索引，但还不像一般的数据库，它不存在查询语言，也不存在抽取或聚合数据的方式。</p>
<p>区块链还有另外一些缺点。所有网络中的参与方要存储所有的区块，数据不是分割成可以分别搞定的片段，所以每个节点必须存储整个数据库，并且处理每一个变化。用工作量证明模型，在网络中分布信赖，是一种聪明的迂回解决方案，但是实际情况下，要用千万个节点消耗能量来证明节点值得信赖。最后一点，以太的价值，就像比特币，买卖受投机影响，使得以太的金融价值不稳定。以太坊在发展规划中有性能提升，可扩展性，替换工作量证明，但是在笔者写此文时，它们还只是愿景。</p>
<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p>中文原文：<a href="http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum" target="_blank" rel="external">http://ethfans.org/posts/block-chain-technology-smart-contracts-and-ethereum</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅仅是出于学习的目的，对 King Wang 的译文中的代码部分根据当前版本的工具进行了更新。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文征得IBM的Glynn Bird同意翻译发表。虽然文章没有很深的理论，但是它用简洁的语言描述了区块链技术，智能合约，以及以太坊。文章用了一个可以运
    
    </summary>
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/categories/BlockChain/"/>
    
    
      <category term="BlockChain" scheme="https://blog.patrickcty.cc/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>Vue与API请求遇到的坑</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/Vue%E4%B8%8EAPI%E8%AF%B7%E6%B1%82%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/Vue与API请求遇到的坑/</id>
    <published>2017-11-07T11:18:51.000Z</published>
    <updated>2017-11-07T11:19:49.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>最近在写比赛项目 TeamSeeker 的代码，后台写得差不多了，于是乎决定写一下网页前端来请求 API，顺便再次测试一下后台的合理性，同时也接触一下一直都想尝试的 Vue。只是没想到居然会遇到这么多坑。</p>
<h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="初始化-Vue-项目"><a href="#初始化-Vue-项目" class="headerlink" title="初始化 Vue 项目"></a>初始化 Vue 项目</h3><p>本来只是准备写单个的 HTML 来组织成前端的，后来想来想去还是跟着教程用 Webpack 来初始化一个比较大的项目。</p>
<p>但是项目是成功初始了，但是在引用第三方的组件的时候，明明已经使用 npm 安装了但是就是引用不了 CSS。</p>
<p>去网上找了一圈发现是没有在项目的配置文件中对这些文件类型进行配置，然而试了半天配置的还是不成功……</p>
<p>最后发现了一个简单的方法，就是在用 npm 安装模块的时候使用 -S 参数，这样就会自动保存在配置中了。这个参数表示保存的意思，等同于 <code>--save</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i materialize-css -S</div></pre></td></tr></table></figure>
<h3 id="发送请求时候的跨域问题"><a href="#发送请求时候的跨域问题" class="headerlink" title="发送请求时候的跨域问题"></a>发送请求时候的跨域问题</h3><p>因为使用的是前后端分离的设计思想，因此难免会产生跨域问题。其实这个问题我之前遇到过，当时是直接在返回的内容中带上 <code>Access-Control-Allow-Origin</code> 这个请求头。</p>
<p>不过坑爹的是，在有的时候，在发送跨域请求之前，浏览器会发送 OPTIONS 请求来检查服务器有没有返回 <code>Access-Control-Allow-Origin</code> 这个请求头从而判断服务器是否支持跨域。于是问题就来了，因为我根本没有定义这个方法，因此也自然不会返回这个请求头了，于是就产生了跨域的问题……</p>
<p>不过这个问题在 Google 上找到了答案，具体原理就是在服务器自定义 Response 类，使得在每次请求后都返回所需要的请求头，这样就可以解决这个问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class MyResponse(Response):</div><div class="line">    def __init__(self, response=None, **kwargs):</div><div class="line">        kwargs[&apos;headers&apos;] = &apos;&apos;</div><div class="line">        headers = kwargs.get(&apos;headers&apos;)</div><div class="line">        # 跨域控制</div><div class="line">        origin = (&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</div><div class="line">        methods = (&apos;Access-Control-Allow-Methods&apos;, &apos;HEAD, OPTIONS, GET, POST, DELETE, PUT&apos;)</div><div class="line">        if headers:</div><div class="line">            headers.add(*origin)</div><div class="line">            headers.add(*methods)</div><div class="line">        else:</div><div class="line">            headers = Headers([origin, methods])</div><div class="line">        kwargs[&apos;headers&apos;] = headers</div><div class="line">        return super().__init__(response, **kwargs)</div></pre></td></tr></table></figure>
<p>然后在 <code>create_app</code> 里面使用这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.response_class = MyResponse</div></pre></td></tr></table></figure>
<p>原文参考<a href="https://blog.zengrong.net/post/2615.html" target="_blank" rel="external">这个博客</a>。</p>
<p>顺便一提，在解决这个问题的时候还出现了一个问题，那就是在请求第二页的时候不管后端前端怎么改都得不到正确的结果，结果找了半天发现是并没有第二页的内容……真的是智障了……</p>
<h3 id="使用-axios-无法将-response-保存下来"><a href="#使用-axios-无法将-response-保存下来" class="headerlink" title="使用 axios 无法将 response 保存下来"></a>使用 axios 无法将 response 保存下来</h3><p>axios 是 Vue 官方推荐的 AJAX 请求发送的模块，一个 GET 请求是这样发送的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">axios.get(&apos;http://example.com/api/index&apos;, &#123;</div><div class="line">    params: &#123;</div><div class="line">      &quot;page&quot;: page</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">    .then(function (response) &#123;</div><div class="line">      console.log(response);</div><div class="line">    &#125;)</div><div class="line">    .catch(function (error) &#123;</div><div class="line">      console.log(error);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>但是我如果想保存 response 对象到 Vue 的一个对象中（需要使用 this） 来访问，如果直接使用 <code>this.$store.dispatch(&#39;getIndex&#39;, response.data);</code> 是不能保存进去的，原因在于 this 在 axios.get() 函数中也起作用，在函数中的作用域就不是 Vue 的对象了，因此我们要在调用函数之前把 this 赋值给另一个变量，然后再用另一个变量来引用 Vue 的对象的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var _self = this;</div><div class="line">axios.get(</div><div class="line">    ...</div><div class="line">    _this.$store.dispatch(&apos;getIndex&apos;, response.data);</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="数据首次加载"><a href="#数据首次加载" class="headerlink" title="数据首次加载"></a>数据首次加载</h3><p>这个到现在还是不是很清楚，先留个坑。</p>
<h3 id="使用-axios-发送-POST-请求遇到的坑"><a href="#使用-axios-发送-POST-请求遇到的坑" class="headerlink" title="使用 axios 发送 POST 请求遇到的坑"></a>使用 axios 发送 POST 请求遇到的坑</h3><p>继使用 axios 发送 GET 请求遇到坑之后，用 POST 请求又踩到了坑，真的是体验极差啊（哭。</p>
<p>这次又是什么问题呢？那就是：</p>
<blockquote>
<p>Request header field Access-Control-Allow-Headers is not allowed by Access-Control-Allow-Headers</p>
</blockquote>
<p>为什么会出现这个问题呢？又是 OPTIONS 这个磨人的小妖精……StackOverflow 上是这样解释的：</p>
<blockquote>
<p>For cross-domain requests, setting the content type to anything other than application/x-www-form-urlencoded, multipart/form-data, or text/plain will trigger the browser to send a preflight OPTIONS request to the server.</p>
</blockquote>
<p>而 axios 发送 POST 请求的时候默认是用 JSON 作为 Content-Type 来发送了，而这正好不是上面的这些，因此就又要提前发送一次 OPTIONS 请求，而正好我又没有对这个处理……</p>
<p>不过这次就不用改服务器的代码了，axios 官方已经给出了解决方法了，那就是把 Content-Type 设置为 <code>application/x-www-form-urlencoded</code>，然后再对 JSON 数据进行处理，具体方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var qs = require(&apos;qs&apos;);</div><div class="line">axios.post(&apos;http://example.com/api/wxlogin&apos;,    </div><div class="line">    qs.stringify(&#123;</div><div class="line">        js_code: &apos;001U3te40K6KSD1Bpaf40DKAe40U3tel&apos;</div><div class="line">    &#125;)</div><div class="line">)</div><div class="line">    .then(function (response) &#123;</div><div class="line">        console.log(response);</div><div class="line">    &#125;)</div><div class="line">    .catch(function (error) &#123;</div><div class="line">        console.log(&apos;aaa&apos;, error);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>当然这个 qs 模块也是要事先安装的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i qs -S</div></pre></td></tr></table></figure>
<h3 id="使用-font-awesome-但是死活引入不了-CSS"><a href="#使用-font-awesome-但是死活引入不了-CSS" class="headerlink" title="使用 font-awesome 但是死活引入不了 CSS"></a>使用 font-awesome 但是死活引入不了 CSS</h3><p>网站当然少不了图标，一个比较简单好用的方法就是使用 font-awesome 提供的图标，平常我都是使用 CDN 来引入的，但是这个项目结构下好像不适合直接引入，而是应该使用 npm 安装模块。</p>
<p>但是安装之后死活找不到安装好的模块，也就无法引入了。于是不得不去安装 vue-awesome，然而这个的图标死活和文字对齐不了……这个简直不能忍啊，最后不得不又得回到 font-awesome。</p>
<p>又找了一圈之后发现是我安装的方法不对，我一开始是使用下面这个来安装的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i fontawesome -S（不要用这个安装！！！）</div></pre></td></tr></table></figure>
<p>确实提示已经安装成功了，但是不能用。我之后又使用了下面这个来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i font-awesome -S</div></pre></td></tr></table></figure>
<p>加了中间这个短横线之后就可以引入了……虽然我发现安装后的提示都是一样的……简直坑爹啊……还是我大 Python 的 pip 要好用……</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这几天真的踩了超多的坑，简单的一个页面结果写了一周才大概完成……中间的心酸真的是只有自己知道了……</p>
<p>最近一段时间也是事情堆起来了……哎只希望下次驾照考试能顺利一点吧……已经成了我心中的梦魇了……真的很害怕很无助……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;最近在写比赛项目 TeamSeeker 的代码，后台写得差不多了，于是乎决定写一下网页前端来请求 API，顺便再次测试一下后
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Vue" scheme="https://blog.patrickcty.cc/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB一些操作</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/MATLAB%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/MATLAB一些操作/</id>
    <published>2017-11-07T11:17:48.000Z</published>
    <updated>2017-11-07T11:18:24.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="syms"><a href="#syms" class="headerlink" title="syms"></a>syms</h2><p>使用 syms 关键字可以定义自变量，这样就可以写出带 x，y，z 等的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">syms x, y;</div><div class="line"></div><div class="line">y = exp(-2 * x);</div></pre></td></tr></table></figure>
<h2 id="prod"><a href="#prod" class="headerlink" title="prod"></a>prod</h2><p>使用 prod 可以实现矩阵中的元素连乘的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = [3 4 5];</div><div class="line">prod(x)</div><div class="line">&gt;&gt; 120</div></pre></td></tr></table></figure>
<h2 id="循环遍历一个向量"><a href="#循环遍历一个向量" class="headerlink" title="循环遍历一个向量"></a>循环遍历一个向量</h2><p>直接把向量赋值给循环变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = [4 5 6]；</div><div class="line"></div><div class="line">for i = a</div><div class="line">    % disp 为输出语句</div><div class="line">    disp(i);</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="subs"><a href="#subs" class="headerlink" title="subs"></a>subs</h2><p>subs 用来替换。</p>
<p>假设 poly 是一个以 x 为自变量的多项式，如果要计算某个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subs(poly, x, 5)</div></pre></td></tr></table></figure>
<h2 id="在向量中增加元素"><a href="#在向量中增加元素" class="headerlink" title="在向量中增加元素"></a>在向量中增加元素</h2><p>假设 event 是一个向量，如果要增加一个 b 向量在尾部，则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event = [event b]</div></pre></td></tr></table></figure>
<h2 id="ezplot"><a href="#ezplot" class="headerlink" title="ezplot"></a>ezplot</h2><p>ezplot 用来画出某个带自变量的表达式的曲线，可以指定自变量的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">% polyresult 为多项式表达式</div><div class="line">ezplot(polyresult, [-1, 1]);</div></pre></td></tr></table></figure>
<h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><p>最基本的画曲线的函数，根据横纵坐标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plot(x0, errevent, &apos;--&apos;, x0, errcheby);</div></pre></td></tr></table></figure>
<h2 id="figure"><a href="#figure" class="headerlink" title="figure"></a>figure</h2><p>新建一张画布，下一个图就会画在这个画布上了。</p>
<h2 id="hold-on-amp-hold-off"><a href="#hold-on-amp-hold-off" class="headerlink" title="hold on &amp; hold off"></a>hold on &amp; hold off</h2><p>用来把多个曲线画在同一个坐标系中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">figure;</div><div class="line">ezplot(polyresult, [-1, 1]);</div><div class="line">hold on;</div><div class="line">syms x0;</div><div class="line">ezplot(exp(-2 * x0), [-1, 1]);</div><div class="line">hold off;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;syms&quot;&gt;&lt;a href=&quot;#syms&quot; class=&quot;headerlink&quot; title=&quot;syms&quot;&gt;&lt;/a&gt;syms&lt;/h2&gt;&lt;p&gt;使用 syms 关键字可以定义自变量，这样就可以写出带 x，y，z 等的表达式。&lt;/p&gt;
&lt;figure class=&quot;hi
    
    </summary>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="MATLAB" scheme="https://blog.patrickcty.cc/tags/MATLAB/"/>
    
      <category term="数值分析" scheme="https://blog.patrickcty.cc/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据库ROLLUP与CUBE</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93ROLLUP%E4%B8%8ECUBE/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/数据库ROLLUP与CUBE/</id>
    <published>2017-11-07T11:16:27.000Z</published>
    <updated>2017-11-07T11:17:14.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>ROLLUP 和 CUBE 都是用来在差查询结果中生成合计的项目。</p>
<p>这两个关键字需要和 GROUP BY 来一起使用，需要注意的是 GROUP BY 关键字后面可以跟多个列名，这多个列名之间的顺序和输出的顺序是相关的。</p>
<p>ROLLUP 和 CUBE 的操作都要依赖 GROUP BY。</p>
<h2 id="GROUPING"><a href="#GROUPING" class="headerlink" title="GROUPING"></a>GROUPING</h2><p>GROUPING 用来区分是本来内容就是 null 还是是因为 ROLLUP 和 CUBE 而产生的 null 值，如果是后者那么 GROUPING(列名) 返回的结果就是 1，否则则是零。</p>
<p>ROLLUP 统计的时候会默认生成 null，这时候就需要自己填入统计的结果了。</p>
<h2 id="ROLLUP"><a href="#ROLLUP" class="headerlink" title="ROLLUP"></a>ROLLUP</h2><p>ROLLUP 产生的合计项目和 GROUP BY 中的多个列名的顺序有关。</p>
<p>ROLLUP 会根据 GROUP BY 的第一个列来进行分组并且输出汇总的内容。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with rollup;</div></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Ann Arbor	MI</div><div class="line">Ann Arbor	ALL</div><div class="line">……省略若干行</div><div class="line">Vacaville	CA</div><div class="line">Vacaville	ALL</div><div class="line">Walnut Creek	CA</div><div class="line">Walnut Creek	ALL</div><div class="line">ALL	ALL</div></pre></td></tr></table></figure></p>
<p>在这里是对应的每个不同的州进行分组，然后对每个组进行汇总，最终对所有的州再进行一次汇总。</p>
<h2 id="CUBE"><a href="#CUBE" class="headerlink" title="CUBE"></a>CUBE</h2><p>CUBE 产生的合计项目和 GROUP BY 中的多个列名的顺序在某种程度上可以说是无关。</p>
<p>CUBE 产生的结果不仅会产生 ROLLUP 的结果，还会产生 ROLLUP 中没出现的另一种顺序的结果。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with cube;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">Berkeley	CA</div><div class="line">Covelo	CA</div><div class="line">Menlo Park	CA</div><div class="line">Oakland	CA</div><div class="line">Palo Alto	CA</div><div class="line">San Francisco	CA</div><div class="line">San Jose	CA</div><div class="line">Vacaville	CA</div><div class="line">Walnut Creek	CA</div><div class="line">ALL	CA</div><div class="line">Gary	IN</div><div class="line">ALL	IN</div><div class="line">Lawrence	KS</div><div class="line">ALL	KS</div><div class="line">Rockville	MD</div><div class="line">ALL	MD</div><div class="line">Ann Arbor	MI</div><div class="line">ALL	MI</div><div class="line">Corvallis	OR</div><div class="line">ALL	OR</div><div class="line">Nashville	TN</div><div class="line">ALL	TN</div><div class="line">Salt Lake City	UT</div><div class="line">ALL	UT</div><div class="line">ALL	ALL</div><div class="line">Ann Arbor	ALL</div><div class="line">Berkeley	ALL</div><div class="line">Corvallis	ALL</div><div class="line">Covelo	ALL</div><div class="line">Gary	ALL</div><div class="line">Lawrence	ALL</div><div class="line">Menlo Park	ALL</div><div class="line">Nashville	ALL</div><div class="line">Oakland	ALL</div><div class="line">Palo Alto	ALL</div><div class="line">Rockville	ALL</div><div class="line">Salt Lake City	ALL</div><div class="line">San Francisco	ALL</div><div class="line">San Jose	ALL</div><div class="line">Vacaville	ALL</div><div class="line">Walnut Creek	ALL</div></pre></td></tr></table></figure></p>
<p>如果忽视输出数据的顺序，那么这个结果相当于两个 ROLLUP 的结果作 UNION<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by city, state with rollup</div><div class="line">union</div><div class="line">select case when grouping(city) = 1 then &apos;ALL&apos;</div><div class="line">	else city </div><div class="line">	end as city,</div><div class="line">	case when grouping(state) = 1 then &apos;ALL&apos;</div><div class="line">	else state</div><div class="line">	end as state</div><div class="line">from pubs.dbo.authors</div><div class="line">group by state, city with rollup;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;ROLLUP 和 CUBE 都是用来在差查询结果中生成合计的项目。&lt;/p&gt;
&lt;p&gt;这两个关键字需要和 GROUP BY 来一起使用，需要注意
    
    </summary>
    
      <category term="课程" scheme="https://blog.patrickcty.cc/categories/%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="SQL Server" scheme="https://blog.patrickcty.cc/tags/SQL-Server/"/>
    
      <category term="数据库" scheme="https://blog.patrickcty.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序学习</title>
    <link href="https://blog.patrickcty.cc/2017/11/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.patrickcty.cc/2017/11/07/微信小程序学习/</id>
    <published>2017-11-07T11:14:01.000Z</published>
    <updated>2017-11-07T11:14:53.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>全局配置文件为 app.json，在项目的根目录中。</p>
<p>配置详情参考<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html" target="_blank" rel="external">官方文档</a>。</p>
<p>要注意的是主体页面的颜色要和微信的颜色保持一致为白色，但是状态栏以及标签页这些地方可以是自己喜欢的颜色。</p>
<h2 id="登录状态的维护"><a href="#登录状态的维护" class="headerlink" title="登录状态的维护"></a>登录状态的维护</h2><p>和其他媒介一样，微信小程序本质上是内容的载体，因而我们也要有一个后台服务器来为小程序提供内容。</p>
<p>从小程序登录微信是极其容易的一件事情，但是我们的后台 api 怎么知道用户是不是真的登录了呢？那就要通过微信提供的 api 来验证了。</p>
<p>在微信的 <code>wx.login()</code> api 中，如果成功登录，则会返回一个登录凭证 code，小程序可以把这个 code 传递给 后台服务器，然后后台服务器通过调用微信的验证 api 来测试登录状态，如果成功则会返回 session_key 到后台服务器（这个 session_key 是密钥，不应该传输到小程序客户端）。</p>
<p>而小程序和普通的浏览器不一样，是不能存储 cookie 的，因此 cookie 相关应该存储到服务器中，而服务器应该把存储 cookie 的 key 来返回给小程序，小程序之后就通过这个 key 来向服务器进行请求。</p>
<p>注意这里有两个登录状态，一个是小程序中微信号的登录状态，第二个是服务器中的登录状态。后者是依托于前者，如果前者过期重新登录，则必须要更新服务的的登录状态。</p>
<p>这样设置的好处是控制了服务器的资源不能被随意获取。</p>
<p><a href="http://www.jianshu.com/p/c5f6c98b2685" target="_blank" rel="external">参考资料</a></p>
<h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p><code>wx.getStorageSync(key)</code> 是用来从本地缓存中同步获取指定 key 对应的内容。</p>
<p><code>wx.setStorageSync(key, value)</code> 把 value 存储到相应的 key 对应的内容中，会覆盖掉原来 key 对应的内容。</p>
<p><code>.unshift()</code> Array 的方法，用来在数组的首部添加一个或多个元素，添加几个元素就有几个参数。</p>
<p><code>.map()</code> Array 的方法，用 map 中的函数来处理 Array 中的每个数据。</p>
<p><code>=&gt;</code> 用来定义箭头函数，这个函数表达式的语法比函数表达式短。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 一个参数时圆括号是可选的</div><div class="line">singleParam =&gt; &#123; statements; &#125;</div><div class="line">(singleParam) =&gt; &#123; statements; &#125;</div><div class="line"></div><div class="line">(param1, param2, …, paramN) =&gt; &#123; statements; &#125;</div><div class="line">(param1, param2, …, paramN) =&gt; expression</div><div class="line">// 等价于：(param1, param2, …, paramN) =&gt; &#123; return expression; &#125;</div><div class="line">/* 当删除大括号时，它将是一个隐式的返回值，这意味着我们不需要指定我们返回*/</div><div class="line"></div><div class="line">// 没有参数时必须要使用圆括号</div><div class="line">() =&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h2&gt;&lt;p&gt;全局配置文件为 app.json，在项目的根目录中。&lt;/p&gt;
&lt;p&gt;配置详情参考&lt;a href=&quot;https://mp.we
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="微信小程序" scheme="https://blog.patrickcty.cc/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
