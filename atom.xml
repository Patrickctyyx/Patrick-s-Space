<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2017-09-18T15:23:07.000Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask常用扩展用法</title>
    <link href="https://blog.patrickcty.cc/2017/09/18/Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.patrickcty.cc/2017/09/18/Flask常用扩展用法/</id>
    <published>2017-09-18T15:21:51.000Z</published>
    <updated>2017-09-18T15:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>强大的 ORM 工具，让对数据库的操作变得简单。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_sqlalchemy import SQLAlchemy</div><div class="line"></div><div class="line">db = SQLAlchemy()</div><div class="line">db.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 根据实际的数据库类型来确定 URI</div><div class="line">SQLALCHEMY_DATABASE_URI = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;dev.sqlite&apos;)</div><div class="line">SQLALCHEMT_ECHO = True  # 可选</div><div class="line">SQLALCHEMY_TRACK_MODIFICATIONS = True  # 需要显式指明</div></pre></td></tr></table></figure>
<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Role(db.Model):</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    name = db.Column(db.String(80), unique=True)</div><div class="line">    description = db.Column(db.String(255))</div><div class="line"></div><div class="line">    def __init__(self, name=&apos;default&apos;):</div><div class="line">        self.name = name</div><div class="line"></div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;&lt;Role &#123;&#125;&gt;&apos;.format(self.name)</div></pre></td></tr></table></figure>
<h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.create_all()</div><div class="line">db.session.query()</div><div class="line">db.session.add()</div><div class="line">db.session.commit()</div><div class="line">db.session.flush()</div><div class="line">db.drop_all()</div></pre></td></tr></table></figure>
<h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>好用的登录控制扩展，功能全面并且强大。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from flask-login import LoginManger</div><div class="line"></div><div class="line">login_manger.login_view = &apos;main.login&apos;</div><div class="line">login_manger.session_protection = &apos;strong&apos;</div><div class="line">login_manger.login_message = &apos;请登录以访问该页面&apos;</div><div class="line">login_manger.login_message_category = &apos;info&apos;</div><div class="line"></div><div class="line">login_manger.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>需要在用户类里面实现特定的方法，或直接继承 UserMixin，注意如果用户的主键不是 id 则要自己实现 user_loader() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask_login import UserMixin, AnonymousUserMixin</div><div class="line"></div><div class="line">class User(db.Model, UserMixin):</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    </div><div class="line"></div><div class="line">class AnonymousUser(AnonymousUserMixin):</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<h3 id="作为函数的装饰器"><a href="#作为函数的装饰器" class="headerlink" title="作为函数的装饰器"></a>作为函数的装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@main_blueprint.route(&apos;/logout&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">@login_required</div><div class="line">def logout():</div><div class="line">    logout_user()</div><div class="line">    flash(&apos;登出成功！&apos;, category=&apos;success&apos;)</div><div class="line">    return redirect(url_for(&apos;blog.home&apos;))</div></pre></td></tr></table></figure>
<h3 id="登入登出"><a href="#登入登出" class="headerlink" title="登入登出"></a>登入登出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">login_user(user, remember=form.remember_me.data)</div><div class="line">logout_user()</div></pre></td></tr></table></figure>
<h3 id="获得当前用户对象"><a href="#获得当前用户对象" class="headerlink" title="获得当前用户对象"></a>获得当前用户对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">from flask-login import current_user</div></pre></td></tr></table></figure>
<p>在 Jinja2 模板中可以直接调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; current_user.name &#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="Flask-Bcrypt"><a href="#Flask-Bcrypt" class="headerlink" title="Flask-Bcrypt"></a>Flask-Bcrypt</h2><p>用来生成和检查加密字符串，常用作密码管理。</p>
<h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask-bcrypt import Bcrypt</div><div class="line"></div><div class="line">bcrypt = Bcrypt()</div><div class="line">bcrypt.init_app(app)</div></pre></td></tr></table></figure>
<h3 id="生成与检验密码"><a href="#生成与检验密码" class="headerlink" title="生成与检验密码"></a>生成与检验密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># property 装饰器将方法封装成了属性</div><div class="line">@property</div><div class="line">def passwd(self):</div><div class="line">    raise AttributeError(&apos;密码不可读！&apos;)</div><div class="line"></div><div class="line"># 通过下面的方法来实现直接对“属性”赋值</div><div class="line"># self.passwd = &apos;aaa&apos;</div><div class="line">@passwd.setter</div><div class="line">def passwd(self, password):</div><div class="line">    # 生成密码</div><div class="line">    self.password = bcrypt.generate_password_hash(password)</div><div class="line"></div><div class="line">def verify_password(self, password):</div><div class="line">    # 检验密码</div><div class="line">    return bcrypt.check_password_hash(self.password, password)</div></pre></td></tr></table></figure>
<h2 id="Flask-Principal"><a href="#Flask-Principal" class="headerlink" title="Flask-Principal"></a>Flask-Principal</h2><p>权限管理扩展。</p>
<h3 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h3><h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>Identity 用来表示身份，而 Need 是 Identity 的一部分，用来表示具体的权限。</p>
<p>Identity 一般在身份状态改变的时候创建，此时也会发出 identity_loaded 的信号，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">identity_changed.send(current_app._get_current_object(),</div><div class="line">                      identity=Identity(user.id))</div></pre></td></tr></table></figure>
<p>Identity 使用用户的 id 来表示用户以及创建对象。</p>
<h4 id="Need"><a href="#Need" class="headerlink" title="Need"></a>Need</h4><p>Need 如上面所说是用来表示具体的权限，是用 namedtuple 来实现的。</p>
<p>namedtuple 是 Python collections 模块中的一个数据结构，实现类似 C 语言中 struct 的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import namedtuple</div><div class="line">&gt;&gt;&gt; MyNT = namedtuple(&apos;tuple_name&apos;, [&apos;attr1&apos;, &apos;attr2&apos;])</div><div class="line">&gt;&gt;&gt; MyNT.__name__</div><div class="line">&apos;tuple_name&apos;</div><div class="line">&gt;&gt;&gt; nt = MyNT(&apos;this is the first attr&apos;, &apos;hello&apos;)</div><div class="line">&gt;&gt;&gt; nt.attr1</div><div class="line">&apos;this is the first attr&apos;</div></pre></td></tr></table></figure>
<p>Need 的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Need = namedtuple(&apos;Need&apos;, [&apos;method&apos;, &apos;value&apos;])</div></pre></td></tr></table></figure>
<p>Need 一般是 tuple，之后在 Permission 初始化的时候会被转换为 set，set 的基本元素是 Need。</p>
<p>UserNeed 和 RoleNeed 是 Need 的两种典型的表现形式，前者用 user id 来表示 method（个人感觉和 Identity 有些重叠），后者用 role 表示 method 作为权限。它们使用 Python 的 functools 中的 partial 来固定了 Need 的 method。</p>
<p>partial 一般用来固定函数的某个参数的值，产生一个偏函数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pow(2, 3)</div><div class="line">8</div><div class="line">&gt;&gt;&gt; from functools import partial</div><div class="line">&gt;&gt;&gt; my_pow = partial(pow, 2)  # 固定了 2 作为了 pow 的第一个参数</div><div class="line">&gt;&gt;&gt; my_pow(5)</div><div class="line">32</div></pre></td></tr></table></figure>
<p>RoleNeed 和 UserNeed 就是这样产生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RoleNeed = partial(Need, &apos;role&apos;)</div><div class="line">UserNeed = partial(Need, &apos;id&apos;)</div></pre></td></tr></table></figure>
<h4 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h4><p>Permission 用来表示权限，和具体的 Identity 无关，但是可以用来判断当前的 Identity 是否具有相应的权限。</p>
<p>Permission 使用 Need 来初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div></pre></td></tr></table></figure></p>
<p>使用 can() 方法来检测当前用户是否具有相应的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if not admin_permission.can():</div><div class="line">    abort(403)</div></pre></td></tr></table></figure></p>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>使用 Permission 表示权限，Identity 表示用户，用户所拥有的权限用 Need 来表示，通过 Permission 来检测 Identity 里面是否具有相应的 Need 来判断这个用户是否有相应的权限。</p>
<h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from flask_principal import Principal, Permission, RoleNeed, identity_loaded()</div><div class="line"></div><div class="line">principals = Principal()</div><div class="line"># 定义了三种权限</div><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div><div class="line"></div><div class="line">principals.init_app(app)</div><div class="line"></div><div class="line"># 当接收到 identity_loaded 信号时会被调用</div><div class="line"># 此时会将 Need 添加到相应的身份对象中</div><div class="line">@identity_loaded.connect_via(app)</div><div class="line">def on_identity_loaded(sender, identity):</div><div class="line">    identity.user = current_user</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;id&apos;):</div><div class="line">        identity.provides.add(UserNeed(current_user.id))</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;roles&apos;):</div><div class="line">        for role in current_user.roles:</div><div class="line">            identity.provides.add(RoleNeed(role.name))</div></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>作为装饰器或者直接调用 can() 方法来判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@blog_print.route(&apos;/edit/&lt;int:post_id&gt;&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line"># 没有 poster 权限无法访问</div><div class="line">@poster_permission.require(http_exception=403) </div><div class="line">@login_required</div><div class="line">def edit_post(post_id):</div><div class="line"></div><div class="line">    post = Post.query.get_or_404(post_id)</div><div class="line">    # 这个权限表示只有创建者才能访问</div><div class="line">    permission = Permission(UserNeed(post.user_id))</div><div class="line">    # 如果不是作者而是管理员则也可以访问</div><div class="line">    if not (permission.can() or admin_permission.can()):</div><div class="line">        abort(403)</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Identity-1"><a href="#Identity-1" class="headerlink" title="Identity"></a>Identity</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class Identity(object):</div><div class="line">    &quot;&quot;&quot;Represent the user&apos;s identity.</div><div class="line"></div><div class="line">    :param id: The user id</div><div class="line">    :param auth_type: The authentication type used to confirm the user&apos;s</div><div class="line">                      identity.</div><div class="line"></div><div class="line">    The identity is used to represent the user&apos;s identity in the system. This</div><div class="line">    object is created on login, or on the start of the request as loaded from</div><div class="line">    the user&apos;s session.</div><div class="line"></div><div class="line">    Once loaded it is sent using the `identity-loaded` signal, and should be</div><div class="line">    populated with additional required information.</div><div class="line"></div><div class="line">    Needs that are provided by this identity should be added to the `provides`</div><div class="line">    set after loading.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, id, auth_type=None):</div><div class="line">        self.id = id</div><div class="line">        self.auth_type = auth_type</div><div class="line">        self.provides = set()</div><div class="line"></div><div class="line">    def can(self, permission):</div><div class="line">        &quot;&quot;&quot;Whether the identity has access to the permission.</div><div class="line"></div><div class="line">        :param permission: The permission to test provision for.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return permission.allows(self)</div><div class="line"></div><div class="line"></div><div class="line">class AnonymousIdentity(Identity):</div><div class="line">    &quot;&quot;&quot;An anonymous identity&quot;&quot;&quot;</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        Identity.__init__(self, None)</div></pre></td></tr></table></figure>
<p>Identity 接受 user id 作为参数，provides 属性是和 Permission 类似都是一个用来储存 Need 的 set，其中 provides 的内容在切换身份的时候添加。</p>
<p>Identity 可以使用 can() 方法来判断该 Identity 是否具有相应的权限，这个方法接受一个 Permission 来作为参数，实际上直接调用 Permission 的方法来检查权限。</p>
<p>而匿名 Identity 则是 id 为空的特殊 Identity。</p>
<h4 id="IdentityContext"><a href="#IdentityContext" class="headerlink" title="IdentityContext"></a>IdentityContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class IdentityContext(object):</div><div class="line">    &quot;&quot;&quot;The context of an identity for a permission.</div><div class="line"></div><div class="line">    .. note:: The principal is usually created by the flaskext.Permission.require method</div><div class="line">              call for normal use-cases.</div><div class="line"></div><div class="line">    The principal behaves as either a context manager or a decorator. The</div><div class="line">    permission is checked for provision in the identity, and if available the</div><div class="line">    flow is continued (context manager) or the function is executed (decorator).</div><div class="line">    &quot;&quot;&quot;</div><div class="line"></div><div class="line">    def __init__(self, permission, http_exception=None):</div><div class="line">        self.permission = permission</div><div class="line">        self.http_exception = http_exception</div><div class="line">        &quot;&quot;&quot;The permission of this principal</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">    @property</div><div class="line">    def identity(self):</div><div class="line">        &quot;&quot;&quot;The identity of this principal</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return g.identity</div><div class="line"></div><div class="line">    def can(self):</div><div class="line">        &quot;&quot;&quot;Whether the identity has access to the permission</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return self.identity.can(self.permission)</div></pre></td></tr></table></figure>
<p>IdentityContext 通常通过 Permission.require() 方法来创建，它接受 Permission 作为参数，绑定的 Identity 是当前用户的 Identity（通过 g 来实现）。</p>
<h4 id="Permission-1"><a href="#Permission-1" class="headerlink" title="Permission"></a>Permission</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">class Permission(object):</div><div class="line">    &quot;&quot;&quot;Represents needs, any of which must be present to access a resource</div><div class="line"></div><div class="line">    :param needs: The needs for this permission</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, *needs):</div><div class="line">        &quot;&quot;&quot;A set of needs, any of which must be present in an identity to have</div><div class="line">        access.</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">        self.needs = set(needs)</div><div class="line">        self.excludes = set()</div><div class="line"></div><div class="line">    def require(self, http_exception=None):</div><div class="line">        &quot;&quot;&quot;Create a principal for this permission.</div><div class="line"></div><div class="line">        The principal may be used as a context manager, or a decroator.</div><div class="line"></div><div class="line">        If ``http_exception`` is passed then ``abort()`` will be called</div><div class="line">        with the HTTP exception code. Otherwise a ``PermissionDenied``</div><div class="line">        exception will be raised if the identity does not meet the</div><div class="line">        requirements.</div><div class="line"></div><div class="line">        :param http_exception: the HTTP exception code (403, 401 etc)</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return IdentityContext(self, http_exception)</div><div class="line"></div><div class="line">    def allows(self, identity):</div><div class="line">        &quot;&quot;&quot;Whether the identity can access this permission.</div><div class="line"></div><div class="line">        :param identity: The identity</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        if self.needs and not self.needs.intersection(identity.provides):</div><div class="line">            return False</div><div class="line"></div><div class="line">        if self.excludes and self.excludes.intersection(identity.provides):</div><div class="line">            return False</div><div class="line"></div><div class="line">        return True</div><div class="line"></div><div class="line">    def can(self):</div><div class="line">        &quot;&quot;&quot;Whether the required context for this permission has access</div><div class="line"></div><div class="line">        This creates an identity context and tests whether it can access this</div><div class="line">        permission</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        return self.require().can()</div></pre></td></tr></table></figure>
<p>Permission 可以说是最关键的部分了，它接受 Need 的 list 作为参数，并将其转换为 set 来储存所有的权限。为什么是 set 呢？因为 set 不可重复，并且做集合运算很容易直到是否存在某个 Need。</p>
<p>它的 require() 方法是使用得最多的方法之一，在调用这个方法的时候会创建一个 IdentityContext 实例，它会调用 IdentityContext.__enter__() 方法来检查权限，而这个方法里面又要调用 IdentityContext.can() 方法，这个方法又调用了相应的 Identity 对应的 Identity.can() 方法，并且传入当前 Identity 含有的权限作为参数。Identity 又调用 Permission.allows() 方法来检查权限，而这个方法则把 Permission 所具有的 Need 的 set 和 Identity.provides 这个 set 来做集合交运算来判断是否有相应的权限。（调用了一大圈，汗）</p>
<p>而 Permission.can() 的用法和上面的几乎一样。不过不同的是 require() 方法一般被用作装饰器，而 can() 方法一般用来直接进行判断。</p>
<h3 id="Principal-总结"><a href="#Principal-总结" class="headerlink" title="Principal 总结"></a>Principal 总结</h3><p>不得不说整个扩展设计得还是非常不错的，各个模块的逻辑性很强，只是太难理解了……我前前后后看了两遍……这次才终于搞清楚前前后后的逻辑了……</p>
<p>果然还是要看源代码，话说源代码写得还真不错，不仅文档详实，代码真的超级规范！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flask-SQLAlchemy&quot;&gt;&lt;a href=&quot;#Flask-SQLAlchemy&quot; class=&quot;headerlink&quot; title=&quot;Flask-SQLAlchemy&quot;&gt;&lt;/a&gt;Flask-SQLAlchemy&lt;/h2&gt;&lt;p&gt;强大的 ORM 工具，让对数
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="SQLAlchemy" scheme="https://blog.patrickcty.cc/tags/SQLAlchemy/"/>
    
      <category term="Principal" scheme="https://blog.patrickcty.cc/tags/Principal/"/>
    
      <category term="Login" scheme="https://blog.patrickcty.cc/tags/Login/"/>
    
  </entry>
  
  <entry>
    <title>《爆漫王》</title>
    <link href="https://blog.patrickcty.cc/2017/09/17/%E3%80%8A%E7%88%86%E6%BC%AB%E7%8E%8B%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/09/17/《爆漫王》/</id>
    <published>2017-09-17T06:34:49.000Z</published>
    <updated>2017-09-17T06:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>梦想，多么熟悉又陌生的一个词。对我来说，这个词似乎从来都没有存在过。</p>
<p>小学时候的“梦想”是成为天文学家，但这只是一个听起来很厉害的职业，而同期的小伙伴们很多选择的是同样炫酷的科学家、医生……这个所谓的梦想的作用也只是在亲戚和老师问到之后的一个回答而已。</p>
<p>而天文学家最接近梦想的一次是爸爸给我买天文望远镜，但是因为我没有太大的兴趣，所以天文望远镜也只用过一次就永远躺在老屋黑暗的顶楼中了。之后这个“梦想”就像那个崭新的天文望远镜一样湮没在尘埃之中了。</p>
<p>初中和高中本应该是大谈理想与未来的时刻，但是在深井中哪看得到什么理想，更何况背上还压着重担。在这样的情况下，大家都是一样，所谓的梦想，被简化成了目标，而目标，则被固化成了取得好成绩。</p>
<p>而我就在大流中漂着，偶尔也有人问过梦想，但是我的回答是不存在。</p>
<p>也不知道什么时候开始，整个社会，特别是青年一代，都开始追逐财富。“最大的梦想是一夜暴富”这种话也多次从我口中说出，但是真正暴富又怎样呢？这个我也从未认真想过，或许也只是因为欲望吧。</p>
<p>追求财富其实也是一个好梦想，但是好的梦想背后总有一个意义，而财富的意义确是那么空虚。所以这与其来说是一个梦想，倒不如说是一种焦虑，一种因为内心空虚缺乏梦想的焦虑。</p>
<p>高中毕业之后，背上的重担终于解除，离开井底也就是理所应当的了。其实很多时候人们一直待在井底并不是因为背上的重担，就像大象会被拴在木桩上并不是因为绳子。真正让我一直待在井底的原因在于我不知道外面有更广阔的世界，也没有机会能接触到。而上大学，让我被动着离开井底，虽然这之前我从来不知道我一直待在井底。</p>
<p>正是在这个过程中我才知道原来生活不仅仅只有成绩，兴趣不仅仅只有篮球动漫。虽然视野拓宽了，但是梦想似乎还是没有萌生，不过走着走着，总算是有了目标，而目标之后的梦想，却宛若缥缈云烟一般，仍然不可触及。</p>
<p>海贼王是一部有梦想的动漫，也是陪我从高中走到现在的动漫。路飞的梦想是成为海贼王，索隆的梦想是成为世界第一的大剑豪，娜美的梦想是画出整个世界的航海图，乌索普的梦想是成为勇敢的海上勇士，山治的梦想是找到 All Blue，罗宾的梦想是追寻历史的真相，乔巴的梦想是成为万能药，弗兰奇的梦想是看到自己造的船达到世界的尽头，而布鲁克的梦想则是再次与拉布见面。</p>
<p>每个人都有梦想，他们也在实现梦想的途中努着力，接受着嘲笑，但也是因为海贼的世界设计的太过精妙，反而没能激励我去现实世界寻找、实现梦想。而我最近看的《爆漫王》却是这种能让人充满干劲，甚至开始思考梦想的一部极其优秀的作品。</p>
<p>曾经男主真诚最高也是一名没有梦想的中学生，每天回家靠打游戏来挥霍时间，在学校里面有不高不低的成绩，暗恋一个从未说过话的女生。但是一个已经拥有并且准备追求梦想的人——高木秋人的出现改变了他的一生。<br>他们和女主一起确定了梦想：两人合作画出漫画，等到作品动画化之后最高就和女主亚豆结婚。</p>
<p>动画的第一季主要是讲述主角确定梦想并且开始向梦想奋斗的故事，其中不仅有欢笑，更多是对梦想的万分执着。两个年仅十四岁的少年，就已经有了人生奋斗的目标，并且和平常人不同的是，他们在这之后就全力追求目标了，连一秒钟都不浪费。真诚练习画画，高木写原作 NAME，很多人都会戏称《爆漫王》为《爆肝王》，因为他们真的太努力了。他们就这样一直奋斗着，接近着目标，从提名到刊载到这一季最后的连载，他们一步步在向那个梦想靠近。</p>
<p>个人认为第一季是整部剧最燃的一季，在这里我们和主角他们一起从零开始一起奋斗一起提心吊胆、分享喜悦，真的让人有一种马上去学习的欲望。</p>
<p>第二季同样精彩，但是这一季整体节奏没有第一步那么明快，颇有几分压抑的气息。那是因为梦想实现的过程总不总是一帆风顺，总是会有各种各样的挫折。</p>
<p>而主角他们遇到的第一个大的挫折就是首部连载作品因为真诚的“爆肝”而不得不长时间休刊，等到最后恢复的时候已经人气下降被腰斩。之后又因为责编的原因不得不去画他们所不喜欢且不擅长的搞笑漫画，也因此他们的作品的名次一直在一个很令人尴尬的位置。在这一季最后，他们勇敢地选择结束连载，并在重重困难之下完成了新的作品，通过了编辑部的挑战。</p>
<p>这一季看的时候感觉十分揪心，就像《牧羊少年》里面说的那样，梦想是以初行者的运气开始，而到了后面就成为了对旅行者的考验。这时候的真诚他们也是迈入了后一个阶段，其中令人印象深刻的是真诚在医院中挣扎着画画的场景，这种对梦想的执着真的是无人能及了。</p>
<p>除此之外，第二季中友谊这个概念也变得更加深入，除了真诚和高木的革命友谊之外，同为福田组的新妻英二、福田先生、中井先生、苍树红等这些人物与主角的友情也表现得淋漓尽致，虽然他们是对手，但同时也是伙伴，正是有了他们相互的支持，这一季才不会让人感觉过于压抑。</p>
<p>说到这些其他的角色，就不得不说这部动漫的另一个亮点了——人物刻画。主人公一行人就不用说了，一群志同道合又个性鲜明的作者，一群性格迥异却又敬业的编辑，全都是“圆形人物”，人物的个性都被表现得淋漓尽致。</p>
<p>其中最让人喜欢的莫过于直爽天真又天赋异禀的新妻英二，他虽然是天才但是并没有天才的架子，反而是一个非常让人亲近的人，也正是抱着超过他的态度，主角他们才能一次一次奋斗，画出更好的作品。而编辑的角色中服部先生最让人喜爱，不仅是因为他直爽的性格与笑声，更是因为他的敬业与真性情，他会为了作者而开心与难受，和他们一起奋斗，正是有了他才让亚城木梦叶他们能走在正确的道路上接近梦想。</p>
<p>而第三季的剧情就比第二季明快不少，但是少了第一季的跌宕起伏，不过剧情的精彩程度还是无可挑剔的。这一季主人公终于走出低谷，大放异彩，最终实现了梦想。</p>
<p>看到最后的时候不禁让人感到落寞，短短的一段时间，就见证了主角他们十年的努力。看的时候希望他们能早日实现梦想，但是当真正实现了梦想的时候却也是不得不说再见的时候了。虽然剧情到这里就结束了，但是这部动漫让我陷入了思考——我的梦想到底是什么？</p>
<p>想来想去，虽然我没有真诚那样明确的梦想，动画化，结婚。但是我也有一个阶段一个阶段的目标，从最近的跟着导师搞科研，到之后的考研上中山大学。和主角相比，我对梦想的执着程度还是太低，这也是我一直以来最大的问题。我无法像主角那样一直专注于梦想，但是看过这部动漫之后我也有了行动，我放弃掉了一些占用很多时间的无意义的内容，比如花大量时间看对我没什么用的手机评测以及肝得很累的崩坏 3。</p>
<p>我想，等我以后觉得很累想放弃的时候我就会再次拾起这部动漫重新找回向前奋斗的勇气吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;梦想，多么熟悉又陌生的一个词。对我来说，这个词似乎从来都没有存在过。&lt;/p&gt;
&lt;p&gt;小学时候的“梦想”是成为天文学家，但这只是一个听起来很厉害的职业，而同期的小伙伴们很多选择的是同样炫酷的科学家、医生……这个所谓的梦想的作用也只是在亲戚和老师问到之后的一个回答而已。&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="https://blog.patrickcty.cc/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="感动" scheme="https://blog.patrickcty.cc/tags/%E6%84%9F%E5%8A%A8/"/>
    
      <category term="梦想" scheme="https://blog.patrickcty.cc/tags/%E6%A2%A6%E6%83%B3/"/>
    
      <category term="友谊" scheme="https://blog.patrickcty.cc/tags/%E5%8F%8B%E8%B0%8A/"/>
    
      <category term="欢乐" scheme="https://blog.patrickcty.cc/tags/%E6%AC%A2%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中 Celery 的用法（二）</title>
    <link href="https://blog.patrickcty.cc/2017/09/03/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/09/03/再次理解Flask中Celery的用法（二）/</id>
    <published>2017-09-03T02:58:34.000Z</published>
    <updated>2017-09-03T03:00:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-Celery-的用法（二）"><a href="#再次理解-Flask-中-Celery-的用法（二）" class="headerlink" title="再次理解 Flask 中 Celery 的用法（二）"></a>再次理解 Flask 中 Celery 的用法（二）</h1><h2 id="运行-Celery-task"><a href="#运行-Celery-task" class="headerlink" title="运行 Celery task"></a>运行 Celery task</h2><p>我们之前都是用 Celery task 的 delay() 方法来运行任务，但是这只是 apply_async 方法的简略版本，后者的使用方法如下：</p>
<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">task.apply_async(</div><div class="line">    args=[1, 2],  # 可选，表示参数列表，是一个 list</div><div class="line">    kwargs=&#123;&apos;kwarg1&apos;: &apos;1&apos;, &apos;kwarg2&apos;: &apos;2&apos;&#125;,</div><div class="line">    # countdown 表示指定秒数后后开始处理这个任务</div><div class="line">    # 不是一定在那个时候执行，要根据其他任务来定</div><div class="line">    countdown=600,</div><div class="line">    # eta 表示指定时间开始处理这个任务</div><div class="line">    # 执行时间和 countdown 一样不完全可靠</div><div class="line">    # 我用这个参数来发邮件结果第二天才发出去……</div><div class="line">    eta=datetime.datime.now() + datetime.timedelta(hours=1)</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="Celery-签名-子任务"><a href="#Celery-签名-子任务" class="headerlink" title="Celery 签名/子任务"></a>Celery 签名/子任务</h2><p>签名可以把 task 生成函数来便于其他的函数进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import signature</div><div class="line">&gt;&gt;&gt; from webapp.tasks import multiply</div><div class="line"># signature 的第一个参数要写全</div><div class="line">&gt;&gt;&gt; signature(&apos;webapp.tasks.multiply&apos;, args=[4, 4], countdown=10)</div><div class="line">webapp.tasks.multiply(4, 4)  # 返回的是一个函数</div><div class="line"># 和上面相同的功能</div><div class="line">&gt;&gt;&gt; multiply.subtask((4, 4), countdown=10)</div><div class="line">webapp.tasks.multiply(4, 4)</div><div class="line"># 上面的缩略版本，没有关键字参数</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4)</div><div class="line">webapp.tasks.multiply(4, 4)</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4)()  # 调用函数</div><div class="line">16</div><div class="line">&gt;&gt;&gt; multiply.s(4, 4).delay()  # 创建任务</div></pre></td></tr></table></figure>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>Celery 任务签名的第一个应用是偏函数。偏函数来源于一个要接受很多参数的函数，这个函数被施加某种操作之后，生成了一个新的函数，在调用这个函数的时候，前 n 个参数永远是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; partial = multiply.s(4)  # 第一个参数永远是 4</div><div class="line">&gt;&gt;&gt; partial(5)</div><div class="line">20</div><div class="line">&gt;&gt;&gt; partial.delay(5)</div></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是根据前一个任务执行的结果来执行的函数。在 apply_async() 中使用 link 参数来添加回调函数。</p>
<p>这个执行任务返回的值并不是回调函数的结果，而是前一个任务执行的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># link 接受一个签名作为参数</div><div class="line"># log 接受 multiply 的结果作为参数</div><div class="line"># 这里是建立了两个 task，并且返回值都是 16</div><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.s())</div><div class="line"># 如果回调函数不接受输入或者不需要上一个任务的结果</div><div class="line"># 那么签名必须使用 si 方法（设置为不可变类型）</div><div class="line"># 结果为 16 而不是 hello</div><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=log.si(&apos;hello&apos;))</div></pre></td></tr></table></figure>
<p>回调函数常常用来做两个联系紧密的任务，比如每次创建用户的任务之后都发送一封欢迎 email。</p>
<p>偏函数也可以和回调函数一起用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; multiply.apply_async((4, 4), link=multiply.s(4))</div></pre></td></tr></table></figure>
<h2 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h2><p>任务组函数接受一组任务签名的列表，并生成一个函数，调用该函数可并行执行所有的任务签名，并返回所有结果的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import group</div><div class="line">&gt;&gt;&gt; sig = group(multiply.s(i, i + 5) for i in range(10))</div><div class="line">&gt;&gt;&gt; rst = sig.delay()</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">[0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</div></pre></td></tr></table></figure>
<h2 id="任务链"><a href="#任务链" class="headerlink" title="任务链"></a>任务链</h2><p>任务链和回调函数有点相像，它接受一组任务签名，把每个签名的执行结果传给任务链的下一个，最后只会返回最后一个的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import chain</div><div class="line"># 事实上也是创建了多个任务，但是只会返回最终的结果</div><div class="line">&gt;&gt;&gt; sig = chain(multiply.s(10, 10), multiply.s(10), multiply.s(10))</div><div class="line"># 另一种写法</div><div class="line">&gt;&gt;&gt; sig = (multiply.s(10, 10) | multiply.s(10) | multiply.s(10))</div></pre></td></tr></table></figure>
<p>任务链也可以用来组合偏函数生成新的偏函数，这样的话任务链也可以嵌套了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; func = (multiply.s(10) | multiply.s(10))</div><div class="line">&gt;&gt;&gt; rst = func.delay(16)</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">1600</div></pre></td></tr></table></figure></p>
<h2 id="复合任务"><a href="#复合任务" class="headerlink" title="复合任务"></a>复合任务</h2><p>复合任务是函数生成一个任务签名的时候，会先执行一个任务组，然后把最终结果传给回调函数，最后回调函数的结果就是最终的结果，这里和上面的回调函数部分有些不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from celery import chord</div><div class="line">&gt;&gt;&gt; sig = chord(</div><div class="line">    group(multiply(i, i + 5) for i in range(10)),</div><div class="line">    # 整个任务组执行的结果，也就是回调函数的参数是 list</div><div class="line">    multiply.s(2) </div><div class="line">)</div><div class="line">&gt;&gt;&gt; rst = sig.delay()</div><div class="line">&gt;&gt;&gt; rst.get()</div><div class="line">[0, 6, 14, 24, 36, 50, 66, 84, 104, 126, 0, 6, 14, 24, 36, 50, 66, 84, 104, 126]</div><div class="line"># 还有另一种写法</div><div class="line">&gt;&gt;&gt; sig = (group([0, 6, 14, 24, 36, 50, 66, 84, 104, 126]) | multiply.s(2))</div></pre></td></tr></table></figure>
<h2 id="定期执行任务"><a href="#定期执行任务" class="headerlink" title="定期执行任务"></a>定期执行任务</h2><p>和 Linux 的 cron 命令有点类似，不过这里完全是在 Flask 的上下文中来执行任务的。</p>
<p>要在 config 文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CELERY_SCHEDULE = &#123;</div><div class="line">    &apos;log-every-30-seconds&apos;: &#123;</div><div class="line">        &apos;task&apos;: &apos;webapp.tasks.log&apos;,</div><div class="line">        &apos;schedule&apos;: datetime.timedelta(seconds=30),</div><div class="line">        &apos;args&apos;: [&apos;hello&apos;,]</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是定义了 log 任务每隔 30s 执行一次</p>
<p>如果要运行定期任务，就要使用 Celery 的 beat 工作进程，当然任务也是在 worker 进程中执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery -A celery_runner beat</div></pre></td></tr></table></figure>
<p>如果要在一个精确的时间执行，那么就要用 crontab 对象了，具体的用法参考 Celery <a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from celery.schedules import crontab</div><div class="line"># 每天凌晨</div><div class="line">&gt;&gt;&gt; crontab(minute=0, hour=0)</div><div class="line"># 早上五点，十点，下午三点，八点</div><div class="line">&gt;&gt;&gt; crontab(minute=0, hour=[5, 10, 15, 20])</div></pre></td></tr></table></figure>
<h2 id="在-Flower-中通过网页监控"><a href="#在-Flower-中通过网页监控" class="headerlink" title="在 Flower 中通过网页监控"></a>在 Flower 中通过网页监控</h2><p>Flower 是针对 Celery 的基于网页的试试管理工具。</p>
<p>安装 Flower：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install flower</div></pre></td></tr></table></figure></p>
<p>运行 Flower：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery flower -A celery_runner --loglevel=info</div></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说实话第一次看到上面这些的时候真的十分头大，一脸懵逼，不过现在回头整理了一遍之后明了了许多，不过要吐槽的是 eta 为什么这么坑啊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-Celery-的用法（二）&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-Celery-的用法（二）&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 Celery 的用法（二）&quot;&gt;&lt;/a&gt;再次理解 Fla
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Celery" scheme="https://blog.patrickcty.cc/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中 Celery 的用法（一）</title>
    <link href="https://blog.patrickcty.cc/2017/09/01/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADCelery%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/09/01/再次理解Flask中Celery的用法（一）/</id>
    <published>2017-09-01T02:19:35.000Z</published>
    <updated>2017-09-03T03:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-Celery-的用法（一）"><a href="#再次理解-Flask-中-Celery-的用法（一）" class="headerlink" title="再次理解 Flask 中 Celery 的用法（一）"></a>再次理解 Flask 中 Celery 的用法（一）</h1><h2 id="Celery-概览"><a href="#Celery-概览" class="headerlink" title="Celery 概览"></a>Celery 概览</h2><p>Celery 是用 Python 编写的任务队列工具，它使用 Python 的多任务库来并行地执行任务。</p>
<p>在下面我们用 Flask Server 来发送任务请求，由消息队列储存并转发给 Celery。Celery 运行的结果也同样由消息队列传递回去。</p>
<p>消息队列是一个队列，用来在生产者进程和消费者进程之间传递信息。不过消息队列在生产者接收到消息之后就立即把数据丢弃了，这时候可以用数据库来保存任务结果。</p>
<h2 id="配置-Celery-环境"><a href="#配置-Celery-环境" class="headerlink" title="配置 Celery 环境"></a>配置 Celery 环境</h2><p>安装 Celery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install celery</div></pre></td></tr></table></figure></p>
<p>安装 Flask 扩展来辅助处理 Celery 的初始化(可选)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install flask-celery-helper</div></pre></td></tr></table></figure></p>
<p>安装 Redis 来作为消息队列以及储存最终的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install redis</div><div class="line">redis-server  # 使用 redis</div></pre></td></tr></table></figure></p>
<h2 id="在-Celery-中创建任务"><a href="#在-Celery-中创建任务" class="headerlink" title="在 Celery 中创建任务"></a>在 Celery 中创建任务</h2><p>在 Celery 中，broker 意思是中间人，指的就是消息队列本身，而 result backend 顾名思义就是存储得到的结果。</p>
<h3 id="单文件示例"><a href="#单文件示例" class="headerlink" title="单文件示例"></a>单文件示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&quot;task.py&quot;&quot;&quot;</div><div class="line"></div><div class="line">from celery import Celery</div><div class="line">import time</div><div class="line"></div><div class="line">app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379&apos;)</div><div class="line"></div><div class="line">@app.task</div><div class="line">def add(x, y):</div><div class="line">    print &apos;hello celery&apos;</div><div class="line">    time.sleep(10)</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>使用 task：</p>
<ul>
<li><p>新建一个 Python Shell，使用 delay 或 apply_async 来运行 add 方法，注意只有当 Celery 实例存在时运行结果才会被收到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from task import add</div><div class="line">&gt;&gt;&gt; add.delay(3, 5)</div><div class="line">&gt;&gt;&gt; add.apply_acync([7, 8])</div></pre></td></tr></table></figure>
</li>
<li><p>再在另一个终端中运行 Celery worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery worker -A task --loglevel=info</div></pre></td></tr></table></figure>
<p>  worker 表示使用 Celery worker<br>  -A 参数是一个含有 Celery 实例的模块名，Celery 通过它来运行</p>
</li>
</ul>
<p>运行 Celery worker 之后就可以看到任务信息了，如果要在 shell 中得到返回的结果则还要配置 backend</p>
<p>修改上面的 app 为如下即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app = Celery(</div><div class="line">    &apos;tasks&apos;,</div><div class="line">    broker=&apos;redis://localhost:6379&apos;，</div><div class="line">    backend=&apos;redis://localhost:6379&apos;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>然后就可以在 Python Shell 查看 Celery 运行的结果和状态了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; rst = add.delay(8, 7)</div><div class="line">&gt;&gt;&gt; rst.state()  # 查看任务现在的状态</div><div class="line">&gt;&gt;&gt; rst.ready()  # 判断任务是否完成</div><div class="line">&gt;&gt;&gt; rst.get()    # 得到运行结果</div><div class="line">15</div></pre></td></tr></table></figure></p>
<h3 id="Flask-中使用示例"><a href="#Flask-中使用示例" class="headerlink" title="Flask 中使用示例"></a>Flask 中使用示例</h3><h4 id="使用扩展来配置"><a href="#使用扩展来配置" class="headerlink" title="使用扩展来配置"></a>使用扩展来配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask_celery import Celery()</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config.update(</div><div class="line">    CELERY_BROKER_URL=&apos;redis://localhost:6379&apos;,</div><div class="line">    CELERY_RESULT_BACKEND=&apos;redis://localhost:6379&apos;</div><div class="line">)</div><div class="line">celery = Celery(app)</div><div class="line"></div><div class="line"></div><div class="line">@celery.task()</div><div class="line">def add_together(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure>
<p>这里直接使用了上面安装的 flask-celery-helper 扩展，所以就直接接用扩展来初始化 Celery 实例即可。</p>
<h4 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h4><p>准备工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&quot;&quot;&quot;celery_maker.py&quot;&quot;&quot;</div><div class="line">from celery import Celery</div><div class="line"></div><div class="line">def make_celery(app):</div><div class="line">    celery = Celery(</div><div class="line">        app.import_name, </div><div class="line">        broker=app.config[&apos;CELERY_BROKER_URL&apos;]</div><div class="line">    )</div><div class="line">    celery.conf.update(app.config)</div><div class="line">    TaskBase = celery.Task</div><div class="line">    class ContextTask(TaskBase):</div><div class="line">        abstract = True</div><div class="line">        def __call__(self, *args, **kwargs):</div><div class="line">            with app.app_context():</div><div class="line">                return TaskBase.__call__(self, *args, **kwargs)</div><div class="line">    celery.Task = ContextTask</div><div class="line">    return celery</div></pre></td></tr></table></figure></p>
<p>使用 Celery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from celery_maker import make_celery</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config.update(</div><div class="line">    CELERY_BROKER_URL=&apos;redis://localhost:6379&apos;,</div><div class="line">    CELERY_RESULT_BACKEND=&apos;redis://localhost:6379&apos;</div><div class="line">)</div><div class="line">celery = make_celery(app)</div><div class="line"></div><div class="line"></div><div class="line">@celery.task()</div><div class="line">def add_together(a, b):</div><div class="line">    return a + b</div></pre></td></tr></table></figure></p>
<p>make_celery 的作用就是把每个对 Celery 任务的调用都包含到 Python 的 with 代码中，这样 Celery 在 Flask 的应用上下文中，就可以确保 Flask 扩展的调用都能正常工作了。</p>
<p>使用方法和之前的也是一样，不过在调用 task 的时候也必须在 Flask 的应用上下文中，不然就达不到预料的结果。</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>我之前就是因为把配置文件的名字写错了导致一直提示 backend 不存在……不要盲目相信书上的内容……还是官方文档靠谱……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-Celery-的用法（一）&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-Celery-的用法（一）&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 Celery 的用法（一）&quot;&gt;&lt;/a&gt;再次理解 Fla
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Celery" scheme="https://blog.patrickcty.cc/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>《十万个冷笑话2》</title>
    <link href="https://blog.patrickcty.cc/2017/08/26/%E3%80%8A%E5%8D%81%E4%B8%87%E4%B8%AA%E5%86%B7%E7%AC%91%E8%AF%9D2%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/26/《十万个冷笑话2》/</id>
    <published>2017-08-26T01:03:25.000Z</published>
    <updated>2017-08-26T01:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《十万个冷笑话-2》"><a href="#《十万个冷笑话-2》" class="headerlink" title="《十万个冷笑话 2》"></a>《十万个冷笑话 2》</h1><p>《十万个冷笑话》是在 2014.12.31 上映，2017.8.24，一起看第一部的原班人马再度聚集。</p>
<p>说起来已经有两年多了，看《十冷》的时候正是学习最紧张的高三，每天的课程与作业压得人透不过起来，而最能让人放松的反而是每周一次的月考，因为有着难得的一整天以及一个晚上的休息时间。而趁着这个时间，荷花亭小分队就会聚首，去到菱角湖万达，那个最常去因为充满着回忆的地方，又或者是去到西园，去放松被学校所压抑的内心。而《十冷》我们就是一起到西园去看的。《十冷》电影的情节早已模糊，但是当时看电影的情景，反而浮现在了脑海中。</p>
<p>毕业也没有拆散我们的友情，不过毕业却会改变一些事情。</p>
<p>当改变还没有发生时，我们一起去了青岛，在海边，在街边，在桥上，在房间里……我们被友谊的快乐包围着，心里祈祷着这样的友谊一直到永远。</p>
<p>但是随着毕业越来越久，改变也变得越来越明显，菁搬到了遥远的汉阳，出行变得不方便，而晨晨和男神在假期也有了满满的安排，我呢，在当时也有了自己的幸福。这就导致荷花亭小分队的聚首变得愈发困难。</p>
<p>不过友谊 wins，去年暑假，我们找到了机会再度聚首，而这次是在李文菁家。依然是以吃吃吃为主题，这次吃到了李文菁亲手烘焙的饼干和泡芙。友谊依然是熟悉的味道。</p>
<p>而寒假则更难找到时间了，兜兜转转又是一年的暑假。这一年的暑假则又变得更加难以聚首，菁依旧在遥远的汉阳，男神则有学校工作以及旅游安排，晨晨也找到了实习，而我则在广州待了很久。就在我以为没办法再度见面之时，阴差阳错之间我把车票改到了后一天，男神也正好“没有安排”，而晨晨和菁也能抽出时间，于是聚会就这样定了下来，也真的可以说是缘分。于是欢乐与我们再次光临了荷花亭，也再次一起观看了《十冷 2》。</p>
<p>荷花亭的菜依旧好吃，但是《十冷 2》却没有那么好看了，不过这些都不重要，因为你们都来了，现在大家都有了自己的幸福，也都有了自己的爱好与目标，我们不再“相同”，但是那份快乐经过了这么多年的酝酿，没有变质，却是越发醇香。依然是荷花亭，依然是吃吃吃，依然是拍拍拍，依然是小分队。</p>
<p>不知道下次见面会是在哪里，不过拥有着彼此的这么多黑照，可不能随随便便玩消失呀！男神请我们去青岛吃吃喝喝，菁亲手给我们考饼干吃，晨晨也接我们去了华科吃饭，那什么时候我能接你们来广州吃早茶呢~希望真的有这一天呢~</p>
<p>《十冷 2》的剧情也不重要，但它的意义却包含了很多~以后的《十冷 3》，《百冷》，《千冷》我们也要一起笑！</p>
<p>不过我在最后还是要吐槽一下《十冷 2》的剧情，看样子导演和编剧确实想拍出好电影，但是在剧情的设计上还是有很多的槽点，在大场面的表现上也显得十分不自然，人物刻画也很草率，前期的铺垫也做得不够好……主要是剧情是硬伤……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《十万个冷笑话-2》&quot;&gt;&lt;a href=&quot;#《十万个冷笑话-2》&quot; class=&quot;headerlink&quot; title=&quot;《十万个冷笑话 2》&quot;&gt;&lt;/a&gt;《十万个冷笑话 2》&lt;/h1&gt;&lt;p&gt;《十万个冷笑话》是在 2014.12.31 上映，2017.8.24，一起看
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="十万个冷笑话" scheme="https://blog.patrickcty.cc/tags/%E5%8D%81%E4%B8%87%E4%B8%AA%E5%86%B7%E7%AC%91%E8%AF%9D/"/>
    
      <category term="荷花亭小分队" scheme="https://blog.patrickcty.cc/tags/%E8%8D%B7%E8%8A%B1%E4%BA%AD%E5%B0%8F%E5%88%86%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>《战狼2》</title>
    <link href="https://blog.patrickcty.cc/2017/08/19/%E3%80%8A%E6%88%98%E7%8B%BC2%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/19/《战狼2》/</id>
    <published>2017-08-19T14:45:42.000Z</published>
    <updated>2017-08-19T15:04:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《战狼-2》"><a href="#《战狼-2》" class="headerlink" title="《战狼 2》"></a>《战狼 2》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>这是我用 MacBook Pro 写的第一部影评~撒花撒花~</p>
<p>《战狼 2》作为一部现象级的国产电影，在很长时间之内刷爆了朋友圈，于是乎在女票回学校之后就第一时间和她一起出去看了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>整部电影是以一个退伍兵为主角来讲述的，和《湄公河行动》有些相像，都是为了替被害的爱人报仇。还有一个最近比较流行的套路就是中外混血电影，《战狼 2》如此，《侠盗联盟》也如此，虽然感觉高大上了一些，但是总是感觉有慢慢的违和感……</p>
<p>不过和《湄公河行动》不同，这部电影中绝大部分都是吴京或者说是冷锋的个人英雄主义。这是整部电影最精彩的地方，但同时也是整部电影的逻辑败笔所在。</p>
<p>从刚开始的徒手潜水解决海盗，到之后枪林弹雨中带着身边的人去到中国大使馆，再到之后只身去医院解救医院的人，以及后来去解救工厂的人。这些场景中的打斗场面都十分精彩，对冷锋这个角色的表现也十分到位：有勇有谋，坚毅，技艺高超，重情……期间穿插的回忆也很妥当，不会显得拖时间。</p>
<p>但是！但是！你让一个人去解救医院里面的人还有工厂里面的人这是闹哪样！编剧恐怕真的是把冷锋当成了钢铁侠，美国队长一个人恐怕都完成不了任务……讲道理我觉得冷锋如果去美国真的可以加入复仇者联盟了，我感觉他甚至可以取代美国队长的位置了（虽然感觉打不过美国队长）。</p>
<p>整部电影后半段就纯粹变成爽片了，不过在爽的同时，电影刻画了一些小人物，比如在医院里面的医生，以及工厂里面为了保护女主两人而挺身而出面对子弹的工厂的工人们，还有就是工厂里面贪生怕死的厂长。这些人物虽然占的戏份比较少，但是都比较鲜活。</p>
<p>另外一个值得一提的人物就是张翰演的富二代卓亦凡（不知道这个名字是不是在暗指某吴姓小鲜肉），从一开始的挂着骚红的 beats 耳机登场，到后来的一些明显是没有经历过真实战争的言行。张翰的本色出演，将这样一个叛逆的公子的形象表现的淋漓尽致，和人物的定位十分贴合。而后面的人物的转变也刻画得很不错，虽然还是很坑，不过为主角战队增加了重要的战力，还有一些小小的笑点。</p>
<p>至于爱国情怀？我感觉打得有点过了，诚然祖国如今已经是十分强大，撤侨工作每次也做得十分到位及时，但是在这一部电影里面却有一种刻意地渲染以至于有些矫情了……还有就是中国的舰队在这次事情中提供的帮助真的太有限了……不过最后所有舰队的导弹的轰鸣还是十分让人热血沸腾的。</p>
<p>总之这是一部比较成功的商业大片，演员演技全程在线，作为一部爽片还是让人感觉很不错的，只是剧情还有一些硬伤，作为一个非魔幻的片还是应该“真”一点，还有就是不知道这个反派是不是在《战狼 1》中出现过，感觉他的行为全程都令人莫名奇妙……</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10.</p>
<p>特效动作都十分到位，整体也很激动人心，去电影院一起狂欢一下也是极好的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《战狼-2》&quot;&gt;&lt;a href=&quot;#《战狼-2》&quot; class=&quot;headerlink&quot; title=&quot;《战狼 2》&quot;&gt;&lt;/a&gt;《战狼 2》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="国产电影" scheme="https://blog.patrickcty.cc/tags/%E5%9B%BD%E4%BA%A7%E7%94%B5%E5%BD%B1/"/>
    
      <category term="战争片" scheme="https://blog.patrickcty.cc/tags/%E6%88%98%E4%BA%89%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>《蝙蝠侠》黑暗骑士三部曲</title>
    <link href="https://blog.patrickcty.cc/2017/08/11/%E3%80%8A%E8%9D%99%E8%9D%A0%E4%BE%A0%E3%80%8B%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>https://blog.patrickcty.cc/2017/08/11/《蝙蝠侠》黑暗骑士三部曲/</id>
    <published>2017-08-11T08:44:56.000Z</published>
    <updated>2017-08-11T08:46:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蝙蝠侠》黑暗骑士三部曲"><a href="#《蝙蝠侠》黑暗骑士三部曲" class="headerlink" title="《蝙蝠侠》黑暗骑士三部曲"></a>《蝙蝠侠》黑暗骑士三部曲</h1><p>在看完黑暗骑士之后，我又决定把剩下的两部看完，在看完整个三部之后，我少有的有了一种意犹未尽想看下一部的感觉。</p>
<p>大家觉得黑暗骑士三部曲经典，多是因为诺兰刻画出了一个真正的蝙蝠侠——一个一心想拯救自己父母曾全力保护的高谭市的人。而不仅仅是一个无所不能，令犯罪分子闻风丧胆的超级英雄。作为一个活生生的人，蝙蝠侠也拥有迷茫，也会害怕，也会愤怒，也正是通过这些情绪的表达，让电影不再那么模式化，让电影有了新的活力。</p>
<p>第一部《蝙蝠侠：侠影之谜》是蝙蝠侠找到自我的过程，从一个无忧无虑的富二代公子，到目睹自己父母被枪杀之后被愤怒蒙蔽双眼，再到谋杀父母的仇人被更加有后台的人枪杀之后对犯罪的迷茫，再到跟着忍者大师找回自我，于是蝙蝠侠就此产生。</p>
<p>小时候掉进蝙蝠洞的经历让他拥有了深入内心的恐惧，而这恐惧在间接中促进了他父母的死亡，于是仇恨的种子也在内心中植下。但是当仇人死亡以及被黑帮老大嘲讽之后，仇恨悄然消失，取而代之的是迷茫，这时的韦恩选择了流浪，亲身去经历犯罪，亲身感受犯罪。</p>
<p>而忍者大师的指点，帮助了他去直面自己的恐惧并且控制自己的愤怒。这部分的描绘比较写意，不过这样和意境确实契合得十分好。</p>
<p>尽管忍者大师能帮他控制情绪，但是自己的路还是要靠自己去开创，在学会控制情绪之后，韦恩也找到了自己的路，但是这条路和影武者联盟所信奉的道路产生了冲突。为了坚持自己的道路——不杀人，他让影武者联盟的房子陷入了火海，“忍者大师”也因此死亡，韦恩的师傅杜卡也陷入昏迷。</p>
<p>这部分我感觉处理的不是很好，韦恩的原则是不杀人，但是在这里他间接杀死了和自己理念不同的“忍者大师”，这难道就不违背他的原则么？而且因为这次的事情，影武者联盟的房子都被毁于一旦，成员也有死伤。从后面的剧情来看，在这里即使“忍者大师”不死，对后面的剧情也没有什么很大的影响，这个地方我觉得是败笔。</p>
<p>不过也因为有了这一段的经历，韦恩终于找到了自己要走的路，他也有了实现自己理想所需要的品质，于是蝙蝠侠就这样诞生了。</p>
<p>电影的节奏把握得极好，感觉我们在跟着韦恩一起，见证着他的成长，这种感觉让观众对蝙蝠侠有了更深的感触，电影的代入感也更强。</p>
<p>第一部讲的是蝙蝠侠的成长，而第二部则是蝙蝠侠和精通犯罪小丑的比赛中输掉了，并“元气大伤”，失去了目标，陷入了谷底，此时高谭市已经情况好转，但这也意味着蝙蝠侠复出的可能性更小了。在这样的情况下，他遇到了“最可怕的敌人”，和他一样师出忍者大师的贝恩。贝恩的强不仅仅在于他的武艺，更是因为他出身黑暗与绝望并适应黑暗与绝望，并且有着一群忠心耿耿的手下。在这样的情况下，蝙蝠侠又怎么会是他的对手？于是蝙蝠侠也被送入了他曾待过的绝望的监狱中，其实在被送进来之前，蝙蝠侠就已经身处谷底，而这个监狱，反而再次给了他崛起的契机——重新找回存在的意义，唤醒起恐惧，因为就像医生所说：“恐惧会祝你一臂之力”。而正是这样的考验下，蝙蝠侠终于找回自我，完成了崛起。</p>
<p>而另一方面在布莱克警探和戈登局长的带领下，被贝恩支配的高谭市内的人也没有放弃，但是蝙蝠侠的缺席总是让他们群龙无首，而蝙蝠侠的出现也终于将他们凝聚了起来，高潮时那一群只有普通手枪的警察面对装备精良的贝恩一群人不畏惧而毅然冲上去的场景让我感觉很震撼，在危急时刻即使是害怕死亡的人也会完成觉醒。</p>
<p>这黑暗骑士三部曲中，充分探讨了人性，从蝙蝠侠的角度——一切都是为了高谭市；从最关心蝙蝠侠人的角度——成为蝙蝠侠并不是拯救城市的唯一方法；从普通人的角度——人们可能会因为恐惧成为罪恶的爪牙，但是当真正被逼入绝境，即使是普通人也会觉醒；从反派的角度——为了贯彻自己的理念，为了纯粹的犯罪，为了复仇以及完成父亲/师傅未完成的目标。</p>
<p>三部电影，既有深度，也保持了商业片应该具有的震撼的大场面，精彩的故事情节，以及蝙蝠侠的个人英雄主义。尽管每一部都差不多有两个半小时，但是每一部的节奏都把握得很好，完全不会觉得过于冗长。真的值得一看！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《蝙蝠侠》黑暗骑士三部曲&quot;&gt;&lt;a href=&quot;#《蝙蝠侠》黑暗骑士三部曲&quot; class=&quot;headerlink&quot; title=&quot;《蝙蝠侠》黑暗骑士三部曲&quot;&gt;&lt;/a&gt;《蝙蝠侠》黑暗骑士三部曲&lt;/h1&gt;&lt;p&gt;在看完黑暗骑士之后，我又决定把剩下的两部看完，在看完整个三部
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="蝙蝠侠" scheme="https://blog.patrickcty.cc/tags/%E8%9D%99%E8%9D%A0%E4%BE%A0/"/>
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>再次理解Flask中RESTfulAPI</title>
    <link href="https://blog.patrickcty.cc/2017/08/10/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%ADRESTfulAPI/"/>
    <id>https://blog.patrickcty.cc/2017/08/10/再次理解Flask中RESTfulAPI/</id>
    <published>2017-08-10T07:40:22.000Z</published>
    <updated>2017-08-10T07:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中-RESTful-API"><a href="#再次理解-Flask-中-RESTful-API" class="headerlink" title="再次理解 Flask 中 RESTful API"></a>再次理解 Flask 中 RESTful API</h1><p>用 Flask 构建 RESTful 有两种方法，一种是狗书中用到的方法，把视图“包装”成 API —— 视图函数完成 API 所需要的功能，但最后返回的不再是一个 HTML 文件，而是由所需要的数据构成的 JSON。</p>
<p>而另一种方法就是使用 flask-restful 扩展来构建 API 了，利用专有的类来作为 REST 的资源部分，通过资源类的不同方法来处理不同的 http 请求，最后以 JSON 格式返回数据，具体步骤如下：</p>
<ul>
<li><p>初始化扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Api</div><div class="line"></div><div class="line">rest_api = Api()</div></pre></td></tr></table></figure>
</li>
<li><p>自定义资源类以及相应的请求方法（对应了一个路由）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Resource</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    # 如果用没有定义的请求方法访问则会返回 405 错误</div><div class="line">    def get(self):</div><div class="line">        pass</div><div class="line">    def post(self):</div><div class="line">        pass</div><div class="line">    def put(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
</li>
<li><p>初始化 API 对象路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from .extensions import rest_api</div><div class="line">from .controller.rest.post import PostApi</div><div class="line"></div><div class="line">def create_app(object_name):</div><div class="line">    ...</div><div class="line">    # 如果是多个路由则要分别绑定</div><div class="line">    rest_api.add_resource(PostApi, &apos;/api/post&apos;, &apos;/api/post/&lt;int:post_id&gt;&apos;)</div><div class="line">    rest_api.add_resource(AnotherApi, &apos;/api/another&apos;)</div><div class="line">    rest_api.init_app(app)</div></pre></td></tr></table></figure>
</li>
<li><p>JSON 化输出格式</p>
</li>
</ul>
<p>JSON 化也同样有两种方法：</p>
<ul>
<li>第一种是使用 flask.jsonify() 把数据手动转换成 JSON 对象再返回。</li>
<li><p>第二种则是使用 field 对象和 mashal_with 函数来进行转换，返回直接返回原来的对象即可。这种方法通过一个由 field 定义的 dict 来说明要转化输出的内容，并且把它传递给 mashal_with 装饰器，最后在返回之前自动转换成相应的 JSON 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">from flask_restful import Resource, fields, mashal_with</div><div class="line"></div><div class="line">nested_tag_fields = &#123;</div><div class="line">    &apos;id&apos;: fields.Integer(),</div><div class="line">    &apos;title&apos;: fields.String()</div><div class="line">&#125;</div><div class="line"></div><div class="line">post_fields = &#123;</div><div class="line">    # 字符串 field，从对象的 .user.username 中取出值作为值</div><div class="line">    &apos;author&apos;: fields.String(attribute=lambda x: x.user.username), </div><div class="line">    &apos;title&apos;: fields.String(),</div><div class="line">    &apos;text&apos;: HTMLField(),  # 自定义 field</div><div class="line">    # list field，转换后成为 JSON list</div><div class="line">    # 内层为一个特殊的 field，是另外一个 JSON 对象，它是用另一个字段对象构成的</div><div class="line">    &apos;tags&apos;: fields.List(fields.Nested(nested_tag_fields)),</div><div class="line">    &apos;publish_time&apos;: fields.DateTime(dt_format=&apos;iso8601&apos;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    @marshal_with(post_fields)  # 对象的属性会根据这个 dict 来转换</div><div class="line">    def get(self, post_id=None):</div><div class="line">        if post_id:</div><div class="line">            post = Post.query.get(post_id)</div><div class="line">            if not post:</div><div class="line">                abort(404)</div><div class="line">            return post  # 返回的 post 的内容已经被转换格式了</div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
<li><p>接收请求参数</p>
</li>
</ul>
<p>定义 parser<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">post_get_parser = reqparse.RequestParser()  # 初始化 parser</div><div class="line">post_get_parser.add_argument(  # 在 parser 中添加参数以及相应规则</div><div class="line">    &apos;page&apos;,</div><div class="line">    type=int,</div><div class="line">    location=[&apos;args&apos;, &apos;header&apos;],</div><div class="line">    required=False</div><div class="line">)</div><div class="line">post_get_parser.add_argument(</div><div class="line">    &apos;user&apos;,</div><div class="line">    type=str,</div><div class="line">    location=[&apos;json&apos;, &apos;args&apos;, &apos;headers&apos;]</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>使用 parser<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from .parsers import post_get_parser</div><div class="line"></div><div class="line">class PostApi(Resource):</div><div class="line">    def get(self, post_id=None):</div><div class="line">        ...</div><div class="line">        # 使用 parser 解析参数</div><div class="line">        # 解析出来的可以像 dict 引用</div><div class="line">        # 例如 args[&apos;user&apos;]</div><div class="line">        args = post_get_parser.parse_args()</div></pre></td></tr></table></figure></p>
<ul>
<li>身份验证</li>
</ul>
<p>使用 access token 来进行身份认证，要完成身份认证要先通过一个 API 来进行登录验证，如果通过就返回 token，之后就根据 token 来进行相应的权限操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># parser 也是要定义的</div><div class="line">class AuthApi(Resource):</div><div class="line">    def post(self):</div><div class="line">        args = user_post_parser.parse_args()</div><div class="line">        user = User.query.filter_by(</div><div class="line">            username=args[&apos;username&apos;]</div><div class="line">        ).one()</div><div class="line"></div><div class="line">        # 检验密码</div><div class="line">        if user.verify_password(args[&apos;password&apos;]):</div><div class="line">            # 通过了才生成令牌</div><div class="line">            s = Serializer(</div><div class="line">                current_app.config[&apos;SECRET_KEY&apos;],</div><div class="line">                expires_in=600</div><div class="line">            )</div><div class="line">            # 返回令牌，注意 dumps 出来的数据是 byte 类型的，要根据编码改成 utf-8 才能成为 JSON 内容</div><div class="line">            return &#123;&quot;token&quot;: s.dumps(&#123;&apos;id&apos;: user.id&#125;).decode(&apos;utf-8&apos;)&#125;</div><div class="line"></div><div class="line">        else:</div><div class="line">            abort(401)</div></pre></td></tr></table></figure>
<p>验证令牌的话在 User 类中添加一个类方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class User(db.Model, UserMixin):</div><div class="line">    ...</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def verify_auth_token(token):</div><div class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;])</div><div class="line"></div><div class="line">        try:</div><div class="line">            data = s.loads(token)</div><div class="line">        except SignatureExpired:</div><div class="line">            return None</div><div class="line">        except BadSignature:</div><div class="line">            return None</div><div class="line">        user = User.query.get(data[&apos;id&apos;])</div><div class="line">        return user</div></pre></td></tr></table></figure></p>
<p>要使用的话就在资源类的方法中调用这个类方法来返回 user 对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中-RESTful-API&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中-RESTful-API&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中 RESTful API&quot;&gt;&lt;/a&gt;再次理解 Flask 中 R
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="REST API" scheme="https://blog.patrickcty.cc/tags/REST-API/"/>
    
  </entry>
  
  <entry>
    <title>再次理解Flask中登录与用户角色</title>
    <link href="https://blog.patrickcty.cc/2017/08/08/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E7%99%BB%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2/"/>
    <id>https://blog.patrickcty.cc/2017/08/08/再次理解Flask中登录与用户角色/</id>
    <published>2017-08-08T12:31:17.000Z</published>
    <updated>2017-08-08T12:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中登录与用户角色"><a href="#再次理解-Flask-中登录与用户角色" class="headerlink" title="再次理解 Flask 中登录与用户角色"></a>再次理解 Flask 中登录与用户角色</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录由以下几个部分构成：</p>
<ul>
<li>填写表单</li>
<li>验证用户信息是否正确</li>
<li>保存登录状态</li>
</ul>
<h3 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h3><p>填写表单这个应该没什么好说的，但是可以让表单更高级——加入验证码。</p>
<p>在这里我是用的 GeeTest。</p>
<p>接入方法：</p>
<ul>
<li>在其官网下载对应语言的 SDK，其中 Python 的 SDK 包括一个 geetest 的包以及一个用来注入到 HTML 中的 js 文件</li>
<li><p>在 HTML 中给验证码留出相应的位置，第一个控标签除就是验证码所在标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;col s12&quot; id=&quot;embed-captcha&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;col s12&quot;&gt;</div><div class="line">    &lt;p id=&quot;wait&quot; class=&quot;show&quot; style=&quot;color: #ee6e73&quot;&gt;正在加载验证码......&lt;/p&gt;</div><div class="line">    &lt;p id=&quot;notice&quot; class=&quot;hide&quot; style=&quot;color: red&quot;&gt;请先拖动验证码到相应位置&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>引入所给 js 文件，并且进行初始化，这部分只用复制下面的结构然后稍微改动即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;js/gt.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">        var handlerEmbed = function (captchaObj) &#123;</div><div class="line">            $(&quot;#embed-submit&quot;).click(function (e) &#123;</div><div class="line">                var validate = captchaObj.getValidate();</div><div class="line">                if (!validate) &#123;</div><div class="line">                    $(&quot;#notice&quot;)[0].className = &quot;show&quot;;</div><div class="line">                    setTimeout(function () &#123;</div><div class="line">                        $(&quot;#notice&quot;)[0].className = &quot;hide&quot;;</div><div class="line">                    &#125;, 2000);</div><div class="line">                    e.preventDefault();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            // 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode</div><div class="line">            captchaObj.appendTo(&quot;#embed-captcha&quot;);</div><div class="line">            captchaObj.onReady(function () &#123;</div><div class="line">                $(&quot;#wait&quot;)[0].className = &quot;hide&quot;;</div><div class="line">            &#125;);</div><div class="line">            // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            // 获取id，challenge，success（是否启用failback）</div><div class="line">            url: &quot;/pc-geetest/register?t=&quot; + (new Date()).getTime(), // 加随机数防止缓存</div><div class="line">            type: &quot;get&quot;,</div><div class="line">            dataType: &quot;json&quot;,</div><div class="line">            success: function (data) &#123;</div><div class="line">                // 使用initGeetest接口</div><div class="line">                // 参数1：配置参数</div><div class="line">                // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件</div><div class="line">                initGeetest(&#123;</div><div class="line">                    gt: data.gt,</div><div class="line">                    challenge: data.challenge,</div><div class="line">                    product: &quot;embed&quot;, // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效</div><div class="line">                    offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注</div><div class="line">                    width: &apos;25%&apos;</div><div class="line">                    // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config</div><div class="line">                &#125;, handlerEmbed);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>验证验证码状态（其实这部分也不用添加，不过添加了能更进一步提升可靠性，具体参阅官方文档）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 这个视图函数必须添加</div><div class="line">@main_blueprint.route(&apos;/pc-geetest/register&apos;, methods=[&apos;GET&apos;])</div><div class="line">def get_pc_captcha():</div><div class="line">    gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">    status = gt.pre_process()</div><div class="line">    session[gt.GT_STATUS_SESSION_KEY] = status</div><div class="line">    response_str = gt.get_response_str()</div><div class="line">    return response_str</div><div class="line"></div><div class="line"></div><div class="line">@main_blueprint.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    form = LoginForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        # 这下面添加了能提升可靠性，也可以不添加</div><div class="line">        gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">        challenge = request.form[gt.FN_CHALLENGE]</div><div class="line">        validate = request.form[gt.FN_VALIDATE]</div><div class="line">        seccode = request.form[gt.FN_SECCODE]</div><div class="line">        status = session[gt.GT_STATUS_SESSION_KEY]</div><div class="line">        if status:</div><div class="line">            result = gt.success_validate(challenge, validate, seccode)</div><div class="line">        else:</div><div class="line">            result = gt.failback_validate(challenge, validate, seccode)</div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证用户信息"><a href="#验证用户信息" class="headerlink" title="验证用户信息"></a>验证用户信息</h3><p>平常我们都是在视图函数中来检验密码是否是正确，但实际上和验证表单内容是否合法一样，这个工作也可以在表单类中完成。</p>
<p>我们在视图函数中通过 form.validate_on_submit 来检查表单是否被成功提交，实际上在返回结果之前我们要先调用 form.validate 函数，也正是在这里面，我们完成对表单内容合法性和密码正确性的检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class LoginForm(FlaskForm):</div><div class="line">    username = StringField(&apos;用户名&apos;, [DataRequired(), Length(max=255)])</div><div class="line">    password = PasswordField(&apos;密码&apos;, [DataRequired()])</div><div class="line">    remember_me = BooleanField(&apos;记住登录状态&apos;)</div><div class="line"></div><div class="line">    def validate(self):  # 在 validate_on_submit 的时候会检查</div><div class="line">        check_validate = super(LoginForm, self).validate()</div><div class="line"></div><div class="line">        if not check_validate:</div><div class="line">            return False</div><div class="line"></div><div class="line">        user = User.query.filter_by(username=self.username.data).first()</div><div class="line">        if not user:</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        if not user.verify_password(self.password.data):</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        return True</div></pre></td></tr></table></figure>
<p>如果出现了错误则只用把它添加到相应表单的 errors 中去，然后就可以在 HTML 中显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;input-field col s12&quot;&gt;</div><div class="line">    &#123;&#123; form.password.label &#125;&#125;</div><div class="line">    &#123;&#123; form.password(class_=&apos;validate&apos;) &#125;&#125;</div><div class="line">    &#123;% if form.password.errors %&#125;</div><div class="line">        &#123;% for e in form.password.errors %&#125;</div><div class="line">            &lt;p class=&quot;help-block alert-danger&quot;&gt;&#123;&#123; e &#125;&#125;&lt;/p&gt;</div><div class="line">        &#123;% endfor %&#125;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="保存登录状态"><a href="#保存登录状态" class="headerlink" title="保存登录状态"></a>保存登录状态</h3><p>最基本的方法当然是使用 session 来保存，然后通过判断 session 是否有相应的信息来检查是否登录处于状态。</p>
<p>比较常用也是进阶的就是使用 flask-login 了。</p>
<p>使用 flask-login 需要根据模块来进行一定的配置：</p>
<ul>
<li>对 User 类实现特定的方法，这里可以通过继承 UserMixin 来简化，但是要注意如果用户 id 的格式和默认的不同则还是要重写 get_id 方法</li>
<li>定义登陆的视图，load_user 函数等<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">login_manger = LoginManager()</div><div class="line">login_manger.login_view = &apos;main.login&apos;</div><div class="line">login_manger.session_protection = &apos;strong&apos;</div><div class="line">login_manger.login_message = &apos;请登录以访问该页面&apos;</div><div class="line">login_manger.login_message_category = &apos;info&apos;</div><div class="line"></div><div class="line"></div><div class="line">@login_manger.user_loader</div><div class="line">def load_user(userid):</div><div class="line">    from .models import User</div><div class="line">    return User.query.get(userid)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><p>要使用用户权限，则要进行用户角色的相应配置，在这里可以使用 flask-principal 模块来对用户权限进行管理。</p>
<p>当然我们要先建立一张表来控制用户和用户角色的多对多关系，在建立数据库之后不要忘记初始化角色表。</p>
<p>flask-principal 的关键名词主要有 Identity，Permission，Need。其中 Identity 和 Permission 都是通过 Need 来实现功能。Need 则是一些 namedtuple（相当于 C 语言中的结构体），包括 method 和 value 两个属性，定义了每种身份可以干什么。</p>
<p>例如 UserNeed 的 method 默认则是 id，key 则应该传入对应用户的 id 值，而 RoleNeed 的 method 的默认值则是 role，key 的默认值应该是 role 的名称。其中 UserNeed 和 RoleNeed 是通过 partical 固定了 Need 的一个参数。点击查看 <a href="http://www.jb51.net/article/87059.htm" target="_blank" rel="external">nametuple</a> 和 <a href="http://www.wklken.me/posts/2013/08/18/python-extra-functools.html" target="_blank" rel="external">partical</a> 用法。</p>
<p>Identity 是通过 user.id 来进行初始化的，然后此时会自动调用自己定义的初始化函数把需要添加的 Need 添加进这个 Identity 中。</p>
<p>在 __init__.py 中定义这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@identity_loaded.connect_via(app)</div><div class="line">def on_identity_loaded(sender, identity):</div><div class="line">    identity.user = current_user</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;id&apos;):</div><div class="line">        identity.provides.add(UserNeed(current_user.id))</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;roles&apos;):</div><div class="line">        for role in current_user.roles:</div><div class="line">            identity.provides.add(RoleNeed(role.name))</div></pre></td></tr></table></figure></p>
<p>而当用户登录登出时 Identity 应该发生改变，此时应该调用 identity_changed 方法来发送信号，此时就会调用 on_identity_loaded 函数来进行新 Identity 的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">identity_changed.send(</div><div class="line">    current_app._get_current_object(),</div><div class="line">    identity=Identity(user.id)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>而 Permission 则是通过 Need 来进行初始化，这些 Need 就表示当前权限所需的角色，只有满足了相应的角色才能达到相应权限。</p>
<p>初始化 Permission<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div></pre></td></tr></table></figure></p>
<p>使用 Permission 的方法：</p>
<ul>
<li><p>使用初始化权限的装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@login_required</div><div class="line">@poster_permission.require(http_exception=403)</div><div class="line">def edit(id):</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
<li><p>使用 Permission.can() 来判断是否符合权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">permission = Permission(UserNeed(post.user.id))</div><div class="line"></div><div class="line"># 发布者和管理员都有权限</div><div class="line">if permission.can() or admin_permission.can():</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中登录与用户角色&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中登录与用户角色&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中登录与用户角色&quot;&gt;&lt;/a&gt;再次理解 Flask 中登录与用户角色&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>《卑鄙的我3》</title>
    <link href="https://blog.patrickcty.cc/2017/08/06/%E3%80%8A%E5%8D%91%E9%84%99%E7%9A%84%E6%88%913%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/06/《卑鄙的我3》/</id>
    <published>2017-08-06T12:26:34.000Z</published>
    <updated>2017-08-06T12:29:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《卑鄙的我-3》"><a href="#《卑鄙的我-3》" class="headerlink" title="《卑鄙的我 3》"></a>《卑鄙的我 3》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>又是一部新的卑鄙的我，当它上映的时候我就决定去看看，一是因为小黄人，再者则是格鲁在前作中给人的印象太深刻。</p>
<p>虽然在国内这部电影的名字被翻译成了神偷奶爸，但是我还是更愿意称它为卑鄙的我，但是当卑鄙的我不再卑鄙，这部电影又是否保留着原来的惊喜呢？</p>
<p>在刚开始看电影的时候我就有一种强烈的看过的感觉，原来是很久之前看的预告片，但回想起来看了预告片之后，正片反而没什么惊喜可言了……</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于上面的问题，答案是没有惊喜。在这一部里，格鲁已经从良，并因为任务失败被赶出了反恶人联盟。而此时格鲁则像一个遭遇了失业危机的中年男人，完全没有了作为一个反派的那种个性十足的感觉。</p>
<p>因为家庭元素的发展，特别是露西的出现，使得格鲁失去了重新成为坏人的可能，所以这一部的发展，也完全被这样的条件所限制住。但编剧为了冲破这样的限制，又让格鲁在他孪生弟弟面前演了一次坏人，不过这也无力回天，因为已经没有了坏人的灵魂，所以这部分注定不会那么精彩。</p>
<p>而作为本片的一大看点，小黄人的戏份却着实的少，甚至都没能出现在主线中。而小黄人的出走，似乎是编剧自己在吐槽格鲁从良这一设定。不过小黄人出现的地方还是保持了之前萌萌的风格，也算是本片为数不多的亮点了吧。</p>
<p>而露西和格鲁的女儿们的戏份简直可有可无，格鲁的女儿也没有把第一二部时的的萌萌的感觉再表现出来，它们的出场，似乎只是为了把时间给拖住，不然片长恐怕就不够了。</p>
<p>至于德鲁，不得不说人和人之间总是有差距 233。他的出场是一个亮点，然而这部分在预告片里面已经播出了，这就进一步减小了戏剧性……不过他的耍宝的风格还是带来了不少的欢乐，也正是有了他，才让格鲁的行动不那么轻松无趣，也让剧情不那么沉闷。我倒是很期待他在后作中和小黄人们一起四处做坏事，只是不知道他的技巧会不会有所长进 233，不然就 GG 了 233。至于德鲁的话，还是让他在家享受天伦之乐吧 233。</p>
<p>卑鄙的我系列其实到第二部就应该算作结束了，不过只要小黄人在，就不用担心没有故事可讲，期待小黄人大眼萌的续作～</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>7/10.</p>
<p>小黄人依旧精彩，但是德鲁已经失去了之前的魅力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《卑鄙的我-3》&quot;&gt;&lt;a href=&quot;#《卑鄙的我-3》&quot; class=&quot;headerlink&quot; title=&quot;《卑鄙的我 3》&quot;&gt;&lt;/a&gt;《卑鄙的我 3》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="小黄人" scheme="https://blog.patrickcty.cc/tags/%E5%B0%8F%E9%BB%84%E4%BA%BA/"/>
    
      <category term="卑鄙的我" scheme="https://blog.patrickcty.cc/tags/%E5%8D%91%E9%84%99%E7%9A%84%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>《蝙蝠侠：黑暗骑士》</title>
    <link href="https://blog.patrickcty.cc/2017/08/05/%E3%80%8A%E8%9D%99%E8%9D%A0%E4%BE%A0%EF%BC%9A%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/05/《蝙蝠侠：黑暗骑士》/</id>
    <published>2017-08-05T03:35:13.000Z</published>
    <updated>2017-08-05T03:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蝙蝠侠：黑暗骑士》"><a href="#《蝙蝠侠：黑暗骑士》" class="headerlink" title="《蝙蝠侠：黑暗骑士》"></a>《蝙蝠侠：黑暗骑士》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>都说诺兰是鬼才导演，这话真的不夸张。从我最早看的《蝙蝠侠：黑暗骑士的崛起》（那时候看的还是枪版，虽然画面模模糊糊，不过剧情真的感觉很不错，特别是蝙蝠侠在谷底挣扎的情景。不过因为年代久远，影片剧情都记不太清了，因此决定以后再刷一遍～），到之后看的《致命魔术》（当时真的感觉剧情碉堡了，不过因为是在学校看的，所以剧情可能有的地方错过了，同样决定再刷一遍～），再到之后看的《星际穿越》（这部充满物理知识的科幻片对于我这个理科男真的十分有吸引力，剧情也一如既往的神～），再就是之后看的《记忆碎片》（也是一部神片，拍摄手法真的是无敌，看完之后还是一脸懵逼，最终还是根据影评才梳理清楚了剧情 233），他的每一部电影都有不同的魔力，却又都有共同点，那就是剧情精彩，令人回味。</p>
<p>这晚我又十分想看电影，但又苦于近期没什么好看的电影，于是在豆瓣 Top 250 上寻找，看到了这一部之后我就知道我想看的是什么了。同时这一部是小丑加持，人们都说小丑塑造了反派的巅峰，之前小丑扮演者去世周年的时候还引发了一阵朋友圈悼念狂潮，这样的电影，当然要好好看一看～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>蝙蝠侠电影历来都是比较黑暗的，蝙蝠侠所在的城市高谭市给人的印象也总是充满了犯罪，即使有了蝙蝠侠的存在。而在本部电影中充满正义感的检察官哈维·登特的登场，使得蝙蝠侠的任务变得轻松起来。但是这个时候小丑出现了，小丑和蝙蝠侠就好像是正义和邪恶的两个极端。蝙蝠侠在现实生活中是一个亿万富翁，因此他成为蝙蝠侠的目的不是为了金钱和名誉，而是为了自己贯彻的理念，而类似的是，小丑嫌弃犯罪狂潮，也不是为了金钱地位，而是纯粹为了报复社会，让社会陷入混乱。也正是因为有了蝙蝠侠的映衬，小丑的形象才会这么丰满，但小丑也正是抓住了蝙蝠侠的弱点，才能如此肆无忌惮。</p>
<p>小丑是一个精通犯罪学的人，他能在一次次的行动中把所有人都戏耍得团团转，无论是各个黑帮大佬，还是警察局的各位，甚至连民众舆论以及蝙蝠侠都被他戏耍。从他第一次登场抢劫银行的情景就能察觉到，他抓住了同伙贪婪的心理，让他们除掉会分走自己钱的同伙，从而使受益者只有他一个。</p>
<p>小丑强就强大在他强大的威慑能力，他通过蝙蝠侠威慑了那一群黑帮大佬，使他们能与自己合作。而他通过同样的手段威慑了法官，警察局长他们身边的人，又用法官和局长的死亡进一步威慑了正义和群众。而他又通过“不交出蝙蝠侠则每天杀一个人”成功地把矛盾引向了蝙蝠侠，一瞬间保卫城市的黑暗骑士变成了威胁他们生存的存在。</p>
<p>此时还有两个关键，一个是哈维，一个是瑞秋。哈维是新上任到高谭市的白色骑士，是光明中的正义的象征，他为了正义不惧死亡，但这样的他实际上也并不是绝对正义，而“双面人”的称号也正是因为他的一些和正面形象完全不同的动作而形成的，这从他用私刑来逼供刺杀市长的犯人可以窥见——尽管硬币的两面都是正面，也就是说他并不会真的杀掉犯人。只是在这时他的另一面在外部环境的影响下控制得很好。</p>
<p>而小丑说过：“疯狂与混乱本身拥有着强大的引力。有时需要的只是轻轻一推。”，小丑要做的，就是轻轻地推动，让正义的象征哈维和蝙蝠侠堕入黑暗，那么他的目的就完美达到了。</p>
<p>故事真正的高潮是在刺杀市长事件之后蝙蝠侠被逼到了绝境，此时因为小丑的威慑，人民的矛盾都指向了蝙蝠侠，蝙蝠侠只得显出真身来平息民众的恐惧，而崇拜蝙蝠侠的哈维则决定以自己为诱饵，让蝙蝠侠抓住小丑。当蝙蝠侠就要抓到小丑的时候，小丑却利用了蝙蝠侠的底线——不杀人成功让蝙蝠侠没有撞向他而是偏离了方向。</p>
<p>而另一个关键瑞秋则是小丑用来操控蝙蝠侠和哈维的重要工具，因为两人都很爱她，她成为了两人的软肋。小丑就利用了这一点先让蝙蝠侠在哈维和瑞秋之间做出选择，只能拯救一个，而之后故意告诉错误地点的他则让蝙蝠侠没能救出所爱瑞秋而陷入了深深的自责，也让哈维精神崩溃。在这场事故中哈维的半边脸也被烧毁，成为了真正的“双面人”。</p>
<p>尽管小丑很想除掉蝙蝠侠，但是当真正想公布蝙蝠侠身份的人出现后他却要人们杀掉他，否则炸掉医院。当然从小丑的作风来不管结果如何，医院一定会被炸掉，因为他追求的是混乱和黑暗。哈维的黑暗，在和小丑的交谈中被真正触发了，他没有杀掉始作俑者小丑，却向间接害死瑞秋的人寻仇。最终哈维在处决戈登的时候被蝙蝠侠推下楼死亡，蝙蝠侠则背上了罪名，消失了……</p>
<p>小丑成功的地方就是他的疯狂，他用他疯狂却又实际上抓住弱点的行为来操控了其他人，达到自己的目的。而他的伎俩让蝙蝠侠陷入迷茫，让哈维堕入黑暗。虽然他最后败在了蝙蝠侠手上，但是实际上是他赢了。因为他所在意的，从在都不是他的性命，也正是这让他如此疯狂又可怕。而蝙蝠侠最后选择背负罪名，则让小丑胜利的影响降到了最低——民众没有失去战胜黑暗的信心。</p>
<p>而小丑也不是次次都胜利，在炸掉逃生船的社会实验中，最终两艘船都选择了不去按起爆按钮，这次人们没有被小丑威慑住，因为有更深的东西威慑到了他们——人性，按下了按钮则表示你要对另一条船的所有生命负责。因此即使是一开始吵着要按下按钮的秃头大叔，到最后真正有执行权的时候却也不敢下手。而更令我惊讶的是黑帮大佬在拿到起爆器之后居然直接将其丢向了窗外，这里真的值得深思。或许善恶之间真的没有那么多界限，所谓的善人，不也吵吵嚷嚷要按照小丑要求处决他人，而所谓的恶人，在最考验人性的地方却又安静了下来做出了令人意想不到的选择。</p>
<p>这部电影对人性的思考是十分深刻的，其中刻画的小丑，蝙蝠侠，哈维都十分成功，而网上的口碑也真的不是吹出来的。不过整体电影有点偏长，也有点过于神化小丑，但这些无伤大雅的小毛病也不应该被过多计较。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>9/10.</p>
<p>是一部值得思考的不一样的商业片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;a href=&quot;#《蝙蝠侠：黑暗骑士》&quot; class=&quot;headerlink&quot; title=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;/a&gt;《蝙蝠侠：黑暗骑士》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;head
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="蝙蝠侠" scheme="https://blog.patrickcty.cc/tags/%E8%9D%99%E8%9D%A0%E4%BE%A0/"/>
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中视图函数的用法</title>
    <link href="https://blog.patrickcty.cc/2017/08/02/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.patrickcty.cc/2017/08/02/再次理解Flask中视图函数的用法/</id>
    <published>2017-08-02T14:24:00.000Z</published>
    <updated>2017-08-02T14:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中视图函数的用法"><a href="#再次理解-Flask-中视图函数的用法" class="headerlink" title="再次理解 Flask 中视图函数的用法"></a>再次理解 Flask 中视图函数的用法</h1><h2 id="使用类描述视图"><a href="#使用类描述视图" class="headerlink" title="使用类描述视图"></a>使用类描述视图</h2><p>在 Flask 应用中，通常是用函数来描述视图的，但是如果多个函数都用到某些通用功能则用类实现视图就非常方便。</p>
<p>多个视图函数都要渲染模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">from flask.views import View</div><div class="line"></div><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">        super(GenericView, self).__init__()</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        page = 1</div><div class="line">        posts = Post.query.order_by(</div><div class="line">            Post.publish_time.desc()</div><div class="line">        ).paginate(page, 10)</div><div class="line">        recent, top_tags = sidebar_data()</div><div class="line"></div><div class="line">        return render_template(</div><div class="line">            self.template,</div><div class="line">            posts=posts,</div><div class="line">            recent=recent,</div><div class="line">            top_tags=top_tags</div><div class="line">        )</div><div class="line"></div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;home.html&apos;</div><div class="line">    )</div><div class="line">)</div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test2&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;index.html&apos;</div><div class="line">    )</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果要使用多种 HTTP 方法，则定义类属性 methods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    methods = [&apos;GET&apos;, &apos;POST&apos;]  # 定义为类属性</div><div class="line">    </div><div class="line">    def __init__(self, template):</div><div class="line">        ...</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        if request.method == &apos;GET&apos;:</div><div class="line">            ...</div><div class="line">        elif request.method == &apos;POST&apos;:</div><div class="line">            ...</div></pre></td></tr></table></figure></p>
<h2 id="使用方法视图"><a href="#使用方法视图" class="headerlink" title="使用方法视图"></a>使用方法视图</h2><p>方法视图允许把每种 HTTP 请求的处理函数写成一个同名的类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from flask.views import MethodView</div><div class="line"></div><div class="line">class UserView(MethodView):</div><div class="line">    def get(self):</div><div class="line">        ...</div><div class="line">    def post(self):</div><div class="line">        ...</div><div class="line">    def put(self):</div><div class="line">        ...</div><div class="line">        </div><div class="line">app.add_url_rule(&apos;/user&apos;, view_func=UserView.as_view(&apos;user&apos;))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中视图函数的用法&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中视图函数的用法&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中视图函数的用法&quot;&gt;&lt;/a&gt;再次理解 Flask 中视图函数的用法&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask-SQLAlchemy 中数据模型之间的关联</title>
    <link href="https://blog.patrickcty.cc/2017/07/29/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask-SQLAlchemy%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94/"/>
    <id>https://blog.patrickcty.cc/2017/07/29/再次理解Flask-SQLAlchemy中数据模型之间的关联/</id>
    <published>2017-07-29T03:07:09.000Z</published>
    <updated>2017-08-10T07:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-SQLAlchemy-中数据模型之间的关联"><a href="#再次理解-Flask-SQLAlchemy-中数据模型之间的关联" class="headerlink" title="再次理解 Flask-SQLAlchemy 中数据模型之间的关联"></a>再次理解 Flask-SQLAlchemy 中数据模型之间的关联</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>Post 表示博客的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Post(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line">    text = db.Column(db.Text())</div><div class="line">    publish_date = db.Column(db.Datetime())</div><div class="line">    # 外键的参数是&apos;表名.主键&apos;</div><div class="line">    # 也可以是类名.主键（不是字符串）</div><div class="line">    user_id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;))  </div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div></pre></td></tr></table></figure></p>
<p>User 表示用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    posts = db.relationship(  # 是一个 list，内容是该作者的所有 post 的对象</div><div class="line">        &apos;Post&apos;,  # Post 此时可能还没定义，所以用字符串作为参数传递</div><div class="line">        backref=&apos;user&apos;,</div><div class="line">        # 查询方式，dynamic 表示动态加载</div><div class="line">        # 这样在加载完 Post 的时候并不立刻加载与其关联的 User</div><div class="line">        # 而是在被使用时才加载</div><div class="line">        lazy=&apos;dynamic&apos; </div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>在一个典型的博客系统中，一篇文章的作者只有一个，而一个作者可能有多篇文章，因此 Post 通过外键与 User 建立了联系，User.id 作为了 Post 表的一列存在了表中。而 User 则使用 db.relationship 来和 ForeignKey 来建立联系。注意 db.relationship 定义的内容并不真的存在于数据库表中，只是存在于 SQLAlchemy 中。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通过在 Post 中指定 user_id 来影响 User.posts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user = User.query.get(1)</div><div class="line">&gt;&gt;&gt; new_post = Post(&apos;Post Title&apos;)</div><div class="line">&gt;&gt;&gt; new_post.user_id = user.id</div><div class="line">&gt;&gt;&gt; db.session.add(new_post)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div><div class="line">&gt;&gt;&gt; user.posts  # 此时新的 post 会被自动添加到 User 表中</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>通过反向引用来影响 User.posts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; second_post = Post(&apos;Second Title&apos;)</div><div class="line">&gt;&gt;&gt; second_post.user = user</div><div class="line">&gt;&gt;&gt; db.session.add(second_post)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div><div class="line">&gt;&gt;&gt; user.posts  # 此时新的 post 也会被自动添加到 User 表中</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>在 relationship 中通过 backref 参数来指定了反向引用，因此在 Post 中只要通过 Post.user 就可以引用对应的 User 内容了，在这里就是通过反向引用来改变了 User.posts 的内容（新绑定了一个 post）</p>
<h3 id="关于-User-posts"><a href="#关于-User-posts" class="headerlink" title="关于 User.posts"></a>关于 User.posts</h3><p>User 中的 posts 字段因为是 dynamic 方式，所以既可以看作列表，也可以看做查询对象（可以在后面使用 filter_by 等）</p>
<p>看作列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user.posts</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>看做查询对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user.posts.order_by(Post.publish_date.desc()).all()</div><div class="line">[&lt;Post &apos;Second Title&apos;&gt;, &lt;Post &apos;Post Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<h3 id="一对多的最后"><a href="#一对多的最后" class="headerlink" title="一对多的最后"></a>一对多的最后</h3><p>因为二者进行了绑定，因此对一个的内容（一般是‘多’的那边）进行更改，另一个就可以马上同步而不用自己手动修改</p>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>一对一和一对多类似，不过在声明 relationship 的时候要传入参数 <code>uselist=False</code></p>
<p>Userinfo 表示没那么重要的数据，对 User 作为补充<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Userinfo(db.Model):</div><div class="line">    id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;), primary_key=True)</div><div class="line">    age = db.Column(db.String(255))</div><div class="line">    introduction = db.Column(db.Text())</div><div class="line">    update_date = db.Column(db.Datetime())</div></pre></td></tr></table></figure></p>
<p>User 表示用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    userinfo = db.relationship(  </div><div class="line">        &apos;Userinfo&apos;,</div><div class="line">        backref=&apos;user&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>一对一的作用主要是副表对主表进行扩展，主表中存放的是相对重要的内容，而副表中存放的是相对没那么重要的内容。副表访问主表数据的方法和一对多相同，但是主表访问附表的方式就多种多样了</p>
<p>通过外键来查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; userinfo = Userinfo.query.get(user.id)</div></pre></td></tr></table></figure></p>
<p>二者建立双向绑定，通过主表反向调用副表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Userinfo(db.Model):</div><div class="line">    id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;), primary_key=True)</div><div class="line">    age = db.Column(db.String(255))</div><div class="line">    introduction = db.Column(db.Text())</div><div class="line">    update_date = db.Column(db.Datetime())</div><div class="line">    user = db.relationship(  </div><div class="line">        &apos;Use&apos;,</div><div class="line">        back_populates=&apos;userinfo&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div><div class="line"></div><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    userinfo = db.relationship(  </div><div class="line">        &apos;Userinfo&apos;,</div><div class="line">        back_populates=&apos;user&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>这里 back_populates 和 backref 意义是相似的，但是 back_populates 必须要在两处都进行说明，这样同时也可以进行双向的反向引用了</p>
<p>因此主表访问附表就可以直接访问了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; userinfo = user.userinfo</div></pre></td></tr></table></figure></p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>数据库模型定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># 直接用 db.Table 来建立表</div><div class="line">tags = db.Table(  # 辅助表，用来建立多对多关系</div><div class="line">    &apos;post_tags&apos;,  # 表名</div><div class="line">    db.Column(&apos;post_id&apos;, db.Integer, db.ForeignKey(&apos;post.id&apos;)),</div><div class="line">    db.Column(&apos;tag_id&apos;, db.Integer, db.ForeignKey(&apos;tag.id&apos;))</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">class Post(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line">    text = db.Column(db.Text())</div><div class="line">    publish_date = db.Column(db.Datetime())</div><div class="line">    user_id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;))</div><div class="line">    tags = db.relationship(  # 声明关系</div><div class="line">        &apos;Tag&apos;,  # 主要是给 Tag 引用</div><div class="line">        secondary=tags,  # 通过 tags 作为中介</div><div class="line">        backref=backref(&apos;posts&apos;, lazy=&apos;dynamic&apos;)</div><div class="line">    )</div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div><div class="line"></div><div class="line"></div><div class="line">class Tag(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div></pre></td></tr></table></figure></p>
<p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; post_one = Post.query.all()[1]</div><div class="line">&gt;&gt;&gt; post_two = Post.query.all()[2]</div><div class="line">&gt;&gt;&gt; tag_one = Tag(&apos;Python&apos;)</div><div class="line">&gt;&gt;&gt; tag_two = Tag(&apos;SQLAlchemy&apos;)</div><div class="line">&gt;&gt;&gt; tag_three = Tag(&apos;Flask&apos;)</div><div class="line">&gt;&gt;&gt; post_one.tags = [tag_two]  # 手动创建对应关系</div><div class="line">&gt;&gt;&gt; post_two.tags = [tag_one, tag_two, tag_three]</div><div class="line">&gt;&gt;&gt; tag_two.posts  # 反向引用</div><div class="line">[tag_one, tag_two, tag_three]</div><div class="line">&gt;&gt;&gt; db.session.add(post_one)  # 似乎并没有 add tag 到 session</div><div class="line">&gt;&gt;&gt; db.session.add(post_two)  # 因为通过回话自动保存了标签</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p>
<p>在所对多关系中，backref 也变成了 list，可以通过 list 的 append 方法来添加文章到标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tag_one.posts.append(post_one)</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;] </div><div class="line">&gt;&gt; post_one.tags</div><div class="line">[&lt;Tag &apos;SQLAlchemy&apos;&gt;, &lt;Tag &apos;Python&apos;&gt;]</div><div class="line">&gt;&gt;&gt; db.session.add(tag)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果要重写 <strong>init</strong> 方法的话则要注意使用的变量是否已经初始化了，没有初始化的话可能变量值为 None，此时调用就会报错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-SQLAlchemy-中数据模型之间的关联&quot;&gt;&lt;a href=&quot;#再次理解-Flask-SQLAlchemy-中数据模型之间的关联&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask-SQLAlchemy 中数据模型之
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
      <category term="SQLAlchemy" scheme="https://blog.patrickcty.cc/tags/SQLAlchemy/"/>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习（一）</title>
    <link href="https://blog.patrickcty.cc/2017/07/20/Docker%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/07/20/Docker学习（一）/</id>
    <published>2017-07-20T03:03:40.000Z</published>
    <updated>2017-07-25T02:56:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-学习（一）"><a href="#Docker-学习（一）" class="headerlink" title="Docker 学习（一）"></a>Docker 学习（一）</h1><h2 id="理解-Docker"><a href="#理解-Docker" class="headerlink" title="理解 Docker"></a>理解 Docker</h2><p>基本概念：</p>
<ul>
<li>镜像</li>
<li>容器</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>是一个特殊的文件系统，包含了容器运行时的依赖。</p>
<p>镜像是一层层构建的，前一层是后一层的基础。每一层构建完就不会再改变，后一层删除前一层文件的操作会保留文件，只是该文件会标记为已删除。</p>
<p>因为上面所说的特性，镜像是只读的。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像的实例，容器运行时在镜像层上创建一个存储层，该存储层会在容器消亡时消亡，该层中的数据也不会保留。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="不使用-sudo-命令执行-Docker"><a href="#不使用-sudo-命令执行-Docker" class="headerlink" title="不使用 sudo 命令执行 Docker"></a>不使用 sudo 命令执行 Docker</h3><p>因为 Docker 运行时需要特殊权限，所以默认执行命令都必须在前面加上 sudo。</p>
<p>不使用 sudo 命令执行 Docker 方法：把用户放进 docker 用户组里面（等同于赋予它 root 权限）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo useradd -aG docker $USER  # 还要注销重新登录</div><div class="line">sudo service docker restart  # 重启服务</div></pre></td></tr></table></figure>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>获取某个容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>查看容器文件改变情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>查看容器日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>删除容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>列出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker ps        # 查看运行中的容器</div><div class="line">docker ps -a     # 查看所有容器</div><div class="line">docker ps -aq    # 查看所有容器，只显示容器 ID</div></pre></td></tr></table></figure></p>
<p>删除镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi 镜像名/镜像 ID</div></pre></td></tr></table></figure></p>
<p>下载/上传镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull/push 镜像名[:TAG|@DIGEST]</div></pre></td></tr></table></figure></p>
<p>创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run</div></pre></td></tr></table></figure></p>
<h2 id="通过-Dockerfile-定制镜像"><a href="#通过-Dockerfile-定制镜像" class="headerlink" title="通过 Dockerfile 定制镜像"></a>通过 Dockerfile 定制镜像</h2><p><code>docker commit</code> 命令可以通过容器产生镜像，但是要重复操作产生多个相同镜像却不方便，此时使用 Dockerfile 能解决这个问题。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<h3 id="使用-docker-build-来构建镜像"><a href="#使用-docker-build-来构建镜像" class="headerlink" title="使用 docker build 来构建镜像"></a>使用 <code>docker build</code> 来构建镜像</h3><p>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</div></pre></td></tr></table></figure></p>
<p>其中常用到 -t 选项来指定构建出的镜像的名称。</p>
<p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>一般新建一个空文件夹并以该文件夹作为上下文路径来构建镜像。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t myimage .</div></pre></td></tr></table></figure></p>
<p>这里的“.“就是上下文路径，表示当前文件夹。</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>定制镜像一定要以一个镜像为基础，而 FROM 指令就是指定基础镜像，并且这是最基本的指令，并且必须是第一条指令。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure>
<ul>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li>
</ul>
<p>注：因为每个 Dockerfile 的指令都会新建一层，而层数多并不是一件有意义的事情，因此应该用 &amp;&amp; 连接多个命令在一条 RUN 指令里面执行，并且在每一层构建的最后删除掉无关文件。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure></p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p>
<p>格式：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p>
<p>比如 &lt;源路径&gt; 可以是一个 URL。</p>
<p>在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>例如 ubuntu 镜像默认的 CMD 就是 <code>/bin/bash</code>。</p>
<p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code></li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>（在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数）</li>
</ul>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>格式和 CMD 相同。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，但当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>环境变量可以在其他的 Dockerfile 指令里面展开。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;</code>。</p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p>一般用于维护多个镜像，这样升级只用重新构建镜像即可，而不用修改每个的 Dockerfile</p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker——从入门到实践</a><br>Docker 开发指南——O’REILLY</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-学习（一）&quot;&gt;&lt;a href=&quot;#Docker-学习（一）&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习（一）&quot;&gt;&lt;/a&gt;Docker 学习（一）&lt;/h1&gt;&lt;h2 id=&quot;理解-Docker&quot;&gt;&lt;a href=&quot;#理解-D
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《第一行代码—— Android 休闲学习（一）</title>
    <link href="https://blog.patrickcty.cc/2017/07/17/Android1/"/>
    <id>https://blog.patrickcty.cc/2017/07/17/Android1/</id>
    <published>2017-07-17T13:43:12.000Z</published>
    <updated>2017-07-26T01:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《第一行代码》——-Android-休闲学习（一）"><a href="#《第一行代码》——-Android-休闲学习（一）" class="headerlink" title="《第一行代码》—— Android 休闲学习（一）"></a>《第一行代码》—— Android 休闲学习（一）</h1><h2 id="日志工具使用"><a href="#日志工具使用" class="headerlink" title="日志工具使用"></a>日志工具使用</h2><p>先用<code>import android.util.Log;</code>来导入所需库函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Log.v()  // verbose</div><div class="line">Log.d()  // debug</div><div class="line">Log.i()  // info</div><div class="line">Log.w()  // waring</div><div class="line">Log.e()  // error</div></pre></td></tr></table></figure>
<p>日志的等级从上到下依次增高。</p>
<p>日志样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">07-16 19:37:03.494 15142-15142/com.example.patrick.activitytest D/FirstActivity: Hello FirstActivity</div></pre></td></tr></table></figure></p>
<p>其中<code>FirstActivity</code>是 tag，为了方便过滤日志，<code>Hello FirstActivity</code>是日志的内容</p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// tag 一般传入当前的类名</div><div class="line">Log.d(tag, msg);</div></pre></td></tr></table></figure></p>
<p>小技巧</p>
<blockquote>
<p>在 onCreate() 方法的外面输入 logt，然后按下 Tab 键，这时候就会以当前的类名作为值自动生成一个 TAG 常量<br>例如：private static final String TAG = “HelloWorldActivity”;</p>
</blockquote>
<h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><p>活动是一种可以包含用户界面的组件，主要用于和用户进行交互。我们看到的页面就是活动。</p>
<h3 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h3><ul>
<li>创建活动：在 /ActivityTest/app/src/main/java/com.example.patrick.activitytest 下创建活动</li>
<li>创建和加载布局（可以自动完成）<ul>
<li>在app/src/main/res 下创建 layout 目录，再在这个目录下创建布局文件</li>
<li>可以在这个文件里面增添元素（要使用的话得在活动中定义动作）</li>
<li>在活动中重写 onCreate 来加载布局，使用 setContentView() </li>
</ul>
</li>
<li>在 AndroidMainfest 文件中注册（自动完成）</li>
<li>配置主活动（一个程序至少要有一个，不然就不能在启动器中看到和打开程序）</li>
</ul>
<h3 id="在活动中使用-Toast"><a href="#在活动中使用-Toast" class="headerlink" title="在活动中使用 Toast"></a>在活动中使用 Toast</h3><p>Toast 是在接近底部的地方弹出的提示</p>
<ul>
<li>触发 Toast（这里是点击按钮触发）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 获取元素，返回值是 View 对象，要下转型成 Button 对象</div><div class="line">Button button1 = (Button) findViewById(R.id.button_1);  </div><div class="line">// 注册监视器，监视点击事件</div><div class="line">button1.setOnClickListener(new View.OnClickListener() &#123;  // 匿名类</div><div class="line">    @Override</div><div class="line">    public void OnClick(View v) &#123;</div><div class="line">        // 通过静态方法创建 Toast 对象并通过 .show() 来使用</div><div class="line">        // 第一个参数是 Toast 的上下文，直接传入活动就可以</div><div class="line">        // 第二个参数就是 Toast 显示的文本</div><div class="line">        // 第三个参数是 Toast 显示的时长</div><div class="line">        Toast.makeText(FirstActivity.this, &quot;You clicked Button 1&quot;,</div><div class="line">            Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>小技巧</p>
<blockquote>
<p>按 Ctrl-O 可以方便地重写方法</p>
</blockquote>
<h3 id="在活动中使用-Menu"><a href="#在活动中使用-Menu" class="headerlink" title="在活动中使用 Menu"></a>在活动中使用 Menu</h3><p>Menu 是页面右上角的三个竖着的小点点。</p>
<p>使用 Menu</p>
<ul>
<li>在 res 目录下新建 menu 文件夹，并且在该目录下创建菜单文件<ul>
<li>在该文件通添加菜单项</li>
<li>android:id 是菜单项的标识符，在活动中用<code>R.id.标识符名</code>来引用</li>
<li>android:title 是菜单的名称（显示在菜单中）</li>
</ul>
</li>
<li>在活动中重写 onCreateOptionsMenu() 方法来初始菜单，可以使用 Ctrl + O 快捷键</li>
<li>定义菜单相应事件，通过重写 onOptionsItemSelected() 方法<ul>
<li>通过 <code>item.getItemId()</code> 来判断点击的是哪个菜单项</li>
</ul>
</li>
</ul>
<h3 id="销毁活动"><a href="#销毁活动" class="headerlink" title="销毁活动"></a>销毁活动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">finish()  // 相当于按返回键</div></pre></td></tr></table></figure>
<h3 id="使用-Intent-切换活动"><a href="#使用-Intent-切换活动" class="headerlink" title="使用 Intent 切换活动"></a>使用 Intent 切换活动</h3><h4 id="显式-Intent"><a href="#显式-Intent" class="headerlink" title="显式 Intent"></a>显式 Intent</h4><p>直接指明了要切换的目的活动。</p>
<p>源活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 第一个参数是启动活动的上下文</div><div class="line">// 第二个参数是要启动的目标活动的类</div><div class="line">Intent intent = new Intent(FirstAcitity.this, SecondActivity.class);</div><div class="line">// 用来启动活动</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h4 id="隐式-Intent"><a href="#隐式-Intent" class="headerlink" title="隐式 Intent"></a>隐式 Intent</h4><p>并不明确指明要启动的活动，而是指定了更为抽象的 action 和 category 等信息，然后交由系统来启动目的活动，可以是同一个应用的活动，也可以是其他应用的活动。</p>
<p>使用方法：</p>
<ul>
<li>在 AndroidManifest.xml 文件中指明 action 与 category</li>
<li>在活动中使用 Intent<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 只有当二者的 action 和 category 完全匹配才能响应 Intent</div><div class="line">// 隐式 Intent 使用 action 来初始化实例的</div><div class="line">Intent intent = new Intent(&quot;和前面指明的 action 内容相同&quot;);</div><div class="line">intent.addCategory(&quot;和前面指明的 category 内容相同&quot;);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="隐式-Intent-Plus"><a href="#隐式-Intent-Plus" class="headerlink" title="隐式 Intent Plus"></a>隐式 Intent Plus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Intent.ACTION_VIEW 是一个 Android 内置的动作</div><div class="line">// 对应的 xml 文件中的值是 android.intent.category.VIEW</div><div class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</div><div class="line">// setData() 接受一个 Uri 对象，指定操作的数据（注意不是 Url）</div><div class="line">intent.setData(Uri.parse(&quot;https://blog.patrickcty.cc&quot;));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<h4 id="用-Intent-向下一个活动传递信息"><a href="#用-Intent-向下一个活动传递信息" class="headerlink" title="用 Intent 向下一个活动传递信息"></a>用 Intent 向下一个活动传递信息</h4><p>使用 putExtra() 发送数据，在目的活动中使用 getStringExtra() 取出数据</p>
<p>源活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String data = &quot;Hello SecondActivity&quot;;</div><div class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</div><div class="line">// putExtra 接受两个参数，第一个参数是 key，用来在目的活动取出数据</div><div class="line">// 第二个参数是数据</div><div class="line">intent.putExtra(&quot;extra_data&quot;, data);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>目的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = getIntent();</div><div class="line">// 通过 key 来取出数据并保存在 data 里面</div><div class="line">String data = intent.getStringExtra(&quot;extra_data&quot;);</div></pre></td></tr></table></figure></p>
<h4 id="用-Intent-返回数据给上一个活动"><a href="#用-Intent-返回数据给上一个活动" class="headerlink" title="用 Intent 返回数据给上一个活动"></a>用 Intent 返回数据给上一个活动</h4><p>startActivityForResult() 启动活动并且在活动销毁的时候能够返回结果给上一个活动。</p>
<p>源活动按钮的点击事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</div><div class="line">// 第二个参数是请求码，唯一，用来区分不同请求</div><div class="line">startActivityForResult(intent, 1);</div></pre></td></tr></table></figure></p>
<p>目的活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;);</div><div class="line">// 专门用来向上一个活动返回数据</div><div class="line">// 第一个参数是处理结果，第二个参数是 Intent</div><div class="line">setResult(RESULT_OK, intent);</div><div class="line">finish();</div></pre></td></tr></table></figure></p>
<p>源活动接受数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// requestCode 就是上面唯一的请求码</div><div class="line">// resultCode 就是处理结果</div><div class="line">@Override</div><div class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">    switch (requestCode) &#123;</div><div class="line">        case 1:</div><div class="line">            if (resultCode == RESULT_OK) &#123;</div><div class="line">                String returnedData = data.getStringExtra(&quot;data_return&quot;);</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《第一行代码》——-Android-休闲学习（一）&quot;&gt;&lt;a href=&quot;#《第一行代码》——-Android-休闲学习（一）&quot; class=&quot;headerlink&quot; title=&quot;《第一行代码》—— Android 休闲学习（一）&quot;&gt;&lt;/a&gt;《第一行代码》—— A
    
    </summary>
    
      <category term="Android" scheme="https://blog.patrickcty.cc/categories/Android/"/>
    
    
      <category term="休闲" scheme="https://blog.patrickcty.cc/tags/%E4%BC%91%E9%97%B2/"/>
    
      <category term="Android" scheme="https://blog.patrickcty.cc/tags/Android/"/>
    
      <category term="菜鸡的自我修养" scheme="https://blog.patrickcty.cc/tags/%E8%8F%9C%E9%B8%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>《一条狗的使命》</title>
    <link href="https://blog.patrickcty.cc/2017/07/10/%E3%80%8A%E4%B8%80%E6%9D%A1%E7%8B%97%E7%9A%84%E4%BD%BF%E5%91%BD%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/07/10/《一条狗的使命》/</id>
    <published>2017-07-10T15:17:31.000Z</published>
    <updated>2017-07-10T15:21:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一条狗的使命》"><a href="#《一条狗的使命》" class="headerlink" title="《一条狗的使命》"></a>《一条狗的使命》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>不得不说这学期的课程太过凶残了，平常两周的复习周就可以把要复习的都复习完了，然后考试周就可以休闲一点了。但是今年的两周复习周基本上都用在复习计组和操作系统上面去了，所以即使是考试周每天考完了也还是要继续留在图书馆“抢救”，所以在看这部电影之前考试周这么久我都没有看过一部电影。</p>
<p>不过因为只剩最后一门了，所以提前了不少时间回寝室了，之后便打开了这部电影～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>影片是以狗为第一人称视角来写的，这个视角给不少地方都增添了笑点，算是一个比较成功的 idea。影片中的狗狗经历了五次转世。其实一开始我是没有意识到是转世的，因为从一开始狗狗被捕，到后来是一只大狗狗在笼子里面，感觉并没有什么不对 233（虽然两次毛的颜色不同）。后来我才意识到了原来是经过了转世。</p>
<p>其中最重要的也是最着力刻画的是第二次转世和地五次转世，但是第二次转世在网上引起的争议也是最大的。</p>
<p>小男孩伊森和妈妈救助了一只被关在车里因为灼热气温而濒死的狗狗并带回了家，而养狗的第一个关键就是获得爸爸的同意。影片似乎是有意把爸爸作为一个大反派来刻画的，从刚进家开始爸爸就不怎么喜欢这只狗，而且爸爸这个人也比较消极，每天因为政治和工作而苦恼，总是一副不高兴的样子。直到领导来家里吃饭的尴尬遭遇，狗毁掉了爸爸升职的机会，爸爸对狗的愤怒升到了顶峰并彻底爆发。</p>
<p>但在这之前，伊森和贝利的接球配合已经很好了，那个贝利找到的橄榄球也在后面成为了重要的线索，Boss Dog 的名号也叫起来了。有人说这个 Boss Dog 叫得不合适，不能让狗形成自己是老大的念头，不过我对狗是否能理解这个称呼的意思表示怀疑，而且昵称这种东西嘛，只要不是那种侮辱性的，大家都开心就好嘛。</p>
<p>在爸爸升职的机会被毁掉后，伊森进入了高中，成为了橄榄球对的核心成员，而爸爸却显现出了颓废之态，成为了酒鬼，直到一次推搡妈妈被赶出了家门。但在这次冲突之前其实爸爸就有一次也是怒气冲冲地离开了家，口里还怪罪着妈妈花了他的很多钱。其实我个人感觉这个地方表现的很不好，很多人觉得是狗让爸爸变成了这样，但我觉得这样的一次打击应该不至于毁掉一个男人，更何况他是顶级销售员，即使被炒了去其他的公司也未必混不开。从网上的评论可以猜到应该是由于时代原因，推销被逐渐取代，爸爸的工作也因此越来越难做甚至没了，而这样的打击使得原本就比较消极的他彻底堕落，沦为了一个酒鬼。再加上妈妈总是用他很多钱，这样的小事情就引起了夫妻之间的矛盾，使得夫妻之间难以好好沟通，造成了被赶出家门的前因。</p>
<p>对我觉得爸爸这条支线描写得真的是不是很好，内容太过简略，又有一种把人往狗狗毁掉了爸爸的人生这方向带的感觉，另外对于妈妈用很多钱这个地方也很模糊，所以当最后爸爸被赶出家这时候我是真的感觉莫名其妙。不过这部分关于狗狗的描写真的是比较到位，慢慢建立羁绊，并因为狗狗结识了女朋友，过上了幸福快乐的生活。这部分比较偏日常，不过狗狗的作用还是不可忽视的。</p>
<p>直到赢得至关重要的橄榄球决赛之后，伊森成功获得了密歇根大学的全额奖学金。这场比赛爸爸也前来观看了，并在赛后向他“表示祝贺”，只不过说话的语气有些阴阳怪气，与其说是祝贺，不如说是酸溜溜的表达内心的嫉妒。而男主的表现很正常，并不是其他人所说的嫌弃他的酒鬼老爸。而后面男主揍陶德这一部分我觉得也很正常，面对一而再再而三的挑衅，男主选择了反击，只不过对于这种垃圾人最妥当的办法还是不理会，直接离开。不过男主的行为也没有什么过错，至于又拿嫌弃爸爸来说事的，这里嫌弃男主爸爸的是陶德，并不是伊森，而自己爸爸是酒鬼这件事本来就不是什么很光荣应该让所有人都知道的事情，因此说嫌弃爸爸还是有点太过了。</p>
<p>没想到陶德这家伙为了报复半夜来丢烟花到伊森家，烟花烧到了地毯最后点燃了整个家，此时贝利出场叫醒了伊森，伊森又叫醒了妈妈，但是最后火势已经太凶了，他们只能从窗户逃脱。妈妈和狗狗被救了下来，但是伊森却被困在了房子里，最后只好跳下来，却摔断了腿。这个地方我想吐槽的是房子外面不是有很多人么，为什么没人去接住他或者搭把手……这个摔断腿真的感觉是强行的剧情需要了。</p>
<p>我一开始还以为这个腿伤并不严重，应该只要好好养伤还是可以恢复到原来的水平的，没想到这个伤直接葬送了他的职业生涯，他只得去家附近的农业大学就读，继承农场。而在养伤的时候他和他女朋友提出了分手，当时我对这个地方的理解是他和她一起上大学的梦想破灭了，而他觉得现在这样会拖累她，于是为了她好就选择了分手。这个从是他之后的想念推测的，但是没想到最后一部分居然说是因为当时受到的打击太大太颓废才分手的……这个其实也可以理解，毕竟密歇根大学和农业大学的差别还不是一般的大，更关键的是职业生涯的葬送，这是未来被毁灭，从一个可能成为体育明星的未来到只能做一个农场主的未来的落差确实十分巨大，不过这样总感觉有些奇怪……最遗憾的是女主就这样离开了，不过生活其实就是这样的，很多时候冲动会造成终生的遗憾，其实男主并不是真的不爱女主了，只是一是冲动。</p>
<p>之后男主去上大学的时候就上演了一幕感人了狗狗万里追车情节，这部分拍得还是很赞的。但是从这之后狗狗就开始快速衰老起来了，再也没有精力四处跑动，甚至连吃饭都没有力气，在去世之前，他也终于见到了伊森。</p>
<p>第三次转世他是成为了一条警犬，不过连性别都转换了 233。这里的篇幅没有前面的多，不过对这短暂的一生的刻画是本片中争议最少的一部分。这一生的使命就和上一生的完全不同了，每天不再是无忧无虑地玩耍了，而要去做警犬应该做的事情。而在这方面，她把她的使命履行得很好。</p>
<p>除此之外，在晚上她也表现出了她的善解人意，她看出了主人内心的痛苦，她在用自己的方式给予主人慰藉，而主人也逐渐接收到了，对她的感情也越来越深厚。而好景不长，在一次追捕坏人的任务中，当她成功救起了被推下水库的女孩之后，她又冲了出来阻止了坏人的射击，却被子弹击中，不幸身亡。</p>
<p>这一生虽然短暂，但使命感却十足，她也很好完成了自己的使命。</p>
<p>接着第四次转世成为了一只柯基，被一个宅女所收养。而正是通过他对另一只狗的喜爱，促使了一段姻缘。这部分狗与主人的默契非常让人印象深刻。比较虐心的是他所爱先一步离他去，而她一直以来活着的意义就是为了保护她。失去了所爱的他也在之后离去了。</p>
<p>而第五次转世就没那么好了，他被一个嬉皮士女士收留，而她老公不让狗狗进家，于是他每天都被锁在了院子里，直到女生再也养不了，他被抛弃。但是抛弃对他来说或许是一件更好的事情，他不仅获得了自由，也远离了令狗难受的城镇。机缘巧合之下，他又闻到了汉娜的味道，他又回到了伊森的身边，但此时的伊森年龄已经不年轻了。因为他已不再是贝利的样子，因此伊森一开始也不是很愿意收留他，但命运使然，伊森还是收留了他。</p>
<p>而机智的贝利又根据之前闻到的气味——汉娜女儿的气味，找到了汉娜。就这样多年之后两人重新相逢，此时汉娜丈夫已经去世，伊森没有让遗憾继续下去，在单身这么多年之后伊森终于又挽回了爱情，终止了遗憾～虽然这里很圆满，不过还是得为伊森感到遗憾……</p>
<p>之后贝利又在仓库里找到了那个充满回忆的球，并且用那个熟悉的接球姿势让伊森知道 Boss Dog 又回来了～这部分真的让人看得十分激动啊～</p>
<p>本来看到前面我就以为伊森这部分已经结束了，没想到最后居然是以这样的方式来给他们的故事画上了一个句号。我想最后伊森一定想说：“终于等到你，还好我没放弃。”。虽然有些刻意，不过结局还是让人感到温暖的，就像整部电影的旋律一样。</p>
<p>狗的使命是什么呢？这或许不重要，只要自己快乐，身边人快乐就好。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10.</p>
<p>这部电影剧情还是不错的，不过有一些地方感觉有一些刻意。但是转世这个设定让人眼前一亮，特别是兜兜转转之后又回到了伊森的身边这里还是很让人惊喜的。总体还是一步让人感动并且欢乐的影片，在考试周也给予了我一些慰藉～还是值得推荐的～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《一条狗的使命》&quot;&gt;&lt;a href=&quot;#《一条狗的使命》&quot; class=&quot;headerlink&quot; title=&quot;《一条狗的使命》&quot;&gt;&lt;/a&gt;《一条狗的使命》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="宠物电影" scheme="https://blog.patrickcty.cc/tags/%E5%AE%A0%E7%89%A9%E7%94%B5%E5%BD%B1/"/>
    
      <category term="感动" scheme="https://blog.patrickcty.cc/tags/%E6%84%9F%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>《神奇女侠》</title>
    <link href="https://blog.patrickcty.cc/2017/06/28/%E3%80%8A%E7%A5%9E%E5%A5%87%E5%A5%B3%E4%BE%A0%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/06/28/《神奇女侠》/</id>
    <published>2017-06-28T12:21:20.000Z</published>
    <updated>2017-06-28T12:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《神奇女侠》"><a href="#《神奇女侠》" class="headerlink" title="《神奇女侠》"></a>《神奇女侠》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影也是在很久之前看的，因为种种原因也一直没能写点什么。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次看到这个角色是在前两年的《蝙蝠侠大战超人》，在他们打得最激烈的时候，神奇女侠及时出现阻止了他们的内战，当时看到这个角色就觉得眼前一亮～</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;神奇女侠的扮演者是盖尔加朵，而盖尔加朵的话也不是一个生面孔了，她所出演的速度与激情的 Gisele 也让人觉得十分有灵性，当她离开主角小分队的时候我真的觉得十分遗憾。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再加上这部电影在网上也收获了不少好评，于是找到时间之后我就和女票一起在吃 CHIZZA 之后顺便看了～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部 DC 的电影和漫威的《美国队长 1》在不少方面都有相似的地方。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的故事都是发生在战争时期，神奇女侠是在一战，美国队长是在二战，二人都是从“初出茅庐”的迷茫到最后的认清自我有所作为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为神奇女侠是在一个平静安详的地方长大，没见识过战争，也没见识过各种各样的人，再加上她听着神话长大，因此她以为只要能打败阿瑞斯就能拯救人类平息战争，但当她打败“阿瑞斯”——鲁登道夫的时候，她发现一切并没有任何改变，这时候的她陷入了无尽的迷茫。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里，我觉得剧情还是很优秀的。在这之前尽管她的同伴都认为她的目标比较不切实际，但他们都没有完全地否定她的观念，而是用他们自己的行动展示给她看，让她自己感受这个世界。但是当之后所有人都认为是虚构的阿瑞斯真正的出现的时候，剧情就突然就变得神了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也正是在与这个正牌的阿瑞斯战斗的过程中，她慢慢找到了自我，也打败了阿瑞斯，而在场的人们在亲眼目睹这场浩大的战斗后也丧失了战斗的欲望，这也算是“实现目标”了吧。然而此时一直保护着她不受这个世界的伤害并且教给她爱的那个男人却在她搞懂爱情之前已经永远的离开了……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整部电影情节的把控还是很好的，看的时候完全不会觉得描写背景的时候太过无趣，也不会觉得打斗空洞，莫名其妙，整体的观影感觉十分舒服，让人意犹未尽。其实开头是承接着之前的《蝙蝠侠大战超人》，那张照片也是蝙蝠侠派人送过来的，这不得不让人期待后续的正义联盟了，当他们再次相遇，又会有什么有趣的事情发生呢？这么多年过去了，神奇女侠究竟又有什么不同呢？真的非常让人期待啊。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.5/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剧情流畅，人物塑造很到位，女侠也很漂亮～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《神奇女侠》&quot;&gt;&lt;a href=&quot;#《神奇女侠》&quot; class=&quot;headerlink&quot; title=&quot;《神奇女侠》&quot;&gt;&lt;/a&gt;《神奇女侠》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="超级英雄" scheme="https://blog.patrickcty.cc/tags/%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84/"/>
    
      <category term="神奇女侠" scheme="https://blog.patrickcty.cc/tags/%E7%A5%9E%E5%A5%87%E5%A5%B3%E4%BE%A0/"/>
    
  </entry>
  
  <entry>
    <title>《加勒比海盗 5：死无对证》</title>
    <link href="https://blog.patrickcty.cc/2017/06/20/%E3%80%8A%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%975%EF%BC%9A%E6%AD%BB%E6%97%A0%E5%AF%B9%E8%AF%81%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/06/20/《加勒比海盗5：死无对证》/</id>
    <published>2017-06-20T00:20:54.000Z</published>
    <updated>2017-06-20T00:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《加勒比海盗-5：死无对证》"><a href="#《加勒比海盗-5：死无对证》" class="headerlink" title="《加勒比海盗 5：死无对证》"></a>《加勒比海盗 5：死无对证》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影在好久之前就看了，然而一直拖着没有开始写。距离上一部加勒比海盗已经过去六年了，前面的几部我都没有去电影院看，因此当新的一部上映，当我终于可以去大屏幕观看的时候，怎么能不去看？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为过去了这么久，前面几部内容都不记得了，因此在结束之后我还特意去看了看木鱼水心的相应的视频来回顾了一下。看的时候感觉这一部和前面几部关系并不大，但是因为一些地方忘记了，所以在看到有些地方的时候就有些不能理解了，不过现在回顾了之前的剧情，前面的疑惑就得到了解答。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的反派是杰克船长在他的成名之战中打败的萨拉查船长，萨拉查曾经是西班牙海军的神奇船长，以歼灭所有海军为目标。就当他以为击败了最后的海盗的时候却被初出茅庐的杰克使用了一个乾坤大飘逸引诱到了死亡三角区去了，受到了诅咒的他们被困在了其中，只有当杰克放弃了他的罗盘他们才能重见天日，因为罗盘的特性是当它的持有者抛弃掉它的时候，他最大的威胁就会被释放出来。在这段回忆中出现的年轻时候的杰克船长是用 CG 做出来的，效果十分逼真，连我的女票都发出了“他怎么能演这么久”的惊叹 233。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这次的主线是亨利为了救回他那因为诅咒被困在飞翔的荷兰人号的威尔特纳而出海寻找海神三叉戟。而此时的杰克船长呢，却待在一个小岛上，进行了一场可笑几乎分文未得到的抢劫。因为没有好船，没有收入，再加上经历了许多失败的冒险，他的船员也对他有些失望了。杰克那出名的黑珍珠号因为受到了黑胡子的诅咒，被禁锢在玻璃瓶里面，杰克仅有一条不知道能不能下海的小破船。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杰克落魄到了什么程度呢？船员全都离开了他，海军四处追杀他，而他的赏金也在几次修改后逐渐降低，甚至他穷到了要用他的神奇的罗盘来换取酒喝。这个罗盘是他成名战胜利之前所得到，也陪伴着他经过了一次次的冒险，无数次带他去到了他最渴望的目标。但是在这里他放弃了它，一个没有船，没有船员的船长还叫什么船长呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是放弃罗盘是一件严重的事，这就意味着萨拉查再度取得自由，而这次的萨拉查有了诅咒的加成，再次成为了海上无敌的存在，而他的目的是直取杰克的人头，以报多年前的一箭之仇。在买酒之后，杰克被海军抓入监狱，不过在行刑时的一片混乱中，主角终于聚到了一起。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里不得不提一提在小岛上发生的抢劫银行和刑场救人的事件，首先我要吐槽一下杰克究竟是怎么进到保险箱里面去的，而且行长的妻子也进到里面去了……总感觉惊天魔盗团悄悄来到了小岛 233。总之这个抢银行的过程很有海盗气息，他们也是选择直接抢走保险柜，这让我联想起了速度与激情的那一幕。然而因为墙壁太结实，他们抢走的不仅仅是保险柜，更是直接把整个银行拖着走了。看着到处鸡飞狗跳的情况，无论是戏里戏外都是十分欢乐的，当然最喜闻乐见的是到了最后保险柜里只剩下了一枚金币——都在沿路上撒光了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而刑场救人这一次呢，也十分有海盗特色，首先就是杰克和天文学家卡琳娜分别在断头台和绞刑架的嘴炮，特别是杰克的油嘴滑舌真的非常有杰克特色。当然也不能让他们白白打这么久的嘴炮，在准备行刑的时候，杰克的船员出现了，炸毁了断头台，留下杰克一直与断头台的刀子进行生命的旋转——这个地方真的十分搞笑又让人捏了一把汗，不过最后自然是杰克安全着地。而主角众人也终于凑齐，为了共同的目标海神三叉戟来开始航海。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杰克这里先放一边，本部电影的亮点所在是巴博萨船长，在杰克遭遇到萨拉查之前，巴博萨先碰上了他和他的鬼船。尽管在萨拉查自由之前，干掉了黑胡子的巴博萨是海上最强的海盗，但是遇到了杀人不眨眼而且海上无敌手并拥有不死之身的萨拉查和他的船员，巴博萨选择了先示好认怂，带领萨拉查找到他的仇人杰克。这无疑是在刀尖上舔血，但是巴博萨奸诈归奸诈，却并不是胆小怕事之辈。他成功在日出之前找到了杰克，保住了他和不少船员的性命。之后当他们上岸追赶杰克的时候他又反水去寻找三叉戟准备向萨拉查发起挑战，从这些看来巴博萨真的是当之无愧的海上枭雄。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在巴博萨夺得的黑胡子的剑的助攻下，黑珍珠号再次出山，而没想到的是一直在找爸爸的卡特琳娜的爸爸居然正是巴博萨，巴博萨原来是因为自己给不了孩子幸福才“抛弃了她”，只留下了一本带有红宝石的笔记本来让她能过得好一些。虽然这出发点是好的，但是抛弃这事怎么说都是不对的。最后果不其然当大海将要闭合，一行拼命逃向船的危急时刻，巴博萨为了救刚刚相认女儿带着萨拉查一起进入海洋中了……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴博萨和杰克相爱相杀，从开始的完全的敌人，到后来再次复活之后的惺惺相惜，亦敌亦友，到现在又再次死去。我想少了巴博萨的海上，杰克可能也会觉得没那么精彩了吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间的剧情没什么好说的，不过看得还是挺爽的，最后因为三叉戟被打破，海上的诅咒都被消除，特纳也终于可以从荷兰人号回到岸上和爱人相遇，特纳和亨利他们父子两对恩爱的夫妇在夕阳的土坡上撒狗粮之时，杰克已经先一步出航成功地躲开了双重暴击 233。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影的话，杰克依然是绝对的男主，亨利的话感觉主要作用就是推动剧情的发展……</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一部很有情怀的作品，剧情和前面关联得比较紧密，没有看前面的话虽然不影响观看，但是一些细节的地方就没有看过之后有感触了。不过在情怀的同时故事也讲得不错，整部电影看得非常爽快，连没看过这系列的女票都觉得很过瘾。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较遗憾的地方就是巴博萨领便当的这个情节比较套路，还有就是杰克什么时候才能找到女朋友啊 233，期待下一部，希望不要再等这么多年了……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《加勒比海盗-5：死无对证》&quot;&gt;&lt;a href=&quot;#《加勒比海盗-5：死无对证》&quot; class=&quot;headerlink&quot; title=&quot;《加勒比海盗 5：死无对证》&quot;&gt;&lt;/a&gt;《加勒比海盗 5：死无对证》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="海盗" scheme="https://blog.patrickcty.cc/tags/%E6%B5%B7%E7%9B%97/"/>
    
      <category term="德普" scheme="https://blog.patrickcty.cc/tags/%E5%BE%B7%E6%99%AE/"/>
    
      <category term="情怀" scheme="https://blog.patrickcty.cc/tags/%E6%83%85%E6%80%80/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式复习——第一章</title>
    <link href="https://blog.patrickcty.cc/2017/06/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://blog.patrickcty.cc/2017/06/19/嵌入式复习——第一章/</id>
    <published>2017-06-19T06:13:09.000Z</published>
    <updated>2017-06-19T06:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式复习——第一章"><a href="#嵌入式复习——第一章" class="headerlink" title="嵌入式复习——第一章"></a>嵌入式复习——第一章</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="嵌入式操作系统分类"><a href="#嵌入式操作系统分类" class="headerlink" title="嵌入式操作系统分类"></a>嵌入式操作系统分类</h2><h3 id="按收费模式划分"><a href="#按收费模式划分" class="headerlink" title="按收费模式划分"></a>按收费模式划分</h3><ul>
<li>商用型：VxWorks, Nucleux, PlamOS, Symbian, WinCE, QNX, pSOS, VRTX, Lynx OS, Hopen, Delta OS</li>
<li>免费型：Linux, μCLinux 等</li>
</ul>
<h3 id="按实时性划分"><a href="#按实时性划分" class="headerlink" title="按实时性划分"></a>按实时性划分</h3><ul>
<li>硬实时：VxWorks</li>
<li>软实时：WinCE, RTLinux</li>
<li>无实时：Embedded Linux</li>
</ul>
<h2 id="实时性概念"><a href="#实时性概念" class="headerlink" title="实时性概念"></a>实时性概念</h2><p>实时性的本质是任务处理花费时间的可预测性，即任务需要在规定的时限内完成。</p>
<p>软实时意味着如果没有满足制定的时间约束不会导致灾难性的后果，而对于影视是系统来说却是灾难性的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式复习——第一章&quot;&gt;&lt;a href=&quot;#嵌入式复习——第一章&quot; class=&quot;headerlink&quot; title=&quot;嵌入式复习——第一章&quot;&gt;&lt;/a&gt;嵌入式复习——第一章&lt;/h1&gt;&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;head
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="嵌入式" scheme="https://blog.patrickcty.cc/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《Linux/Unix 使用》复习（二）</title>
    <link href="https://blog.patrickcty.cc/2017/06/19/linux%E5%A4%8D%E4%B9%A02/"/>
    <id>https://blog.patrickcty.cc/2017/06/19/linux复习2/</id>
    <published>2017-06-19T01:35:38.000Z</published>
    <updated>2017-06-19T01:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Linux-Unix-使用》复习（二）"><a href="#《Linux-Unix-使用》复习（二）" class="headerlink" title="《Linux/Unix 使用》复习（二）"></a>《Linux/Unix 使用》复习（二）</h1><h1 id="安装和卸载"><a href="#安装和卸载" class="headerlink" title="安装和卸载"></a>安装和卸载</h1><h2 id="硬盘的磁道与扇区"><a href="#硬盘的磁道与扇区" class="headerlink" title="硬盘的磁道与扇区"></a>硬盘的磁道与扇区</h2><ul>
<li>磁道：磁碟的每一面划分的大小不同的同心圆</li>
<li>柱面：全部磁碟面上有相同半径的磁道，也就是说每个磁碟的相同地方的磁道连起来就形成了柱面</li>
<li>扇区：磁道划成的若干小弧段</li>
<li>磁头：每个磁碟有两面对应两个磁头</li>
</ul>
<blockquote>
<p>访问一个具体的扇区需要的物理参数是 （柱面号/磁道号，磁头号，扇区号）</p>
<p>硬盘总容量 = 柱面数 × 磁头数 × 每个磁道的扇区数 × 512 KB</p>
</blockquote>
<h2 id="硬盘的分区"><a href="#硬盘的分区" class="headerlink" title="硬盘的分区"></a>硬盘的分区</h2><blockquote>
<p>柱面是分区的边界，即一个分区包含整数个连续编号的柱面</p>
</blockquote>
<h3 id="MBR-的分区"><a href="#MBR-的分区" class="headerlink" title="MBR 的分区"></a>MBR 的分区</h3><p>（0 柱面，0 磁头，1 扇区）是硬盘的主引导分区，里面存放了：</p>
<ul>
<li>硬盘的主引导程序</li>
<li>四个分区表记录</li>
<li>硬盘有效标志</li>
</ul>
<p>分区记录表里面用来存放分区的信息，且存放的一定是主分区，否则则是逻辑分区。</p>
<h4 id="主分区"><a href="#主分区" class="headerlink" title="主分区"></a>主分区</h4><p>也可称为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区。</p>
<p>总之主分区和操作系统是密切相关的。</p>
<h4 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h4><p>也要占用分区表记录，用来创建逻辑分区。一个扩展分区对应着多个逻辑分区。</p>
<h4 id="逻辑分区"><a href="#逻辑分区" class="headerlink" title="逻辑分区"></a>逻辑分区</h4><p>仅仅只是存储介质，和操作系统以及主分区无关，作用类似于 U 盘。</p>
<h3 id="Linux-分区方法"><a href="#Linux-分区方法" class="headerlink" title="Linux 分区方法"></a>Linux 分区方法</h3><ul>
<li>创建根分区（主分区），挂载 / 目录</li>
<li>交换分区（主分区，可选），大小为物理内存两倍，但最大不超过 4GB</li>
</ul>
<h3 id="GPT-的分区"><a href="#GPT-的分区" class="headerlink" title="GPT 的分区"></a>GPT 的分区</h3><p>GPT 支持分区数可达 128 个，只有支持 UEFI 的主板才能从 GPT 分区硬盘启动操作系统。</p>
<h3 id="分区命名"><a href="#分区命名" class="headerlink" title="分区命名"></a>分区命名</h3><blockquote>
<p>/dev/设备代号和设备代号数（如果不包含代号数则是整块硬盘）</p>
</blockquote>
<p>例如 /dev/sdb5</p>
<ul>
<li>sdb 表示第二块硬盘</li>
<li>5 表示第五个分区，在这里是逻辑分区</li>
</ul>
<p>其中光盘命名为 /dev/cdrom<br>IDE 硬盘为 /dev/hd[a~z][1~16]</p>
<h2 id="卸载-Linux"><a href="#卸载-Linux" class="headerlink" title="卸载 Linux"></a>卸载 Linux</h2><p>所谓卸载，就是在分区表中删除掉 Linux 的分区并且修改主引导程序</p>
<p>删除分区方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo fdisk /dev/sda  # 假如要删除第一块硬盘的分区，然后再在里面进行相应的操作</div></pre></td></tr></table></figure></p>
<h2 id="初步管理"><a href="#初步管理" class="headerlink" title="初步管理"></a>初步管理</h2><pre><code>pass，如果习题里面出现再看
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《Linux-Unix-使用》复习（二）&quot;&gt;&lt;a href=&quot;#《Linux-Unix-使用》复习（二）&quot; class=&quot;headerlink&quot; title=&quot;《Linux/Unix 使用》复习（二）&quot;&gt;&lt;/a&gt;《Linux/Unix 使用》复习（二）&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="Linux" scheme="https://blog.patrickcty.cc/tags/Linux/"/>
    
  </entry>
  
</feed>
