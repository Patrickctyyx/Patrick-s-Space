<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2019-04-18T01:48:01.314Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于毕业设计的一些事</title>
    <link href="https://blog.patrickcty.cc/2019/04/16/%E5%85%B3%E4%BA%8E%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>https://blog.patrickcty.cc/2019/04/16/关于毕业设计的一些事/</id>
    <published>2019-04-16T15:55:49.000Z</published>
    <updated>2019-04-18T01:48:01.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漫画人脸二分类"><a href="#漫画人脸二分类" class="headerlink" title="漫画人脸二分类"></a>漫画人脸二分类</h2><p>一开始我一直想用 VGG 来实现漫画人脸的二分类，即判断是不是人脸。但是效果一直很差，acc 和随便猜的一模一样（50%）。</p>
<p>这时候我一直以为是数据有问题，不过在洗过好多次之后我发现并非如此，出问题的不是数据，而是数据和网络不匹配。</p>
<p>换句话来说就是漫画人脸中包含的要素太少，使用 VGG 这种深层网络会让特征到最后“消失殆尽”，所以最后效果就很差了。</p>
<p>为了验证这个猜想，我使用 VGG 训练 MNIST，结果不出意料的也是随便猜的概率（10%）。</p>
<p>==当然上面的也只是猜想，因为我对 CNN 理解还是太浅，这个基础问题还得在之后再恶补一下了。==</p>
<p>心里有这个概念之后我就尝试用浅一点的网络来解决问题了，尝试着用 AlexNet 和另一个浅一点的 CNN 来训练模型，虽然最后在二分类问题上能达到 80% 左右 的准确率，但是还有一个大问题又被我忽视掉了。</p>
<p>在尝试这两个网络中，我又在其中加入了 bn 层，不过加入之后浅层的 CNN acc 又变成了 50%……</p>
<p>==更新==</p>
<p>MNIST 这个 acc 这么低，原因不是我想的那样，而是我在处理输入的时候直接无脑 resize，破坏了原来图片的语义……使用正常的处理方法就能得到正确的结果了，并不是 VGG 的锅……</p>
<p>那么问题来了，我的漫画网络究竟是哪里出问题了呢……</p>
<h2 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h2><p>Acc 80%，这是一个不算特别好又不算坏的结果。但是试了很多种方法一时间没能找到更高的准确度，于是就准备拿这个模型来提取特征了。</p>
<p>不过在这个过程中，我有又发现了一个大问题：提取出来的特征太稀疏了，256 维的特征中，只有不到十个元素不为零……而 flatten 层也仅有 1/8 左右的不为零。虽然我内心没有逼数，但这的确是一个不正常的现象。</p>
<p>==后面我准备训练 MNIST 来观察一下各层的正常输出应该是怎么样的。==</p>
<h3 id="检索系统中遇到的坑"><a href="#检索系统中遇到的坑" class="headerlink" title="检索系统中遇到的坑"></a>检索系统中遇到的坑</h3><ul>
<li><code>ValueError: Tensor Tensor(&quot;Sigmoid_2:0&quot;, shape=(?, 17), dtype=float32) is not an element of this graph.</code></li>
</ul>
<p>出现这个问题的原因就是多线程、分布式环境下，恢复 Model 时的 Tensor Graph 和生成 Model 时不同。</p>
<p>具体来说就是模型是在全局变量里面恢复的，但是调用是在 Flask 的多线程调用的。</p>
<p>解决方法就是在恢复 Model 的时候保存相应的 Graph，然后再在 predict 的时候恢复这个 Graph 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># when load model</div><div class="line">graph = tf.get_default_graph()</div><div class="line"></div><div class="line"># when use model in another thread</div><div class="line">global graph</div><div class="line">with graph.as_default():</div><div class="line">    (... do inference here ...)</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/keras-team/keras/issues/2397" target="_blank" rel="external">https://github.com/keras-team/keras/issues/2397</a></li>
<li><p><a href="https://justttry.github.io/justttry.github.io/not-an-element-of-Tensor-graph/" target="_blank" rel="external">https://justttry.github.io/justttry.github.io/not-an-element-of-Tensor-graph/</a></p>
</li>
<li><p><code>FailedPreconditionError: tensorflow not found container localhost does not exist</code></p>
</li>
</ul>
<p>这个问题比较玄学，好像各种问题都可能报这个错误。我出现这个问题的原因可能是 tf 的版本和 keras 的版本有些冲突，使用系统的 Python 不行，但是换成 Anaconda 的 Python 就没问题了。</p>
<p>不过需要注意的是，tf.keras 和 keras 并不是一个东西，如果两个混用的话是会出现各种错误的，如果用到了某一个就一条路走到黑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漫画人脸二分类&quot;&gt;&lt;a href=&quot;#漫画人脸二分类&quot; class=&quot;headerlink&quot; title=&quot;漫画人脸二分类&quot;&gt;&lt;/a&gt;漫画人脸二分类&lt;/h2&gt;&lt;p&gt;一开始我一直想用 VGG 来实现漫画人脸的二分类，即判断是不是人脸。但是效果一直很差，acc 和随便
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
    
      <category term="Deep Learning" scheme="https://blog.patrickcty.cc/tags/Deep-Learning/"/>
    
      <category term="TensorFlow" scheme="https://blog.patrickcty.cc/tags/TensorFlow/"/>
    
      <category term="Keras" scheme="https://blog.patrickcty.cc/tags/Keras/"/>
    
  </entry>
  
  <entry>
    <title>安装 OpenCV C++ 库以及运行相应程序</title>
    <link href="https://blog.patrickcty.cc/2019/04/07/%E5%AE%89%E8%A3%85OpenCV/"/>
    <id>https://blog.patrickcty.cc/2019/04/07/安装OpenCV/</id>
    <published>2019-04-07T07:40:53.000Z</published>
    <updated>2019-04-07T07:58:50.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扯两句废话"><a href="#扯两句废话" class="headerlink" title="扯两句废话"></a>扯两句废话</h2><p>之前用惯了 Python，以为使用 C++ 的模块也是直接一行命令安装然后再直接编译就可以了，没想到并没有这么简单，还是需要其他的一些步骤。</p>
<p>于是这两天在不会 C++ 上吃了大亏 orz。</p>
<h2 id="Ubuntu-安装-OpenCV"><a href="#Ubuntu-安装-OpenCV" class="headerlink" title="Ubuntu 安装 OpenCV"></a>Ubuntu 安装 OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libopencv-dev</div></pre></td></tr></table></figure>
<p>没错，一行命令完事。</p>
<p>一开始我是老老实实下载、编译的（因为搜安装教程完全没看到用 apt 安装的，于是我以为只能编译来安装了 orz），结果配了半天环境变量还是找不到 OpenCV 的包，最后这行命令下去直接就一切 ok 了。</p>
<p>检查 OpenCV 是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg-config --cflags --libs opencv</div></pre></td></tr></table></figure>
<p>如果输出的那一大堆不是报错的那就说明安装成功了。</p>
<h2 id="Mac-安装-OpenCV"><a href="#Mac-安装-OpenCV" class="headerlink" title="Mac 安装 OpenCV"></a>Mac 安装 OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install opencv</div></pre></td></tr></table></figure>
<p>这样安装了还是要配置环境变量</p>
<h3 id="配置-pkg-config-环境变量"><a href="#配置-pkg-config-环境变量" class="headerlink" title="配置 pkg-config 环境变量"></a>配置 pkg-config 环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/</div></pre></td></tr></table></figure>
<h3 id="把-OpenCV-pc-文件链接到-PKG-CONFIG-PATH"><a href="#把-OpenCV-pc-文件链接到-PKG-CONFIG-PATH" class="headerlink" title="把 OpenCV .pc 文件链接到 PKG_CONFIG_PATH"></a>把 OpenCV .pc 文件链接到 PKG_CONFIG_PATH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/opt/opencv3/lib/pkgconfig/opencv.pc $PKG_CONFIG_PATH</div></pre></td></tr></table></figure>
<p>这一步具体的路径就要看 opencv.pc 文件在哪里了，我的 Mac 上的是 opencv4.pc 文件</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>环境变量配置好了之后应该就可以了，之后还是运行上面的命令来检查是否安装成功。详细的安装过程可以看<a href="https://gist.github.com/nkcr/6f5c6db4dccd3b32e8ba" target="_blank" rel="external">这个教程</a>。</p>
<h2 id="运行相应程序"><a href="#运行相应程序" class="headerlink" title="运行相应程序"></a>运行相应程序</h2><p>如果源程序中引用了相应的模块那么编译的时候就要加入一些其他的内容了，比如如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++11 main.cpp mangaLineSeparator.cpp -o main $(pkg-config --cflags --libs opencv4)</div></pre></td></tr></table></figure>
<p>然后就生成了可执行程序 <code>main</code> 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ 的模块的使用和 Python 还是有一些不同的，在处理问题的时候不要根据惯性思维来思考，不然就会在一些你意想不到的地方纠结……比如明明是编译的命令写错了，我却一直以为是模块没有正常安装……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扯两句废话&quot;&gt;&lt;a href=&quot;#扯两句废话&quot; class=&quot;headerlink&quot; title=&quot;扯两句废话&quot;&gt;&lt;/a&gt;扯两句废话&lt;/h2&gt;&lt;p&gt;之前用惯了 Python，以为使用 C++ 的模块也是直接一行命令安装然后再直接编译就可以了，没想到并没有这么简单，
    
    </summary>
    
    
      <category term="C++" scheme="https://blog.patrickcty.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>3.28随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/28/3-28%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/28/3-28随想/</id>
    <published>2019-03-28T06:10:34.000Z</published>
    <updated>2019-03-28T06:47:17.292Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写随想了，不知不觉这本王小波散文集也快读完了。</p>
<p>今天读到的《盖茨的紧身衣》让我有了一些想法。现在经常有一些新事物号称要颠覆、取代已有的一些事物。也有一些新事物被人们鼓吹会完全取代旧事物。</p>
<p>虽然真正能颠覆和取代的确实存在，但大多数新事物只是让市面上多了一个 fancy 的选择，分流了一些摇摆的受众，原本的事物并没有收到那么大的冲击。就比如前几年很多人鼓吹电子书将取代书籍，电子货币将取代现金。但是现在呢？实体书依旧有市场，现金仍然被广泛的使用。不过还有下半句那就是实体书的市场已经大大萎缩了，现金的使用也大大减少了。但其实这种缩小并不是一件坏事，作家的书籍在互联网上得到了更大的曝光，更容易被其他人阅读到；货币的流通不但没有减少反而跟着网购一起腾飞。</p>
<p>不过说起要，要想不被淘汰，最重要的一点就是有实力。群众的眼睛是雪亮的，好的内容在竞争中往往不会落入下风。另外一点就是不要盲目跟风，虽然跟风的话运气好可以一夜暴富，但是通常情况下就会落得一个不三不四的结果。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写随想了，不知不觉这本王小波散文集也快读完了。&lt;/p&gt;
&lt;p&gt;今天读到的《盖茨的紧身衣》让我有了一些想法。现在经常有一些新事物号称要颠覆、取代已有的一些事物。也有一些新事物被人们鼓吹会完全取代旧事物。&lt;/p&gt;
&lt;p&gt;虽然真正能颠覆和取代的确实存在，但大多数新事物只是让
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>3.19随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/19/3-19%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/19/3-19随想/</id>
    <published>2019-03-19T01:41:10.000Z</published>
    <updated>2019-03-19T02:01:53.558Z</updated>
    
    <content type="html"><![CDATA[<p>在看《我的精神家园》的时候我就一直在想我在大学之前的事。</p>
<p>王小波的精神家园来自于从小读过的书籍，而对于那些从小并没有养成主动读书习惯的人，精神家园则是大为不同了。在现在看来，我认为背诵语文书上的一些课文，尤其是诗歌与古文是非常有必要的，尽管在大学之前我都是那种看到“背诵”二字都会万分头疼的人（现在好像也非常讨厌背书）。</p>
<p>在批判过去教育的死板与迂腐之前，我不得不说，那种强行要你背的方法虽不是一个最佳的方法，但它的成效确实还不错。何出此言？不说是在小学和初中，就算是在高中很多人对生活的认识都是非常浅薄的，欣赏力也比较有限。即是说，他们无法发现其中的美与内涵。就以《游褒禅山记》为例，在学习这篇文章的时候我并没有感觉到任何吸引到我的地方，但在现在再回想里来，其中蕴含的道理，在生活之中还是非常受用的。我们到底是那些迎难而上的人还是看到险峰就回走的人？即使是最讨厌古文的我，在学习《滕王阁序》的时候，也彻底被王勃的喷涌而出的才华给折服了，这样一篇才华横溢的文章，课后没有要求背诵全文，我也基本把全文熟悉到可以背诵的地步。</p>
<p>虽然当时所学习的那些课文并没有建立起我的精神家园，但它们却在潜移默化之中改变了我的想法，同时这种帮助在我成熟的过程中越发清晰。</p>
<p>这些背诵全文，或者往广了说是语文的学习，都是为了构建我们的精神家园。只不过人们往往对强制的东西非常反感，所以在当时很多人都非常抵触，但还是有一些人从这样的过程中获得了乐趣，为他们的精神家园奠定了坚实的基础。现在的教育方式和我那时候相比已经有了长足的进步，老师都是以一种引导的方式来让学生自主进行自己精神家园的构建，这样的方法在效率和效果上都要比被动灌输要来的好不少。如今网络上键盘侠横行，一个重要的原因就是他们精神家园没有建立起来，自己独立思考的能力严重欠缺，非常缺乏教养。或许到了下一代之后这样的情形能有所好转吧，那时候大家都有了自己的精神家园。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看《我的精神家园》的时候我就一直在想我在大学之前的事。&lt;/p&gt;
&lt;p&gt;王小波的精神家园来自于从小读过的书籍，而对于那些从小并没有养成主动读书习惯的人，精神家园则是大为不同了。在现在看来，我认为背诵语文书上的一些课文，尤其是诗歌与古文是非常有必要的，尽管在大学之前我都是那种
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>写在考研尘埃落定之后</title>
    <link href="https://blog.patrickcty.cc/2019/03/18/%E5%86%99%E5%9C%A8%E8%80%83%E7%A0%94%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A%E4%B9%8B%E5%90%8E/"/>
    <id>https://blog.patrickcty.cc/2019/03/18/写在考研尘埃落定之后/</id>
    <published>2019-03-18T14:04:43.000Z</published>
    <updated>2019-03-18T14:29:20.785Z</updated>
    
    <content type="html"><![CDATA[<p>3.18 晚上七点二十，考研的总排名终于公布在软件学院的官网上了，我也在拟录取的名单之中。这也意味着我的考研生活终于真正意义上的尘埃落定了。</p>
<p>这个时候按理说应该是吹一波我考研是怎么认真复习，怎么磨练意志这种内容。然而事实并不是这样，虽然不想承认，但这次考研，特别是初试是有很大的运气成分存在的。即使是在最紧张的二轮复习的时候，我复习的效率还是非常低的；准备复试的效率低得就更加令人难以启齿了。关于考研，我想说的不是这些，而更多是一种感想。</p>
<p>在写《最短的捷径就是绕远路》这一篇博文的时候，我就想说我的考研相关内容，但当时还没有出结果，不好提前立 flag，现在终于可以来说一说了。就和乔尼认为的那样，我也饶了一大圈的远路，真的真的绕了好大一圈的远路，从武汉到广州，再从广州回到武汉。即使绕了这么大一圈的远路，但我好歹还是回到了起点，没有倒在半路，这也是一种幸运吧。但绕远路也不是没有代价的，无论是在知识储备还是编程能力亦或是专注力，我和同龄的优秀人才都有着不小的差距，我仅仅只是回到了以前——就像乔尼所说，从负数回归到零——但是他们已经往前冲了好大一截路了。这一段路是我在今后的生活中不能忽视的一段距离，也是我需要用实际行动来弥补的距离。</p>
<p>在这次考研的旅途中，我要感谢实验室的环境，一同考研小伙伴的相互鼓励，父母的全力支持，女朋友的鼓励，当然最大的帮助还是熊楚原全方位无死角的引导了。今天上热搜的清华初试专业第一复试被刷的当事人妹子就是因为缺乏正确的引导而导致这样的悲剧的发生。</p>
<p>说实话，当考研成绩真正出来的时候我的内心是无比的激动的，虽然现在内心依然有些躁动，不过我已经知道了这仅仅只是个开始，后面还有更多的事情要做，我不能一直沉溺在这次的成功之中，而是要像熊楚原说的那样，继续前行，做好我应该做的事情。今后的生活，希望我能多主动去“绕远路”，认真思考，不要逃避。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.18 晚上七点二十，考研的总排名终于公布在软件学院的官网上了，我也在拟录取的名单之中。这也意味着我的考研生活终于真正意义上的尘埃落定了。&lt;/p&gt;
&lt;p&gt;这个时候按理说应该是吹一波我考研是怎么认真复习，怎么磨练意志这种内容。然而事实并不是这样，虽然不想承认，但这次考研，特
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>最短的捷径就是绕远路</title>
    <link href="https://blog.patrickcty.cc/2019/03/13/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%8D%B7%E5%BE%84%E5%B0%B1%E6%98%AF%E7%BB%95%E8%BF%9C%E8%B7%AF/"/>
    <id>https://blog.patrickcty.cc/2019/03/13/最短的捷径就是绕远路/</id>
    <published>2019-03-13T05:48:41.000Z</published>
    <updated>2019-03-15T11:39:28.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.jnugeek.cn/image/mangas/3992.jpeg" alt="image"></p>
<p>“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大陆的期间，我一直都遵行着这个原则。也因为多亏有你陪伴，我才得以跨越这条漫漫长路。”  ——杰洛·齐贝林</p>
<p>杰洛的 Lesson 5 到底是什么意思，在看漫画的时候我就不明白，在之后这个问题又浮上我的心头，并又困扰了我许久。在参考了其他人的理解并结合自己的思考之后，我终于有了些端倪。</p>
<p>最令我困惑的就是杰洛的“在横跨这片大陆的期间，我一直都遵行着这个原则”这句话了。众所周知，杰洛在这次 SBR 大赛之中，从来都是抄捷径走。但实际上，这些所谓的捷径，或许就是“远路”。怎么理解呢？尽管这些路在距离上是最短的，但每一次都伴随着巨大的风险与挑战，稍有不慎就直接丧失比赛资格，输掉全盘的比赛了。所以这些道路尽管读作捷径，但是却写作需要勇气、果断与智慧的远路。也正是因为这样的“绕远路”，杰洛才能在比赛中拔得头筹。他没有波克洛克的强运，但他就是凭自己的努力，取得了领先的地位。</p>
<p><img src="https://static.jnugeek.cn/image/mangas/v2-f05fc60b0d4c75e3e4c01c143170a9c1_hd.jpg" alt="image"></p>
<p>纵观整部 SBR，我最喜欢的角色就是杰洛，一个追寻答案的人，一个良师益友。这部 SBR 我看的还是太匆忙，下次观看的时候我要专注于杰洛与乔尼的成长之上。</p>
<p>绕远路就是最短的捷径，可惜这个道理我没有早点领悟。</p>
<p>3.15</p>
<p>今天在思考中，我对这句话又有了新的理解。</p>
<p>一直以来，我都是一个喜欢抄近道的人，具体说来就是尽量的偷懒。不愿意去深入思考，不愿意去深入查找资料，于是就自己作出了很多让人后悔的决定。正是因为我大学生活之中抄捷径太多了，所以现在落到了一个尴尬的境地。和我比起来，熊楚原就是一个绕远路的人。于是现在的结果就是，熊楚原不仅比我有着更扎实同时更广的专业知识，而且在思想深度上也是我所不能企及的。</p>
<p>在编程方面，我坚信的一点就是“不要重复造轮子”，但是这句话是有适用对象的——是对那些对相关方面较为熟悉的人来说的。而对于接触一个领域的新手来说，造轮子的过程就是一个熟悉的过程，当你能自己独立地造出几个轮子，就说明你对这个领域已经有相当程度的了解了，这时候如果要开发一个项目或者工程的话就可以顺利地使用别人已经造好的轮子了。要不然可能会在你想不到的地方掉进坑，耗费更多的时间。很多时候一个简单的功能我宁可花很多时间来找相关的模块也不愿意自己动手实现一下——就算只有一行代码的事，想想真的有点本末倒置了。</p>
<p>一直以来在抄捷径的过程中，我饶了很多路，真的太讽刺了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.jnugeek.cn/image/mangas/3992.jpeg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.12随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/12/3-12%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/12/3-12随想/</id>
    <published>2019-03-12T01:13:46.000Z</published>
    <updated>2019-03-12T01:33:42.708Z</updated>
    
    <content type="html"><![CDATA[<p>前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。</p>
<p>文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人们在不需要受苦的时候去追求吃苦，那就是一种非常害人的思想了。</p>
<p>在一些影视剧里面，常常会出现“忆苦思甜”的场景：一家人坐在餐桌上，吃着菜杆子，讲述着以前的苦日子。从那个苦年代过来的人非常吃这一套，而且这样的氛围真真切切能让他们回忆起之前的经历，不过对于他们的子女，这就是一顿难吃的饭以及一些不知所云的经历。忆苦思甜不是这么来的，在优渥环境中长大的人是无法想象那种艰难的情景的，你也别想他们能从中学到珍惜现在。</p>
<p>要让他们珍惜当下，培养他们的同理心，最好的方法就是实践。有条件的话可以去偏远山区去探望那里的儿童，让子女亲自把物资交给他们，让他们亲自感受一下安稳的生活是并不是理所当然；即使去不了偏远山区也可以去孤儿院这些地方去看看。形式从来都没那么重要，重要的是一种真真切切的感情，你说这样就比吃菜杆子更加的苦吗？完全没有啊！但这样的效果却比吃菜杆子来的不知道有多好，甚至还可以在回程的路上，在他们还没有回到他们熟悉的舒服环境之前，再给他们讲讲过去的苦日子，这样一来就能让他们有更深的感触。</p>
<p>最后我想说的是，很多人的吃苦就是一种假把式，用来麻痹自己，让自己心安理得，真正是因为懒还是因为别的什么的原因个人自己心里都有数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。&lt;/p&gt;
&lt;p&gt;文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试准备指二零零七到二零一二上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/09/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E6%8C%87%E4%BA%8C%E9%9B%B6%E9%9B%B6%E4%B8%83%E5%88%B0%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%BA%8C%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/09/复试准备指二零零七到二零一二上机题/</id>
    <published>2019-03-09T03:21:35.000Z</published>
    <updated>2019-03-09T03:21:51.633Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程输出 出列编号的序列。</li>
</ol>
<p>例：</p>
<p>若 N=3,C=1,则出列编号的序列为 1，2，3</p>
<p>若 N=3,C=2,则出列编号的序列为 2，1，3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n, c;</div><div class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;</div><div class="line">        int out[1000] = &#123;0&#125;;</div><div class="line">        int cnt = n;  // 没有出列的人数</div><div class="line">        int num = 1;  // 报数</div><div class="line">        int no = 0;  // 排列编号</div><div class="line">        while (cnt) &#123;</div><div class="line">            if (out[no] == 1) &#123;</div><div class="line">                no = (no + 1) % n;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if (num == c) &#123;</div><div class="line">                cout &lt;&lt; no + 1 &lt;&lt; &apos; &apos;;</div><div class="line">                out[no] = 1;</div><div class="line">                num = 1;</div><div class="line">                cnt--;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            no = (no + 1) % n;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>输入一个循环数组（数组的最后一个元素的下一元素为数组的第一个元素），依次打印出 数组中所有元素的下一个比这个元素更大的值（按数组下标大小搜寻，可以循环），如果不 存在更大的元素，打印-1。</li>
</ol>
<p>例：</p>
<p>输入：</p>
<p>6</p>
<p>1 2 1 6 3 4</p>
<p>输出：2 6 6 -1 4 6 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n;</div><div class="line">    int a[1000];</div><div class="line">    while (cin &gt;&gt; n) &#123;</div><div class="line">        int mmax = -1;</div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            cin &gt;&gt; a[i];</div><div class="line">            if (a[i] &gt; mmax) &#123;</div><div class="line">                mmax = a[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if (a[i] == mmax) &#123;</div><div class="line">                cout &lt;&lt; -1 &lt;&lt; &apos; &apos;;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int next = (i + 1) % n;</div><div class="line">            while (1) &#123;</div><div class="line">                if (a[i] &lt; a[next]) &#123;</div><div class="line">                    cout &lt;&lt; a[next] &lt;&lt; &apos; &apos;;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                next = (next + 1) % n;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试准备之二零一三上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B8%89%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试准备之二零一三上机题/</id>
    <published>2019-03-07T13:46:47.000Z</published>
    <updated>2019-03-07T13:47:08.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>输出 100-1000 的所有平方回文数。</li>
</ol>
<p>平分回文数字是满足下列条件的整数：</p>
<p>（1）从左读与从右读都是一样的。</p>
<p>（2）为某一个数的平方。</p>
<p>例：121 是平方回文数。</p>
<ol>
<li>编程解决“八皇后问题”：即在一个 8*8 的矩形格子中排放 8 个皇后，要满足的条件包 括：任意两个皇后不能在同一行，同一列，也不能在同一条对角线上。</li>
</ol>
<p>要求编程给出解的个数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool is_huiwen(int num) &#123;</div><div class="line">    int x = num % 10;</div><div class="line">    int y = num / 100;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt; 1000; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; is_huiwen(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[8][8] = &#123;0&#125;;</div><div class="line">int col_flags[8] = &#123;0&#125;;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void queen(int row) &#123;</div><div class="line">    if (row == 8) &#123;</div><div class="line">        cnt++;</div><div class="line">        for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 8; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">        // 纵列上没有皇后</div><div class="line">        if (col_flags[i] == 1) continue;</div><div class="line">        // 左斜对角线上没有皇后</div><div class="line">        int flag = 0;</div><div class="line">        for (int j = 1; j + i &lt; 8; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i + j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        flag = 0;</div><div class="line">        // 右斜对角线没有皇后</div><div class="line">        for (int j = 1; j &lt;= i; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i - j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        arr[row][i] = 1;</div><div class="line">        col_flags[i] = 1;</div><div class="line">        queen(row + 1);</div><div class="line">        arr[row][i] = 0;</div><div class="line">        col_flags[i] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    queen(0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;输出 100-1000 的所有平方回文数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平分回文数字是满足下列条件的整数：&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之二零一四上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E5%9B%9B%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之二零一四上机题/</id>
    <published>2019-03-07T13:08:48.000Z</published>
    <updated>2019-03-07T13:09:10.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。</li>
</ol>
<p>（1）完全平方数。</p>
<p>（2）含有两位数字相同。</p>
<p>例：144，676…</p>
<ol>
<li>输入一串字符串，把下标为奇数的小写字母(从 0 开始编号)转换为大写字母。</li>
</ol>
<p>输出转换后的字符串。</p>
<h2 id="代码分别如下"><a href="#代码分别如下" class="headerlink" title="代码分别如下"></a>代码分别如下</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool has_same_nums(int num) &#123;</div><div class="line">    int x = num / 100;</div><div class="line">    int y = (num - x * 100) / 10;</div><div class="line">    int z = num - x * 100 - y * 10;</div><div class="line">//    cout &lt;&lt; x &lt;&lt; &apos; &apos; &lt;&lt; y &lt;&lt; &apos; &apos; &lt;&lt; z;</div><div class="line"></div><div class="line">    return x == y || x == z || y == z;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt;= 999; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; has_same_nums(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    string str;</div><div class="line">    int interval = &apos;a&apos; - &apos;A&apos;;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (i % 2 == 1) continue;</div><div class="line">            if (str[i] - &apos;a&apos; &gt;= 0 &amp;&amp; str[i] - &apos;z&apos; &lt;= 0) &#123;</div><div class="line">                str[i] -= interval;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cout &lt;&lt; str &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长连续数字</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之最长连续数字/</id>
    <published>2019-03-07T12:50:37.000Z</published>
    <updated>2019-03-07T12:50:47.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，</p>
<p>例：</p>
<p>输入：</p>
<p>ab125ff1234567#</p>
<p>输出：</p>
<p>1234567</p>
<p>开始位置为 8</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没啥好说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void longest_str(string str) &#123;</div><div class="line">    int max_len = 0, max_pos = 0;</div><div class="line">    int cur_num = 0, cur_pos = 0;</div><div class="line">    int flag = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; str.length() - 1; ++i) &#123;</div><div class="line">        // is number</div><div class="line">        if (str[i] - &apos;0&apos; &gt;= 0 &amp;&amp; str[i] - &apos;0&apos; &lt;= 9) &#123;</div><div class="line">            if (flag == 0) &#123;</div><div class="line">                flag = 1;</div><div class="line">                cur_pos = i;</div><div class="line">                cur_num = 1;</div><div class="line">            &#125; else &#123;</div><div class="line">                cur_num++;</div><div class="line">            &#125;</div><div class="line">            if (cur_num &gt; max_len) &#123;</div><div class="line">                max_len = cur_num;</div><div class="line">                max_pos = cur_pos;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;  // not number</div><div class="line">            flag = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; str.substr(max_pos, max_len) &lt;&lt; &quot; 开始位置为&quot; &lt;&lt; max_pos + 1 &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        longest_str(str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之棒球赛</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%A3%92%E7%90%83%E8%B5%9B/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之棒球赛/</id>
    <published>2019-03-07T12:35:20.000Z</published>
    <updated>2019-03-07T12:39:13.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：</p>
<ol>
<li>如果该字符串是数字：代表当轮比赛的得分情况。</li>
<li>如果该字符串是“+”：代表当轮比赛得分情况为上两轮之和。</li>
<li>如果该字符串是“C”：代表上一轮得分无效。</li>
<li>如果该字符串是“D”:代表当轮比赛得分为上一轮得分的两倍。</li>
</ol>
<p>你需要得出最后总的得分情况并返回结果。</p>
<p>例：</p>
<p>输入：52CD+</p>
<p>输出：30</p>
<p>解释：</p>
<p>第 1 轮得分 5 分，当前总共得分 5 分。</p>
<p>第 2 轮得分 2 分，当前总共得分 5+2=7 分。</p>
<p>第 3 轮取消上轮得分，当前总共得分 5 分。</p>
<p>第 4 轮获得上一轮双倍得分，当前总共得分 5+10=15 分。</p>
<p>第 5 轮获得上两轮得分之和，当前总共得分 15+5+10=30 分。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个==栈的应用==题，如果知道这一点解法就很简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    int stack[105];</div><div class="line"></div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        int top = 0;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (str[i] == &apos;C&apos;) &#123;</div><div class="line">                --top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;D&apos;) &#123;</div><div class="line">                stack[top] = 2 * stack[top - 1];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;+&apos;) &#123;</div><div class="line">                stack[top] = stack[top - 1] + stack[top - 2];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                stack[top++] = str[i] - &apos;0&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int sum = 0;</div><div class="line">        for (int i = 0; i &lt; top; ++i) &#123;</div><div class="line">            sum += stack[i];</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.7随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/3-7%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/3-7随想/</id>
    <published>2019-03-07T07:26:32.000Z</published>
    <updated>2019-03-07T07:42:51.372Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。</p>
<p>那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人们对这个国家的印象；另一方面国家的形象又能被个人的行为所影响，中国人在国外被认为素质低下，就是个人行为所产生的影响。</p>
<p>何为自我尊严呢？我和王小波想得不一样，我认为自尊就是问心无愧。古人被打板子，虽然外人看来很难看，但是如果是文死谏，我认为并没有丧失尊严；反之，皇帝老儿在殿堂之上骄纵作乐，看起来很风光，但是这就是尊严么？也不一定吧。</p>
<p>不过要说的话，很多尊严其实说白了就是面子，是给别人看的，而非问心无愧。这一套中国人是最擅长的，所以尊严这东西其实并不普遍。毕竟对于大多数人来说，过得舒服才是最重要的，只是有时候不得不追求一下所谓的尊严，因为如果你只秉持自尊的话，在这个社会上是寸步难行的。</p>
<p>王小波为了尊严不会在火车太挤的时候挤进去而且浑然无觉，但是总有人会为了回家而选择“丧失尊严”。这些其实都无关紧要，重要的是问心无愧就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。&lt;/p&gt;
&lt;p&gt;那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试上机准备之跳台阶</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之跳台阶/</id>
    <published>2019-03-06T13:57:00.000Z</published>
    <updated>2019-03-06T14:01:49.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1 阶台阶，也可以跳 n-2 阶台阶……也可以跳 1 阶</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>a[1] = 1, a[2] = 2.</p>
<p>对于三级台阶，可以第一步跳三步，方法为 1；可以第一步跳两步，还剩一步，方法和 a[3 - 2] 相同；也可以第一步跳一步，还剩两步，方法和 a[3 - 1] 相同。最终结果为 1 + 1 + 2 = 4 = 2^2</p>
<p>同理 a[4] = 1 + 1 + 2 + 4 = 8 = 2^3</p>
<p>a[n] = 2^(n - 1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之马跳棋</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E9%A9%AC%E8%B7%B3%E6%A3%8B/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之马跳棋/</id>
    <published>2019-03-06T13:43:50.000Z</published>
    <updated>2019-03-06T14:01:53.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的位）开始跳马，能够把棋盘的格子全部都走一遍，每个格子只允许走一次。</p>
<p>（1）输出一个如图 2 的解，左上角为第一步起点。</p>
<p>（2）总共有多少解。</p>
<p>P.S 国际象棋的棋子是在格子中间的。国际象棋中的“马走日”，如下图所示，第一步为[1,1], 第二步为[2,8]或[2,12]，第三步可以是[3,5]或[3,21]等，以此类推。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个常规的回溯题，要注意的就是一共有八个走的方向，在返回的时候记得还原原本的状态值。</p>
<p>一共有 304 解，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[5][5] = &#123;0&#125;;</div><div class="line">int vis_num = 1;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void horse_jump(int x, int y) &#123;</div><div class="line">    // 输出走法</div><div class="line">    if (vis_num == 25) &#123;</div><div class="line">        for (int i = 0; i &lt; 5; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 5; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">        cnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 右二下一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x + 2][y + 1] == 0) &#123;</div><div class="line">        arr[x + 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一下二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x + 1][y + 2] == 0) &#123;</div><div class="line">        arr[x + 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二上一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x - 2][y - 1] == 0) &#123;</div><div class="line">        arr[x - 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一上二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x - 1][y - 2] == 0) &#123;</div><div class="line">        arr[x - 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二下一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x - 2][y + 1] == 0) &#123;</div><div class="line">        arr[x - 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一下二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x - 1][y + 2] == 0) &#123;</div><div class="line">        arr[x - 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右二上一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x + 2][y - 1] == 0) &#123;</div><div class="line">        arr[x + 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一上二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x + 1][y - 2] == 0) &#123;</div><div class="line">        arr[x + 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    arr[0][0] = 1;</div><div class="line">    horse_jump(0, 0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长公共子串</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之最长公共子串/</id>
    <published>2019-03-06T01:58:30.000Z</published>
    <updated>2019-03-06T02:50:26.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。</p>
</blockquote>
<p>输入：</p>
<p>What’re your namess?</p>
<p>My namess are your.</p>
<p>输出：</p>
<p>reyour</p>
<p>namess</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最长公共子串/序列，是动态规划中一个非常经典的题型。但我之前接触的是最长公共子序列，子序列不要求序列的元素是相邻的，而子串需要元素是相邻的。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>两个循环，把序列 B 的每个元素开始的子串和 A 的所有元素进行比较，找出所有子串，从而找出最长子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void get_sub_str(string a, string b) &#123;</div><div class="line">    int len_a = a.length();</div><div class="line">    int len_b = b.length();</div><div class="line"></div><div class="line">    int start = 0, max_len = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; len_a; ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; len_b; ++j) &#123;</div><div class="line">            // 当找到相等的时候就顺着比下去，直到不相同</div><div class="line">            // 这里重新使用了一个变量 k，就不用改 i、j 了</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                int k = 1;</div><div class="line">                while (i + k &lt; len_a &amp;&amp; j + k &lt; len_b &amp;&amp; (a[i + k] == b[j + k])) &#123;</div><div class="line">                    ++k;</div><div class="line">                &#125;</div><div class="line">                if (k &gt; max_len) &#123;</div><div class="line">                    start = i;</div><div class="line">                    max_len = k;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = start; i &lt; start + max_len; ++i) &#123;</div><div class="line">        cout &lt;&lt; a[i];</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过上面这种实现只能输出第一个最长的子串，如果要输出所有最长子串，就要把所有有可能成为最长子串的子串保存下来，输出的时候再进行判断，只输出长度是最长的那些子串。</p>
<h3 id="动态规划-空间换时间"><a href="#动态规划-空间换时间" class="headerlink" title="动态规划-空间换时间"></a>动态规划-空间换时间</h3><p>我们可以用 m * n 的矩阵来存放相等的信息，如果 <code>arr[m][n] != 0</code> 则表明 <code>a[m] == b[n]</code>，子串就是斜对角线这些元素都不为零的那些位置。因此只用找最长的斜线即可。</p>
<p>为了简化找对角线的过程，我们可以让该点的元素值是左上方元素值加一，这样凭借元素值就知道序列的长度有多少了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 使用动态规划-空间换时间的方法</div><div class="line">void print_sub_str(string a, string b) &#123;</div><div class="line">    int arr[256][256] = &#123;0&#125;;</div><div class="line"></div><div class="line">    int max_len = 0;</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                // 根据斜上方的元素来赋值</div><div class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</div><div class="line">                    arr[i][j] = arr[i - 1][j - 1] + 1;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    arr[i][j] = 1;</div><div class="line">                &#125;</div><div class="line">                if (arr[i][j] &gt; max_len) &#123;</div><div class="line">                    max_len = arr[i][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 找到最有长度最长的子串</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (arr[i][j] == max_len) &#123;</div><div class="line">                // 要注意这里 substr 第二个参数是子串的长度！！！而非结束位置</div><div class="line">                cout &lt;&lt; b.substr(j - max_len + 1, max_len) &lt;&lt; endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是暴力法还是动态规划法都是有一定的技巧的。暴力法主要是注意一下变量是怎么安排的；动态规划法则要搞清楚是如何用时间换空间，如何减轻输出的计算量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
      <category term="算法" scheme="https://blog.patrickcty.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="华科" scheme="https://blog.patrickcty.cc/tags/%E5%8D%8E%E7%A7%91/"/>
    
      <category term="考研" scheme="https://blog.patrickcty.cc/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复试" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>3.5随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/05/3-5%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/05/3-5随想/</id>
    <published>2019-03-05T08:52:36.000Z</published>
    <updated>2019-03-06T14:02:29.947Z</updated>
    
    <content type="html"><![CDATA[<p>今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。</p>
<p>文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。</p>
<p>看到这个我就想到我小学学过的一篇课文，叫做《懒惰的智慧》，其大意就是现在社会的很多发明都是人们为了“偷懒”而产生的。一些机械化的事情我们虽然能做，但真的没必要和机器去争一个高低。</p>
<p>很多程序员都有这样的一个习惯，当遇到一个十分钟就可以完成的纯重复的工作的时候，他们一般不会去选择花十分钟机械地去完成，而是可能回去选择花二十分钟写一个脚本，再花一秒钟来跑这个脚本。</p>
<p>听起来又是另一个极端是不是？但这才是人区别于其他事物的一个重要特点。虽然看起来花费了更多的时间，但是在这个过程中他们可能又接触到了一些平常没怎么用的用法，熟悉了某些新知识；而如果去做机械的工作，就不会有这样的体验了，可能还会影响到心情。当然，对于一些怕麻烦，不想折腾的人来说，即使可能只用花五分钟写脚本，他们或许也不会愿意去写脚本。（其实我有很多时候也是这样的，不过经过多次尝试之后我发现还是写脚本要更加的愉悦，无论是身体上还是心灵上。）</p>
<p>我想说的是，人要找准自己的定位，我们没必要在自己不熟悉的领域和其他的东西来较劲，做好自己的本分工作就好，在一定的约束下，怎么舒服怎么来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。&lt;/p&gt;
&lt;p&gt;文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。&lt;/p&gt;
&lt;p&gt;看到这个我就想到我小学学过的一篇课文，叫
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于我犯二踩到Python环境坑的那些事</title>
    <link href="https://blog.patrickcty.cc/2019/03/05/%E5%85%B3%E4%BA%8E%E6%88%91%E7%8A%AF%E4%BA%8C%E8%B8%A9%E5%88%B0Python%E7%8E%AF%E5%A2%83%E5%9D%91%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://blog.patrickcty.cc/2019/03/05/关于我犯二踩到Python环境坑的那些事/</id>
    <published>2019-03-05T08:18:33.000Z</published>
    <updated>2019-03-05T08:39:03.504Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一个很傻逼的问题上卡了很长时间……现在一定要记录一下这些……同时也提醒以后不要像现在这么傻逼了……</p>
<p>首先这一切傻逼的根本原因都是因为我对 Linux/Unix 环境的一些基本设定很懵逼……</p>
<p>前段时间我的 Python3 环境突然消失不见（现在看来应该是我傻逼的改了环境变量自己不知道），于是我就装了 Anaconda。一开始用的还是很好的，直到那该死的 <code>conda install</code> 命令在 <code>Solving environment</code> 那个地方卡了超久超久，我又开始怀念我原本的 pip 了（其实 Anaconda 也可以用 pip 安装包，只是我傻逼不知道）。</p>
<p>在进行了一些令别人窒息和令我崩溃的操作之后我才知道并不是 Anaconda 把原本的路径给修改掉了，而是系统的寻找命令的机制使得输入 Python 出来的是 Anaconda 的 Python。</p>
<p>系统是根据 <code>$PATH</code> 的路径来寻找命令，越前面的路径越先被找到，比如以下的(忽略里面很多重复的路径……)</p>
<blockquote>
<p>~ echo $PATH<br>~ /usr/bin:/Users/patrick/anaconda3/bin:/Users/patrick/.nvm/versions/node/v8.3.0/bin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/MacOS:/anaconda3/bin:/anaconda2/bin:/Users/patrick/anaconda3/bin:/anaconda3/condabin:/Library/Frameworks/Python.framework/Versions/3.6/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/usr/local/sbin:/usr/local/sbin:/Users/patrick/anaconda3/bin</p>
</blockquote>
<p>路径之间是通过<code>:</code>隔开的。输入 <code>python</code> 命令的话，首先会在 <code>/usr/bin</code> 里面去寻找，没有的话才会到下一个里面去寻找。因为之前 Anaconda 是添加到最前面的，所以就会最先寻找。</p>
<p>最后的解决方案就是把环境变量改成上面这样，这样输入 <code>python</code> 命令就会使用系统自带的 python2，避免了一些依赖旧的 Python2 的包的不兼容，使用 <code>python3</code> 就会使用 Anaconda 的 Python，然后安装包还是使用 pip，这时候的 pip 也是 Anaconda 里面的了。</p>
<p>其实就是一很小的问题，不过因为我石乐志，卡了很久……下次再遇到问题的时候还是要先冷静下来，不然越急躁越容易走向错误的方向，浪费更多的时间……警醒警醒！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在一个很傻逼的问题上卡了很长时间……现在一定要记录一下这些……同时也提醒以后不要像现在这么傻逼了……&lt;/p&gt;
&lt;p&gt;首先这一切傻逼的根本原因都是因为我对 Linux/Unix 环境的一些基本设定很懵逼……&lt;/p&gt;
&lt;p&gt;前段时间我的 Python3 环境突然消失不见（现
    
    </summary>
    
      <category term="其他" scheme="https://blog.patrickcty.cc/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Linux" scheme="https://blog.patrickcty.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>3.3随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/03/3-3%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/03/3-3随想/</id>
    <published>2019-03-03T06:21:53.000Z</published>
    <updated>2019-03-03T07:23:34.947Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了 Z 哥最新一期的视频，又是一篇满满的干货的视频，这次我决定不仅仅只是看，也要记录一下我自己的思考。</p>
<p>首先，何为一双好鞋？对我而言第一点就是帅，其次就是满足我的某种需求，比如：</p>
<ul>
<li>Ultra Boost：跑步</li>
<li>Air Jordan 11：体验 AJ 的最经典款</li>
<li>韦德全城：打篮球</li>
<li>Air Jordan 1：休闲穿搭，情侣鞋</li>
</ul>
<p>这些你对鞋的期待，反映在鞋的身上就是鞋的价值。但鞋的价格和价值很多情况下是不匹配的，比如大牌的某个毫无技术含量的休闲鞋是天价，而某国产品牌最高端的鞋款也才小几百。当然我们也不能仅仅按照物料成本来界定价格，物料成本只是一个基准，比物料成本高的价格才是你应该考虑的部分，这部分就是品牌溢价，包括品牌认知度，球星代言，科技加成，社交价值等等。你是否愿意花这么多钱为品牌溢价买单？如果答案是愿意，那么于你自己而言，就不算亏；如果答案是不愿意，与你自己而言就是亏——尽管所谓的亏可能会让你赚大钱，比如花高价买，然后以更高的价格倒卖。</p>
<p>然而，人总是不理性的，而且商家也在利用我们这一点，制造一些噱头来诱导消费，比如搞一些超限量，或者说是耍猴。这样就会让你有种买到就是赚到的感觉，实际上这个抢到的人不一定喜欢，喜欢的人不一定抢得到，最后最高兴的就是那些倒卖的贩子以及品牌自己了。所以就像 Z 哥一直说的，不是大爱我不买。</p>
<p>再者，追求利益是人的天性，靠球鞋来赚钱是可以的，也有很多贩子就是这样的，甚至很多玩鞋的也成了鞋贩子。但这样一来不近搅浑了球鞋市场，还让那些真正喜欢鞋的人很难受，就只有那些看见有好处捞一笔的贩子受益了。现在球鞋市场的繁荣只是暂时的，就像其他很多的市场一样，现在的所有炒作都是在给这个市场增加泡沫，当什么时候这些泡沫消散就是一个正常市场出现的时候。</p>
<p>关于应不应该通过这种说得好听叫把握机会，说得难听叫投机的方式来赚钱，我个人是不喜欢通过这种方式的。你们可以说我是懒，或是缺乏远见等等。但一是我真的很不喜欢这样折腾，因为一旦兴趣爱好和钱沾上关系，那它很大可能就会变质；二是这本来就是一个畸形的市场，很多人以为能进来捞钱，结果只是进来变成了韭菜。除非你真的对形势洞察得特别清晰，否则还是不要轻易趟这趟浑水，比如股市，比如区块链。</p>
<p>思维再发散一下，很多人在做选择的时候总是不经过思考，或是思考太浅，没有深入到事物的本质。当然我的大多数选择就是这样决定下来的，就比如最让我后悔的大学选择。选择什么样的大学，我们应该重点考虑这两个问题：</p>
<ul>
<li>读大学的目的是什么？<ul>
<li>学习？</li>
<li>结交人脉？</li>
<li>读研深造？</li>
<li>出国深造？</li>
<li>就业？</li>
<li>享受青春？</li>
</ul>
</li>
<li>大学的哪些因素能让我的目的更好的实现？<ul>
<li>品牌效应？</li>
<li>人脉资源？</li>
<li>硬件环境？</li>
<li>机会数量？</li>
</ul>
</li>
</ul>
<p>而另外的一些感性的因素，比如我喜欢某个城市，某个大学漂亮妹子比较多，某个大学食堂很好吃等等因素应该仅仅只是作为锦上添花的部分。但是我们往往会因为这些感性的因素来作出决定，比如我就因为我喜欢广州而只有暨大够分就来了这个计算机氛围极差的文科学校。诚然，由于信息的不对称，你可能需要耗费很大的力气才能完成挑选，但假如你真正花了很大力气来挑选，真正搞清楚自己的需求，你就不会因为另一个学校的伙食比较好而觉得遗憾了。</p>
<p>选大学，以及以后的选工作和选球鞋还不一样，不能仅仅因为“品牌溢价”而买单，这种涉及到你自身的前途的选择，就应该从未来发展的角度来考虑。这足够困难，因为几乎没有高中毕业的学生会想到考研保研的事情，他们更不会知道你所谓的一个差学校好专业会在调剂筛选、复试的时候就是比那些好学校的差专业要低一等。不过这也不是不能弥补的，人生中还是有很多节点能让你改变命运，只是你需要付出更多来弥补你之前的不恰当的选择罢了。</p>
<p>最重要的一点就是思考，无论干什么都要多思考，你思考得越透彻，越深入，你就越有可能把差的影响降到最低，甚至还能获得意想不到的收获。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了 Z 哥最新一期的视频，又是一篇满满的干货的视频，这次我决定不仅仅只是看，也要记录一下我自己的思考。&lt;/p&gt;
&lt;p&gt;首先，何为一双好鞋？对我而言第一点就是帅，其次就是满足我的某种需求，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ultra Boost：跑步&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="球鞋" scheme="https://blog.patrickcty.cc/tags/%E7%90%83%E9%9E%8B/"/>
    
      <category term="选择" scheme="https://blog.patrickcty.cc/tags/%E9%80%89%E6%8B%A9/"/>
    
      <category term="思考" scheme="https://blog.patrickcty.cc/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="ZGNB" scheme="https://blog.patrickcty.cc/tags/ZGNB/"/>
    
  </entry>
  
  <entry>
    <title>Screentone Removal 理解</title>
    <link href="https://blog.patrickcty.cc/2019/03/02/%E5%AE%9E%E7%8E%B0Screentone-Removal/"/>
    <id>https://blog.patrickcty.cc/2019/03/02/实现Screentone-Removal/</id>
    <published>2019-03-02T02:20:27.000Z</published>
    <updated>2019-03-02T02:27:40.377Z</updated>
    
    <content type="html"><![CDATA[<p>理解论文<a href="https://www.researchgate.net/publication/277653033" target="_blank" rel="external">《Separation of Manga Line Drawings and Screentones》</a>中的算法。</p>
<h2 id="Screentone-removal-mask"><a href="#Screentone-removal-mask" class="headerlink" title="Screentone removal mask"></a>Screentone removal mask</h2><h3 id="计算-LoG-过滤后的值"><a href="#计算-LoG-过滤后的值" class="headerlink" title="计算 LoG 过滤后的值"></a>计算 LoG 过滤后的值</h3><p>论文中采用高斯拉普拉斯滤波（Laplacian of Gaussian Filter）来作为去除网点的 Mask，这是由于 LoG 过滤器有以下特点：</p>
<ul>
<li>过滤之后，线条处值比较大，其他地方值比较小</li>
<li>过滤之后值为负数的像素不太可能是线条</li>
</ul>
<h3 id="处理过滤后图像"><a href="#处理过滤后图像" class="headerlink" title="处理过滤后图像"></a>处理过滤后图像</h3><ul>
<li>将过滤后图像中的负数置零</li>
</ul>
<h3 id="二值化过滤后的图像"><a href="#二值化过滤后的图像" class="headerlink" title="二值化过滤后的图像"></a>二值化过滤后的图像</h3><p>所谓二值化就是按照一个门槛值，把大于某个临界灰度值的像素灰度设为灰度极大值，把小于这个值的像素灰度设为灰度极小值。需要注意的是，二值化只能在灰度图片中进行。</p>
<p>论文中使用<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95" target="_blank" rel="external">大津法</a>产生自适应阈值。</p>
<h3 id="自适应选取窗口值算法"><a href="#自适应选取窗口值算法" class="headerlink" title="自适应选取窗口值算法"></a>自适应选取窗口值算法</h3><p>使用 LoG 需要接受窗口值来作为参数，LoG 也是基于高斯函数，即正态分布函数，正态分布函数需要接受 σ 作为参数。函数的标准差 σ 越大，函数越平缓（分布较为分散），σ 越小函数越尖（分布更集中）。</p>
<p>而窗口大小，也就是卷积核的长宽可以通过正态分布的特点来确定，因为太远的地方函数的数值可以忽略不计。二者相互换算的公式可以看<a href="https://blog.shinelee.me/2018/09-19-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%A0%87%E5%87%86%E5%B7%AE%E5%92%8C%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.html" target="_blank" rel="external">这篇博客</a>，具体公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\sigma = 0.3 \times ((ksize - 1) \times 0.5 - 1) + 0.8</div></pre></td></tr></table></figure>
<p>该算法则是为了自适应地选取窗口大小来计算 LoG 的值。</p>
<h4 id="评判标准与一些指标"><a href="#评判标准与一些指标" class="headerlink" title="评判标准与一些指标"></a>评判标准与一些指标</h4><ul>
<li>连通域标准（Connected  Component Criteria，CCC）</li>
<li>停止标准（Stop Criteria， STC）</li>
<li>连通分量数（Number of Connected Component， NCC）</li>
</ul>
<p>公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CCC_i = 1 - \frac&#123;NCC(M_&#123;LoG_i&#125;)&#125;&#123;NCC(M_&#123;LoG_&#123;i - 2&#125;&#125;)&#125;</div><div class="line"></div><div class="line">STC_i = \frac&#123;NCC(M_&#123;LoG_i&#125;)&#125;&#123;NCC(M_&#123;LoG_1&#125;)&#125; \times |NCC(M_&#123;LoG_i&#125;) - NCC(M_&#123;LoG_&#123;i - 2&#125;&#125;)|</div></pre></td></tr></table></figure>
<p>其中 <code>$CCC_i$</code> 显示随着 i 的增加连通域的下降，当其取得最大值的时候表示此时网点去除效果最好。论文中指出，当有多个峰值的时候，更大的 i 会有更好的结果，因此设置参数 β = 0.8 来获得更大的 i 值，称为松弛因子。</p>
<p><code>$STC_i$</code> 表示停止的条件，如果数值小于门槛值（一般设为 α = 0.8）就会停止。它用来显示当前 i 的连通区域的数量变化情况。</p>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>通过迭代，在 STC 大于门槛的情况下，取得最大的 CCC。</p>
<p>在得到最好的 i 值之后，论文中指出，实际情况当 i 比计算出来的值大一些时能取到更好的效果。</p>
<p>而当有黑色网点，且 i 过大时，线条会太粗，于是引入 <code>$i_{base}$</code> 来处理这种情况，让结果的线条更细。</p>
<p>以上公式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i_&#123;LoG&#125; += 4</div><div class="line"></div><div class="line">i_&#123;base&#125; = min(\frac&#123;i&#125;&#123;2&#125;, i_&#123;LoG&#125;)</div><div class="line"></div><div class="line">M_&#123;rm&#125; = M_&#123;LoG_i&#125; \wedge M_&#123;LoG_&#123;i_&#123;base&#125;&#125;&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://static.jnugeek.cn/image/notes/remove_mask.png" alt="result"></p>
<h2 id="Line-preserving-mask"><a href="#Line-preserving-mask" class="headerlink" title="Line preserving mask"></a>Line preserving mask</h2><h2 id="Mask-merging-for-reﬁning-line-extraction"><a href="#Mask-merging-for-reﬁning-line-extraction" class="headerlink" title="Mask merging for reﬁning line extraction"></a>Mask merging for reﬁning line extraction</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解论文&lt;a href=&quot;https://www.researchgate.net/publication/277653033&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Separation of Manga Line Drawings and Sc
    
    </summary>
    
      <category term="图像处理" scheme="https://blog.patrickcty.cc/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Manga" scheme="https://blog.patrickcty.cc/tags/Manga/"/>
    
      <category term="Image Processing" scheme="https://blog.patrickcty.cc/tags/Image-Processing/"/>
    
  </entry>
  
</feed>
