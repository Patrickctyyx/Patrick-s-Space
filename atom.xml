<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2017-08-08T12:55:33.552Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再次理解Flask中登录与用户角色</title>
    <link href="https://blog.patrickcty.cc/2017/08/08/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E7%99%BB%E5%BD%95%E4%B8%8E%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2/"/>
    <id>https://blog.patrickcty.cc/2017/08/08/再次理解Flask中登录与用户角色/</id>
    <published>2017-08-08T12:31:17.000Z</published>
    <updated>2017-08-08T12:55:33.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中登录与用户角色"><a href="#再次理解-Flask-中登录与用户角色" class="headerlink" title="再次理解 Flask 中登录与用户角色"></a>再次理解 Flask 中登录与用户角色</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录由以下几个部分构成：</p>
<ul>
<li>填写表单</li>
<li>验证用户信息是否正确</li>
<li>保存登录状态</li>
</ul>
<h3 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h3><p>填写表单这个应该没什么好说的，但是可以让表单更高级——加入验证码。</p>
<p>在这里我是用的 GeeTest。</p>
<p>接入方法：</p>
<ul>
<li>在其官网下载对应语言的 SDK，其中 Python 的 SDK 包括一个 geetest 的包以及一个用来注入到 HTML 中的 js 文件</li>
<li><p>在 HTML 中给验证码留出相应的位置，第一个控标签除就是验证码所在标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;col s12&quot; id=&quot;embed-captcha&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div class=&quot;col s12&quot;&gt;</div><div class="line">    &lt;p id=&quot;wait&quot; class=&quot;show&quot; style=&quot;color: #ee6e73&quot;&gt;正在加载验证码......&lt;/p&gt;</div><div class="line">    &lt;p id=&quot;notice&quot; class=&quot;hide&quot; style=&quot;color: red&quot;&gt;请先拖动验证码到相应位置&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>引入所给 js 文件，并且进行初始化，这部分只用复制下面的结构然后稍微改动即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;js/gt.js&apos;) &#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">        var handlerEmbed = function (captchaObj) &#123;</div><div class="line">            $(&quot;#embed-submit&quot;).click(function (e) &#123;</div><div class="line">                var validate = captchaObj.getValidate();</div><div class="line">                if (!validate) &#123;</div><div class="line">                    $(&quot;#notice&quot;)[0].className = &quot;show&quot;;</div><div class="line">                    setTimeout(function () &#123;</div><div class="line">                        $(&quot;#notice&quot;)[0].className = &quot;hide&quot;;</div><div class="line">                    &#125;, 2000);</div><div class="line">                    e.preventDefault();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            // 将验证码加到id为captcha的元素里，同时会有三个input的值：geetest_challenge, geetest_validate, geetest_seccode</div><div class="line">            captchaObj.appendTo(&quot;#embed-captcha&quot;);</div><div class="line">            captchaObj.onReady(function () &#123;</div><div class="line">                $(&quot;#wait&quot;)[0].className = &quot;hide&quot;;</div><div class="line">            &#125;);</div><div class="line">            // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html</div><div class="line">        &#125;;</div><div class="line">        $.ajax(&#123;</div><div class="line">            // 获取id，challenge，success（是否启用failback）</div><div class="line">            url: &quot;/pc-geetest/register?t=&quot; + (new Date()).getTime(), // 加随机数防止缓存</div><div class="line">            type: &quot;get&quot;,</div><div class="line">            dataType: &quot;json&quot;,</div><div class="line">            success: function (data) &#123;</div><div class="line">                // 使用initGeetest接口</div><div class="line">                // 参数1：配置参数</div><div class="line">                // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件</div><div class="line">                initGeetest(&#123;</div><div class="line">                    gt: data.gt,</div><div class="line">                    challenge: data.challenge,</div><div class="line">                    product: &quot;embed&quot;, // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效</div><div class="line">                    offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注</div><div class="line">                    width: &apos;25%&apos;</div><div class="line">                    // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config</div><div class="line">                &#125;, handlerEmbed);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>验证验证码状态（其实这部分也不用添加，不过添加了能更进一步提升可靠性，具体参阅官方文档）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># 这个视图函数必须添加</div><div class="line">@main_blueprint.route(&apos;/pc-geetest/register&apos;, methods=[&apos;GET&apos;])</div><div class="line">def get_pc_captcha():</div><div class="line">    gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">    status = gt.pre_process()</div><div class="line">    session[gt.GT_STATUS_SESSION_KEY] = status</div><div class="line">    response_str = gt.get_response_str()</div><div class="line">    return response_str</div><div class="line"></div><div class="line"></div><div class="line">@main_blueprint.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    form = LoginForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        # 这下面添加了能提升可靠性，也可以不添加</div><div class="line">        gt = GeetestLib(Config.pc_id, Config.pc_key)</div><div class="line">        challenge = request.form[gt.FN_CHALLENGE]</div><div class="line">        validate = request.form[gt.FN_VALIDATE]</div><div class="line">        seccode = request.form[gt.FN_SECCODE]</div><div class="line">        status = session[gt.GT_STATUS_SESSION_KEY]</div><div class="line">        if status:</div><div class="line">            result = gt.success_validate(challenge, validate, seccode)</div><div class="line">        else:</div><div class="line">            result = gt.failback_validate(challenge, validate, seccode)</div><div class="line">        ...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="验证用户信息"><a href="#验证用户信息" class="headerlink" title="验证用户信息"></a>验证用户信息</h3><p>平常我们都是在视图函数中来检验密码是否是正确，但实际上和验证表单内容是否合法一样，这个工作也可以在表单类中完成。</p>
<p>我们在视图函数中通过 form.validate_on_submit 来检查表单是否被成功提交，实际上在返回结果之前我们要先调用 form.validate 函数，也正是在这里面，我们完成对表单内容合法性和密码正确性的检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class LoginForm(FlaskForm):</div><div class="line">    username = StringField(&apos;用户名&apos;, [DataRequired(), Length(max=255)])</div><div class="line">    password = PasswordField(&apos;密码&apos;, [DataRequired()])</div><div class="line">    remember_me = BooleanField(&apos;记住登录状态&apos;)</div><div class="line"></div><div class="line">    def validate(self):  # 在 validate_on_submit 的时候会检查</div><div class="line">        check_validate = super(LoginForm, self).validate()</div><div class="line"></div><div class="line">        if not check_validate:</div><div class="line">            return False</div><div class="line"></div><div class="line">        user = User.query.filter_by(username=self.username.data).first()</div><div class="line">        if not user:</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        if not user.verify_password(self.password.data):</div><div class="line">            self.username.errors.append(&apos;用户名或密码错误&apos;)</div><div class="line">            return False</div><div class="line"></div><div class="line">        return True</div></pre></td></tr></table></figure>
<p>如果出现了错误则只用把它添加到相应表单的 errors 中去，然后就可以在 HTML 中显示出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;input-field col s12&quot;&gt;</div><div class="line">    &#123;&#123; form.password.label &#125;&#125;</div><div class="line">    &#123;&#123; form.password(class_=&apos;validate&apos;) &#125;&#125;</div><div class="line">    &#123;% if form.password.errors %&#125;</div><div class="line">        &#123;% for e in form.password.errors %&#125;</div><div class="line">            &lt;p class=&quot;help-block alert-danger&quot;&gt;&#123;&#123; e &#125;&#125;&lt;/p&gt;</div><div class="line">        &#123;% endfor %&#125;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="保存登录状态"><a href="#保存登录状态" class="headerlink" title="保存登录状态"></a>保存登录状态</h3><p>最基本的方法当然是使用 session 来保存，然后通过判断 session 是否有相应的信息来检查是否登录处于状态。</p>
<p>比较常用也是进阶的就是使用 flask-login 了。</p>
<p>使用 flask-login 需要根据模块来进行一定的配置：</p>
<ul>
<li>对 User 类实现特定的方法，这里可以通过继承 UserMixin 来简化，但是要注意如果用户 id 的格式和默认的不同则还是要重写 get_id 方法</li>
<li>定义登陆的视图，load_user 函数等<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">login_manger = LoginManager()</div><div class="line">login_manger.login_view = &apos;main.login&apos;</div><div class="line">login_manger.session_protection = &apos;strong&apos;</div><div class="line">login_manger.login_message = &apos;请登录以访问该页面&apos;</div><div class="line">login_manger.login_message_category = &apos;info&apos;</div><div class="line"></div><div class="line"></div><div class="line">@login_manger.user_loader</div><div class="line">def load_user(userid):</div><div class="line">    from .models import User</div><div class="line">    return User.query.get(userid)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h2><p>要使用用户权限，则要进行用户角色的相应配置，在这里可以使用 flask-principal 模块来对用户权限进行管理。</p>
<p>当然我们要先建立一张表来控制用户和用户角色的多对多关系，在建立数据库之后不要忘记初始化角色表。</p>
<p>flask-principal 的关键名词主要有 Identity，Permission，Need。其中 Identity 和 Permission 都是通过 Need 来实现功能。Need 则是一些 namedtuple（相当于 C 语言中的结构体），包括 method 和 value 两个属性，定义了每种身份可以干什么。</p>
<p>例如 UserNeed 的 method 默认则是 id，key 则应该传入对应用户的 id 值，而 RoleNeed 的 method 的默认值则是 role，key 的默认值应该是 role 的名称。其中 UserNeed 和 RoleNeed 是通过 partical 固定了 Need 的一个参数。点击查看 <a href="http://www.jb51.net/article/87059.htm" target="_blank" rel="external">nametuple</a> 和 <a href="http://www.wklken.me/posts/2013/08/18/python-extra-functools.html" target="_blank" rel="external">partical</a> 用法。</p>
<p>Identity 是通过 user.id 来进行初始化的，然后此时会自动调用自己定义的初始化函数把需要添加的 Need 添加进这个 Identity 中。</p>
<p>在 __init__.py 中定义这个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@identity_loaded.connect_via(app)</div><div class="line">def on_identity_loaded(sender, identity):</div><div class="line">    identity.user = current_user</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;id&apos;):</div><div class="line">        identity.provides.add(UserNeed(current_user.id))</div><div class="line"></div><div class="line">    if hasattr(current_user, &apos;roles&apos;):</div><div class="line">        for role in current_user.roles:</div><div class="line">            identity.provides.add(RoleNeed(role.name))</div></pre></td></tr></table></figure></p>
<p>而当用户登录登出时 Identity 应该发生改变，此时应该调用 identity_changed 方法来发送信号，此时就会调用 on_identity_loaded 函数来进行新 Identity 的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">identity_changed.send(</div><div class="line">    current_app._get_current_object(),</div><div class="line">    identity=Identity(user.id)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>而 Permission 则是通过 Need 来进行初始化，这些 Need 就表示当前权限所需的角色，只有满足了相应的角色才能达到相应权限。</p>
<p>初始化 Permission<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">admin_permission = Permission(RoleNeed(&apos;admin&apos;))</div><div class="line">poster_permission = Permission(RoleNeed(&apos;poster&apos;))</div><div class="line">default_permission = Permission(RoleNeed(&apos;default&apos;))</div></pre></td></tr></table></figure></p>
<p>使用 Permission 的方法：</p>
<ul>
<li><p>使用初始化权限的装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@login_required</div><div class="line">@poster_permission.require(http_exception=403)</div><div class="line">def edit(id):</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
<li><p>使用 Permission.can() 来判断是否符合权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">permission = Permission(UserNeed(post.user.id))</div><div class="line"></div><div class="line"># 发布者和管理员都有权限</div><div class="line">if permission.can() or admin_permission.can():</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中登录与用户角色&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中登录与用户角色&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中登录与用户角色&quot;&gt;&lt;/a&gt;再次理解 Flask 中登录与用户角色&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>《卑鄙的我3》</title>
    <link href="https://blog.patrickcty.cc/2017/08/06/%E3%80%8A%E5%8D%91%E9%84%99%E7%9A%84%E6%88%913%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/06/《卑鄙的我3》/</id>
    <published>2017-08-06T12:26:34.000Z</published>
    <updated>2017-08-06T12:29:43.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《卑鄙的我-3》"><a href="#《卑鄙的我-3》" class="headerlink" title="《卑鄙的我 3》"></a>《卑鄙的我 3》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>又是一部新的卑鄙的我，当它上映的时候我就决定去看看，一是因为小黄人，再者则是格鲁在前作中给人的印象太深刻。</p>
<p>虽然在国内这部电影的名字被翻译成了神偷奶爸，但是我还是更愿意称它为卑鄙的我，但是当卑鄙的我不再卑鄙，这部电影又是否保留着原来的惊喜呢？</p>
<p>在刚开始看电影的时候我就有一种强烈的看过的感觉，原来是很久之前看的预告片，但回想起来看了预告片之后，正片反而没什么惊喜可言了……</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>关于上面的问题，答案是没有惊喜。在这一部里，格鲁已经从良，并因为任务失败被赶出了反恶人联盟。而此时格鲁则像一个遭遇了失业危机的中年男人，完全没有了作为一个反派的那种个性十足的感觉。</p>
<p>因为家庭元素的发展，特别是露西的出现，使得格鲁失去了重新成为坏人的可能，所以这一部的发展，也完全被这样的条件所限制住。但编剧为了冲破这样的限制，又让格鲁在他孪生弟弟面前演了一次坏人，不过这也无力回天，因为已经没有了坏人的灵魂，所以这部分注定不会那么精彩。</p>
<p>而作为本片的一大看点，小黄人的戏份却着实的少，甚至都没能出现在主线中。而小黄人的出走，似乎是编剧自己在吐槽格鲁从良这一设定。不过小黄人出现的地方还是保持了之前萌萌的风格，也算是本片为数不多的亮点了吧。</p>
<p>而露西和格鲁的女儿们的戏份简直可有可无，格鲁的女儿也没有把第一二部时的的萌萌的感觉再表现出来，它们的出场，似乎只是为了把时间给拖住，不然片长恐怕就不够了。</p>
<p>至于德鲁，不得不说人和人之间总是有差距 233。他的出场是一个亮点，然而这部分在预告片里面已经播出了，这就进一步减小了戏剧性……不过他的耍宝的风格还是带来了不少的欢乐，也正是有了他，才让格鲁的行动不那么轻松无趣，也让剧情不那么沉闷。我倒是很期待他在后作中和小黄人们一起四处做坏事，只是不知道他的技巧会不会有所长进 233，不然就 GG 了 233。至于德鲁的话，还是让他在家享受天伦之乐吧 233。</p>
<p>卑鄙的我系列其实到第二部就应该算作结束了，不过只要小黄人在，就不用担心没有故事可讲，期待小黄人大眼萌的续作～</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>7/10.</p>
<p>小黄人依旧精彩，但是德鲁已经失去了之前的魅力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《卑鄙的我-3》&quot;&gt;&lt;a href=&quot;#《卑鄙的我-3》&quot; class=&quot;headerlink&quot; title=&quot;《卑鄙的我 3》&quot;&gt;&lt;/a&gt;《卑鄙的我 3》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="小黄人" scheme="https://blog.patrickcty.cc/tags/%E5%B0%8F%E9%BB%84%E4%BA%BA/"/>
    
      <category term="卑鄙的我" scheme="https://blog.patrickcty.cc/tags/%E5%8D%91%E9%84%99%E7%9A%84%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>《蝙蝠侠：黑暗骑士》</title>
    <link href="https://blog.patrickcty.cc/2017/08/05/%E3%80%8A%E8%9D%99%E8%9D%A0%E4%BE%A0%EF%BC%9A%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/08/05/《蝙蝠侠：黑暗骑士》/</id>
    <published>2017-08-05T03:35:13.000Z</published>
    <updated>2017-08-05T03:38:47.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《蝙蝠侠：黑暗骑士》"><a href="#《蝙蝠侠：黑暗骑士》" class="headerlink" title="《蝙蝠侠：黑暗骑士》"></a>《蝙蝠侠：黑暗骑士》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>都说诺兰是鬼才导演，这话真的不夸张。从我最早看的《蝙蝠侠：黑暗骑士的崛起》（那时候看的还是枪版，虽然画面模模糊糊，不过剧情真的感觉很不错，特别是蝙蝠侠在谷底挣扎的情景。不过因为年代久远，影片剧情都记不太清了，因此决定以后再刷一遍～），到之后看的《致命魔术》（当时真的感觉剧情碉堡了，不过因为是在学校看的，所以剧情可能有的地方错过了，同样决定再刷一遍～），再到之后看的《星际穿越》（这部充满物理知识的科幻片对于我这个理科男真的十分有吸引力，剧情也一如既往的神～），再就是之后看的《记忆碎片》（也是一部神片，拍摄手法真的是无敌，看完之后还是一脸懵逼，最终还是根据影评才梳理清楚了剧情 233），他的每一部电影都有不同的魔力，却又都有共同点，那就是剧情精彩，令人回味。</p>
<p>这晚我又十分想看电影，但又苦于近期没什么好看的电影，于是在豆瓣 Top 250 上寻找，看到了这一部之后我就知道我想看的是什么了。同时这一部是小丑加持，人们都说小丑塑造了反派的巅峰，之前小丑扮演者去世周年的时候还引发了一阵朋友圈悼念狂潮，这样的电影，当然要好好看一看～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>蝙蝠侠电影历来都是比较黑暗的，蝙蝠侠所在的城市高谭市给人的印象也总是充满了犯罪，即使有了蝙蝠侠的存在。而在本部电影中充满正义感的检察官哈维·登特的登场，使得蝙蝠侠的任务变得轻松起来。但是这个时候小丑出现了，小丑和蝙蝠侠就好像是正义和邪恶的两个极端。蝙蝠侠在现实生活中是一个亿万富翁，因此他成为蝙蝠侠的目的不是为了金钱和名誉，而是为了自己贯彻的理念，而类似的是，小丑嫌弃犯罪狂潮，也不是为了金钱地位，而是纯粹为了报复社会，让社会陷入混乱。也正是因为有了蝙蝠侠的映衬，小丑的形象才会这么丰满，但小丑也正是抓住了蝙蝠侠的弱点，才能如此肆无忌惮。</p>
<p>小丑是一个精通犯罪学的人，他能在一次次的行动中把所有人都戏耍得团团转，无论是各个黑帮大佬，还是警察局的各位，甚至连民众舆论以及蝙蝠侠都被他戏耍。从他第一次登场抢劫银行的情景就能察觉到，他抓住了同伙贪婪的心理，让他们除掉会分走自己钱的同伙，从而使受益者只有他一个。</p>
<p>小丑强就强大在他强大的威慑能力，他通过蝙蝠侠威慑了那一群黑帮大佬，使他们能与自己合作。而他通过同样的手段威慑了法官，警察局长他们身边的人，又用法官和局长的死亡进一步威慑了正义和群众。而他又通过“不交出蝙蝠侠则每天杀一个人”成功地把矛盾引向了蝙蝠侠，一瞬间保卫城市的黑暗骑士变成了威胁他们生存的存在。</p>
<p>此时还有两个关键，一个是哈维，一个是瑞秋。哈维是新上任到高谭市的白色骑士，是光明中的正义的象征，他为了正义不惧死亡，但这样的他实际上也并不是绝对正义，而“双面人”的称号也正是因为他的一些和正面形象完全不同的动作而形成的，这从他用私刑来逼供刺杀市长的犯人可以窥见——尽管硬币的两面都是正面，也就是说他并不会真的杀掉犯人。只是在这时他的另一面在外部环境的影响下控制得很好。</p>
<p>而小丑说过：“疯狂与混乱本身拥有着强大的引力。有时需要的只是轻轻一推。”，小丑要做的，就是轻轻地推动，让正义的象征哈维和蝙蝠侠堕入黑暗，那么他的目的就完美达到了。</p>
<p>故事真正的高潮是在刺杀市长事件之后蝙蝠侠被逼到了绝境，此时因为小丑的威慑，人民的矛盾都指向了蝙蝠侠，蝙蝠侠只得显出真身来平息民众的恐惧，而崇拜蝙蝠侠的哈维则决定以自己为诱饵，让蝙蝠侠抓住小丑。当蝙蝠侠就要抓到小丑的时候，小丑却利用了蝙蝠侠的底线——不杀人成功让蝙蝠侠没有撞向他而是偏离了方向。</p>
<p>而另一个关键瑞秋则是小丑用来操控蝙蝠侠和哈维的重要工具，因为两人都很爱她，她成为了两人的软肋。小丑就利用了这一点先让蝙蝠侠在哈维和瑞秋之间做出选择，只能拯救一个，而之后故意告诉错误地点的他则让蝙蝠侠没能救出所爱瑞秋而陷入了深深的自责，也让哈维精神崩溃。在这场事故中哈维的半边脸也被烧毁，成为了真正的“双面人”。</p>
<p>尽管小丑很想除掉蝙蝠侠，但是当真正想公布蝙蝠侠身份的人出现后他却要人们杀掉他，否则炸掉医院。当然从小丑的作风来不管结果如何，医院一定会被炸掉，因为他追求的是混乱和黑暗。哈维的黑暗，在和小丑的交谈中被真正触发了，他没有杀掉始作俑者小丑，却向间接害死瑞秋的人寻仇。最终哈维在处决戈登的时候被蝙蝠侠推下楼死亡，蝙蝠侠则背上了罪名，消失了……</p>
<p>小丑成功的地方就是他的疯狂，他用他疯狂却又实际上抓住弱点的行为来操控了其他人，达到自己的目的。而他的伎俩让蝙蝠侠陷入迷茫，让哈维堕入黑暗。虽然他最后败在了蝙蝠侠手上，但是实际上是他赢了。因为他所在意的，从在都不是他的性命，也正是这让他如此疯狂又可怕。而蝙蝠侠最后选择背负罪名，则让小丑胜利的影响降到了最低——民众没有失去战胜黑暗的信心。</p>
<p>而小丑也不是次次都胜利，在炸掉逃生船的社会实验中，最终两艘船都选择了不去按起爆按钮，这次人们没有被小丑威慑住，因为有更深的东西威慑到了他们——人性，按下了按钮则表示你要对另一条船的所有生命负责。因此即使是一开始吵着要按下按钮的秃头大叔，到最后真正有执行权的时候却也不敢下手。而更令我惊讶的是黑帮大佬在拿到起爆器之后居然直接将其丢向了窗外，这里真的值得深思。或许善恶之间真的没有那么多界限，所谓的善人，不也吵吵嚷嚷要按照小丑要求处决他人，而所谓的恶人，在最考验人性的地方却又安静了下来做出了令人意想不到的选择。</p>
<p>这部电影对人性的思考是十分深刻的，其中刻画的小丑，蝙蝠侠，哈维都十分成功，而网上的口碑也真的不是吹出来的。不过整体电影有点偏长，也有点过于神化小丑，但这些无伤大雅的小毛病也不应该被过多计较。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>9/10.</p>
<p>是一部值得思考的不一样的商业片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;a href=&quot;#《蝙蝠侠：黑暗骑士》&quot; class=&quot;headerlink&quot; title=&quot;《蝙蝠侠：黑暗骑士》&quot;&gt;&lt;/a&gt;《蝙蝠侠：黑暗骑士》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;head
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="蝙蝠侠" scheme="https://blog.patrickcty.cc/tags/%E8%9D%99%E8%9D%A0%E4%BE%A0/"/>
    
      <category term="人性" scheme="https://blog.patrickcty.cc/tags/%E4%BA%BA%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask 中视图函数的用法</title>
    <link href="https://blog.patrickcty.cc/2017/08/02/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask%E4%B8%AD%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>https://blog.patrickcty.cc/2017/08/02/再次理解Flask中视图函数的用法/</id>
    <published>2017-08-02T14:24:00.000Z</published>
    <updated>2017-08-02T14:25:12.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-中视图函数的用法"><a href="#再次理解-Flask-中视图函数的用法" class="headerlink" title="再次理解 Flask 中视图函数的用法"></a>再次理解 Flask 中视图函数的用法</h1><h2 id="使用类描述视图"><a href="#使用类描述视图" class="headerlink" title="使用类描述视图"></a>使用类描述视图</h2><p>在 Flask 应用中，通常是用函数来描述视图的，但是如果多个函数都用到某些通用功能则用类实现视图就非常方便。</p>
<p>多个视图函数都要渲染模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">from flask.views import View</div><div class="line"></div><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">        super(GenericView, self).__init__()</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        page = 1</div><div class="line">        posts = Post.query.order_by(</div><div class="line">            Post.publish_time.desc()</div><div class="line">        ).paginate(page, 10)</div><div class="line">        recent, top_tags = sidebar_data()</div><div class="line"></div><div class="line">        return render_template(</div><div class="line">            self.template,</div><div class="line">            posts=posts,</div><div class="line">            recent=recent,</div><div class="line">            top_tags=top_tags</div><div class="line">        )</div><div class="line"></div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;home.html&apos;</div><div class="line">    )</div><div class="line">)</div><div class="line"></div><div class="line">app.add_url_rule(</div><div class="line">    # 第一个参数是 url</div><div class="line">    &apos;/test2&apos;,</div><div class="line">    view_func=GenericView.as_view(</div><div class="line">        &apos;test&apos;,  # 指定 endpoint</div><div class="line">        template=&apos;index.html&apos;</div><div class="line">    )</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果要使用多种 HTTP 方法，则定义类属性 methods<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class GenericView(View):  # 定义视图类，减少重复</div><div class="line">    methods = [&apos;GET&apos;, &apos;POST&apos;]  # 定义为类属性</div><div class="line">    </div><div class="line">    def __init__(self, template):</div><div class="line">        ...</div><div class="line"></div><div class="line">    # 作用和普通视图函数相同</div><div class="line">    def dispatch_request(self):</div><div class="line">        if request.method == &apos;GET&apos;:</div><div class="line">            ...</div><div class="line">        elif request.method == &apos;POST&apos;:</div><div class="line">            ...</div></pre></td></tr></table></figure></p>
<h2 id="使用方法视图"><a href="#使用方法视图" class="headerlink" title="使用方法视图"></a>使用方法视图</h2><p>方法视图允许把每种 HTTP 请求的处理函数写成一个同名的类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from flask.views import MethodView</div><div class="line"></div><div class="line">class UserView(MethodView):</div><div class="line">    def get(self):</div><div class="line">        ...</div><div class="line">    def post(self):</div><div class="line">        ...</div><div class="line">    def put(self):</div><div class="line">        ...</div><div class="line">        </div><div class="line">app.add_url_rule(&apos;/user&apos;, view_func=UserView.as_view(&apos;user&apos;))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-中视图函数的用法&quot;&gt;&lt;a href=&quot;#再次理解-Flask-中视图函数的用法&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask 中视图函数的用法&quot;&gt;&lt;/a&gt;再次理解 Flask 中视图函数的用法&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/Flask/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>再次理解 Flask-SQLAlchemy 中数据模型之间的关联</title>
    <link href="https://blog.patrickcty.cc/2017/07/29/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3Flask-SQLAlchemy%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94/"/>
    <id>https://blog.patrickcty.cc/2017/07/29/再次理解Flask-SQLAlchemy中数据模型之间的关联/</id>
    <published>2017-07-29T03:07:09.000Z</published>
    <updated>2017-08-02T14:24:40.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再次理解-Flask-SQLAlchemy-中数据模型之间的关联"><a href="#再次理解-Flask-SQLAlchemy-中数据模型之间的关联" class="headerlink" title="再次理解 Flask-SQLAlchemy 中数据模型之间的关联"></a>再次理解 Flask-SQLAlchemy 中数据模型之间的关联</h1><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>Post 表示博客的文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Post(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line">    text = db.Column(db.Text())</div><div class="line">    publish_date = db.Column(db.Datetime())</div><div class="line">    # 外键的参数是&apos;表名.主键&apos;</div><div class="line">    # 也可以是类名.主键（不是字符串）</div><div class="line">    user_id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;))  </div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div></pre></td></tr></table></figure></p>
<p>User 表示用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    posts = db.relationship(  # 是一个 list，内容是该作者的所有 post 的对象</div><div class="line">        &apos;Post&apos;,  # Post 此时可能还没定义，所以用字符串作为参数传递</div><div class="line">        backref=&apos;user&apos;,</div><div class="line">        # 查询方式，dynamic 表示动态加载</div><div class="line">        # 这样在加载完 Post 的时候并不立刻加载与其关联的 User</div><div class="line">        # 而是在被使用时才加载</div><div class="line">        lazy=&apos;dynamic&apos; </div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>在一个典型的博客系统中，一篇文章的作者只有一个，而一个作者可能有多篇文章，因此 Post 通过外键与 User 建立了联系，User.id 作为了 Post 表的一列存在了表中。而 User 则使用 db.relationship 来和 ForeignKey 来建立联系。注意 db.relationship 定义的内容并不真的存在于数据库表中，只是存在于 SQLAlchemy 中。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通过在 Post 中指定 user_id 来影响 User.posts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user = User.query.get(1)</div><div class="line">&gt;&gt;&gt; new_post = Post(&apos;Post Title&apos;)</div><div class="line">&gt;&gt;&gt; new_post.user_id = user.id</div><div class="line">&gt;&gt;&gt; db.session.add(new_post)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div><div class="line">&gt;&gt;&gt; user.posts  # 此时新的 post 会被自动添加到 User 表中</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>通过反向引用来影响 User.posts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; second_post = Post(&apos;Second Title&apos;)</div><div class="line">&gt;&gt;&gt; second_post.user = user</div><div class="line">&gt;&gt;&gt; db.session.add(second_post)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div><div class="line">&gt;&gt;&gt; user.posts  # 此时新的 post 也会被自动添加到 User 表中</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>在 relationship 中通过 backref 参数来指定了反向引用，因此在 Post 中只要通过 Post.user 就可以引用对应的 User 内容了，在这里就是通过反向引用来改变了 User.posts 的内容（新绑定了一个 post）</p>
<h3 id="关于-User-posts"><a href="#关于-User-posts" class="headerlink" title="关于 User.posts"></a>关于 User.posts</h3><p>User 中的 posts 字段因为是 dynamic 方式，所以既可以看作列表，也可以看做查询对象（可以在后面使用 filter_by 等）</p>
<p>看作列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user.posts</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<p>看做查询对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; user.posts.order_by(Post.publish_date.desc()).all()</div><div class="line">[&lt;Post &apos;Second Title&apos;&gt;, &lt;Post &apos;Post Title&apos;&gt;]</div></pre></td></tr></table></figure></p>
<h3 id="一对多的最后"><a href="#一对多的最后" class="headerlink" title="一对多的最后"></a>一对多的最后</h3><p>因为二者进行了绑定，因此对一个的内容（一般是‘多’的那边）进行更改，另一个就可以马上同步而不用自己手动修改</p>
<h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>一对一和一对多类似，不过在声明 relationship 的时候要传入参数 <code>uselist=False</code></p>
<p>Userinfo 表示没那么重要的数据，对 User 作为补充<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Userinfo(db.Model):</div><div class="line">    id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;), primary_key=True)</div><div class="line">    age = db.Column(db.String(255))</div><div class="line">    introduction = db.Column(db.Text())</div><div class="line">    update_date = db.Column(db.Datetime())</div></pre></td></tr></table></figure></p>
<p>User 表示用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    userinfo = db.relationship(  </div><div class="line">        &apos;Userinfo&apos;,</div><div class="line">        backref=&apos;user&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>一对一的作用主要是副表对主表进行扩展，主表中存放的是相对重要的内容，而副表中存放的是相对没那么重要的内容。副表访问主表数据的方法和一对多相同，但是主表访问附表的方式就多种多样了</p>
<p>通过外键来查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; userinfo = Userinfo.query.get(user.id)</div></pre></td></tr></table></figure></p>
<p>二者建立双向绑定，通过主表反向调用副表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Userinfo(db.Model):</div><div class="line">    id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;), primary_key=True)</div><div class="line">    age = db.Column(db.String(255))</div><div class="line">    introduction = db.Column(db.Text())</div><div class="line">    update_date = db.Column(db.Datetime())</div><div class="line">    user = db.relationship(  </div><div class="line">        &apos;Use&apos;,</div><div class="line">        back_populates=&apos;userinfo&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div><div class="line"></div><div class="line">class User(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    username = db.Column(db.String(255))</div><div class="line">    password = db.Column(db.String(255))</div><div class="line">    userinfo = db.relationship(  </div><div class="line">        &apos;Userinfo&apos;,</div><div class="line">        back_populates=&apos;user&apos;,</div><div class="line">        uselist=False</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<p>这里 back_populates 和 backref 意义是相似的，但是 back_populates 必须要在两处都进行说明，这样同时也可以进行双向的反向引用了</p>
<p>因此主表访问附表就可以直接访问了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; userinfo = user.userinfo</div></pre></td></tr></table></figure></p>
<h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>数据库模型定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># 直接用 db.Table 来建立表</div><div class="line">tags = db.Table(  # 辅助表，用来建立多对多关系</div><div class="line">    &apos;post_tags&apos;,  # 表名</div><div class="line">    db.Column(&apos;post_id&apos;, db.Integer, db.ForeignKey(&apos;post.id&apos;)),</div><div class="line">    db.Column(&apos;tag_id&apos;, db.Integer, db.ForeignKey(&apos;tag.id&apos;))</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">class Post(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line">    text = db.Column(db.Text())</div><div class="line">    publish_date = db.Column(db.Datetime())</div><div class="line">    user_id = db.Column(db.Integer(), db.ForeignKey(&apos;user.id&apos;))</div><div class="line">    tags = db.relationship(  # 声明关系</div><div class="line">        &apos;Tag&apos;,  # 主要是给 Tag 引用</div><div class="line">        secondary=tags,  # 通过 tags 作为中介</div><div class="line">        backref=backref(&apos;posts&apos;, lazy=&apos;dynamic&apos;)</div><div class="line">    )</div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div><div class="line"></div><div class="line"></div><div class="line">class Tag(db.Model):</div><div class="line">    id = db.Column(db.Integer(), primary_key=True)</div><div class="line">    title = db.Column(db.String(255))</div><div class="line"></div><div class="line">    def __init__(self, title):</div><div class="line">        self.title = title</div></pre></td></tr></table></figure></p>
<p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; post_one = Post.query.all()[1]</div><div class="line">&gt;&gt;&gt; post_two = Post.query.all()[2]</div><div class="line">&gt;&gt;&gt; tag_one = Tag(&apos;Python&apos;)</div><div class="line">&gt;&gt;&gt; tag_two = Tag(&apos;SQLAlchemy&apos;)</div><div class="line">&gt;&gt;&gt; tag_three = Tag(&apos;Flask&apos;)</div><div class="line">&gt;&gt;&gt; post_one.tags = [tag_two]  # 手动创建对应关系</div><div class="line">&gt;&gt;&gt; post_two.tags = [tag_one, tag_two, tag_three]</div><div class="line">&gt;&gt;&gt; tag_two.posts  # 反向引用</div><div class="line">[tag_one, tag_two, tag_three]</div><div class="line">&gt;&gt;&gt; db.session.add(post_one)  # 似乎并没有 add tag 到 session</div><div class="line">&gt;&gt;&gt; db.session.add(post_two)  # 因为通过回话自动保存了标签</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p>
<p>在所对多关系中，backref 也变成了 list，可以通过 list 的 append 方法来添加文章到标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; tag_one.posts.append(post_one)</div><div class="line">[&lt;Post &apos;Post Title&apos;&gt;, &lt;Post &apos;Second Title&apos;&gt;] </div><div class="line">&gt;&gt; post_one.tags</div><div class="line">[&lt;Tag &apos;SQLAlchemy&apos;&gt;, &lt;Tag &apos;Python&apos;&gt;]</div><div class="line">&gt;&gt;&gt; db.session.add(tag)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果要重写 <strong>init</strong> 方法的话则要注意使用的变量是否已经初始化了，没有初始化的话可能变量值为 None，此时调用就会报错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再次理解-Flask-SQLAlchemy-中数据模型之间的关联&quot;&gt;&lt;a href=&quot;#再次理解-Flask-SQLAlchemy-中数据模型之间的关联&quot; class=&quot;headerlink&quot; title=&quot;再次理解 Flask-SQLAlchemy 中数据模型之
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="SQLAlchemy" scheme="https://blog.patrickcty.cc/categories/Python/SQLAlchemy/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/categories/Python/SQLAlchemy/Flask/"/>
    
    
      <category term="Python" scheme="https://blog.patrickcty.cc/tags/Python/"/>
    
      <category term="Web" scheme="https://blog.patrickcty.cc/tags/Web/"/>
    
      <category term="Flask" scheme="https://blog.patrickcty.cc/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习（一）</title>
    <link href="https://blog.patrickcty.cc/2017/07/20/Docker%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.patrickcty.cc/2017/07/20/Docker学习（一）/</id>
    <published>2017-07-20T03:03:40.000Z</published>
    <updated>2017-07-25T02:56:40.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-学习（一）"><a href="#Docker-学习（一）" class="headerlink" title="Docker 学习（一）"></a>Docker 学习（一）</h1><h2 id="理解-Docker"><a href="#理解-Docker" class="headerlink" title="理解 Docker"></a>理解 Docker</h2><p>基本概念：</p>
<ul>
<li>镜像</li>
<li>容器</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>是一个特殊的文件系统，包含了容器运行时的依赖。</p>
<p>镜像是一层层构建的，前一层是后一层的基础。每一层构建完就不会再改变，后一层删除前一层文件的操作会保留文件，只是该文件会标记为已删除。</p>
<p>因为上面所说的特性，镜像是只读的。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像的实例，容器运行时在镜像层上创建一个存储层，该存储层会在容器消亡时消亡，该层中的数据也不会保留。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="不使用-sudo-命令执行-Docker"><a href="#不使用-sudo-命令执行-Docker" class="headerlink" title="不使用 sudo 命令执行 Docker"></a>不使用 sudo 命令执行 Docker</h3><p>因为 Docker 运行时需要特殊权限，所以默认执行命令都必须在前面加上 sudo。</p>
<p>不使用 sudo 命令执行 Docker 方法：把用户放进 docker 用户组里面（等同于赋予它 root 权限）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo useradd -aG docker $USER  # 还要注销重新登录</div><div class="line">sudo service docker restart  # 重启服务</div></pre></td></tr></table></figure>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>获取某个容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>查看容器文件改变情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>查看容器日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>删除容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm 容器名/容器 ID</div></pre></td></tr></table></figure></p>
<p>列出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker ps        # 查看运行中的容器</div><div class="line">docker ps -a     # 查看所有容器</div><div class="line">docker ps -aq    # 查看所有容器，只显示容器 ID</div></pre></td></tr></table></figure></p>
<p>删除镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi 镜像名/镜像 ID</div></pre></td></tr></table></figure></p>
<p>下载/上传镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull/push 镜像名[:TAG|@DIGEST]</div></pre></td></tr></table></figure></p>
<p>创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run</div></pre></td></tr></table></figure></p>
<h2 id="通过-Dockerfile-定制镜像"><a href="#通过-Dockerfile-定制镜像" class="headerlink" title="通过 Dockerfile 定制镜像"></a>通过 Dockerfile 定制镜像</h2><p><code>docker commit</code> 命令可以通过容器产生镜像，但是要重复操作产生多个相同镜像却不方便，此时使用 Dockerfile 能解决这个问题。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<h3 id="使用-docker-build-来构建镜像"><a href="#使用-docker-build-来构建镜像" class="headerlink" title="使用 docker build 来构建镜像"></a>使用 <code>docker build</code> 来构建镜像</h3><p>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</div></pre></td></tr></table></figure></p>
<p>其中常用到 -t 选项来指定构建出的镜像的名称。</p>
<p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>一般新建一个空文件夹并以该文件夹作为上下文路径来构建镜像。</p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t myimage .</div></pre></td></tr></table></figure></p>
<p>这里的“.“就是上下文路径，表示当前文件夹。</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>定制镜像一定要以一个镜像为基础，而 FROM 指令就是指定基础镜像，并且这是最基本的指令，并且必须是第一条指令。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</div></pre></td></tr></table></figure>
<ul>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li>
</ul>
<p>注：因为每个 Dockerfile 的指令都会新建一层，而层数多并不是一件有意义的事情，因此应该用 &amp;&amp; 连接多个命令在一条 RUN 指令里面执行，并且在每一层构建的最后删除掉无关文件。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure></p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p>
<p>格式：</p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p>
<p>比如 &lt;源路径&gt; 可以是一个 URL。</p>
<p>在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>例如 ubuntu 镜像默认的 CMD 就是 <code>/bin/bash</code>。</p>
<p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code></li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>（在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数）</li>
</ul>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>格式和 CMD 相同。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数，但当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>环境变量可以在其他的 Dockerfile 指令里面展开。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;</code>。</p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p>一般用于维护多个镜像，这样升级只用重新构建镜像即可，而不用修改每个的 Dockerfile</p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker——从入门到实践</a><br>Docker 开发指南——O’REILLY</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-学习（一）&quot;&gt;&lt;a href=&quot;#Docker-学习（一）&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习（一）&quot;&gt;&lt;/a&gt;Docker 学习（一）&lt;/h1&gt;&lt;h2 id=&quot;理解-Docker&quot;&gt;&lt;a href=&quot;#理解-D
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《第一行代码—— Android 休闲学习（一）</title>
    <link href="https://blog.patrickcty.cc/2017/07/17/Android1/"/>
    <id>https://blog.patrickcty.cc/2017/07/17/Android1/</id>
    <published>2017-07-17T13:43:12.000Z</published>
    <updated>2017-07-26T01:26:05.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《第一行代码》——-Android-休闲学习（一）"><a href="#《第一行代码》——-Android-休闲学习（一）" class="headerlink" title="《第一行代码》—— Android 休闲学习（一）"></a>《第一行代码》—— Android 休闲学习（一）</h1><h2 id="日志工具使用"><a href="#日志工具使用" class="headerlink" title="日志工具使用"></a>日志工具使用</h2><p>先用<code>import android.util.Log;</code>来导入所需库函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Log.v()  // verbose</div><div class="line">Log.d()  // debug</div><div class="line">Log.i()  // info</div><div class="line">Log.w()  // waring</div><div class="line">Log.e()  // error</div></pre></td></tr></table></figure>
<p>日志的等级从上到下依次增高。</p>
<p>日志样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">07-16 19:37:03.494 15142-15142/com.example.patrick.activitytest D/FirstActivity: Hello FirstActivity</div></pre></td></tr></table></figure></p>
<p>其中<code>FirstActivity</code>是 tag，为了方便过滤日志，<code>Hello FirstActivity</code>是日志的内容</p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// tag 一般传入当前的类名</div><div class="line">Log.d(tag, msg);</div></pre></td></tr></table></figure></p>
<p>小技巧</p>
<blockquote>
<p>在 onCreate() 方法的外面输入 logt，然后按下 Tab 键，这时候就会以当前的类名作为值自动生成一个 TAG 常量<br>例如：private static final String TAG = “HelloWorldActivity”;</p>
</blockquote>
<h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><p>活动是一种可以包含用户界面的组件，主要用于和用户进行交互。我们看到的页面就是活动。</p>
<h3 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h3><ul>
<li>创建活动：在 /ActivityTest/app/src/main/java/com.example.patrick.activitytest 下创建活动</li>
<li>创建和加载布局（可以自动完成）<ul>
<li>在app/src/main/res 下创建 layout 目录，再在这个目录下创建布局文件</li>
<li>可以在这个文件里面增添元素（要使用的话得在活动中定义动作）</li>
<li>在活动中重写 onCreate 来加载布局，使用 setContentView() </li>
</ul>
</li>
<li>在 AndroidMainfest 文件中注册（自动完成）</li>
<li>配置主活动（一个程序至少要有一个，不然就不能在启动器中看到和打开程序）</li>
</ul>
<h3 id="在活动中使用-Toast"><a href="#在活动中使用-Toast" class="headerlink" title="在活动中使用 Toast"></a>在活动中使用 Toast</h3><p>Toast 是在接近底部的地方弹出的提示</p>
<ul>
<li>触发 Toast（这里是点击按钮触发）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 获取元素，返回值是 View 对象，要下转型成 Button 对象</div><div class="line">Button button1 = (Button) findViewById(R.id.button_1);  </div><div class="line">// 注册监视器，监视点击事件</div><div class="line">button1.setOnClickListener(new View.OnClickListener() &#123;  // 匿名类</div><div class="line">    @Override</div><div class="line">    public void OnClick(View v) &#123;</div><div class="line">        // 通过静态方法创建 Toast 对象并通过 .show() 来使用</div><div class="line">        // 第一个参数是 Toast 的上下文，直接传入活动就可以</div><div class="line">        // 第二个参数就是 Toast 显示的文本</div><div class="line">        // 第三个参数是 Toast 显示的时长</div><div class="line">        Toast.makeText(FirstActivity.this, &quot;You clicked Button 1&quot;,</div><div class="line">            Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>小技巧</p>
<blockquote>
<p>按 Ctrl-O 可以方便地重写方法</p>
</blockquote>
<h3 id="在活动中使用-Menu"><a href="#在活动中使用-Menu" class="headerlink" title="在活动中使用 Menu"></a>在活动中使用 Menu</h3><p>Menu 是页面右上角的三个竖着的小点点。</p>
<p>使用 Menu</p>
<ul>
<li>在 res 目录下新建 menu 文件夹，并且在该目录下创建菜单文件<ul>
<li>在该文件通添加菜单项</li>
<li>android:id 是菜单项的标识符，在活动中用<code>R.id.标识符名</code>来引用</li>
<li>android:title 是菜单的名称（显示在菜单中）</li>
</ul>
</li>
<li>在活动中重写 onCreateOptionsMenu() 方法来初始菜单，可以使用 Ctrl + O 快捷键</li>
<li>定义菜单相应事件，通过重写 onOptionsItemSelected() 方法<ul>
<li>通过 <code>item.getItemId()</code> 来判断点击的是哪个菜单项</li>
</ul>
</li>
</ul>
<h3 id="销毁活动"><a href="#销毁活动" class="headerlink" title="销毁活动"></a>销毁活动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">finish()  // 相当于按返回键</div></pre></td></tr></table></figure>
<h3 id="使用-Intent-切换活动"><a href="#使用-Intent-切换活动" class="headerlink" title="使用 Intent 切换活动"></a>使用 Intent 切换活动</h3><h4 id="显式-Intent"><a href="#显式-Intent" class="headerlink" title="显式 Intent"></a>显式 Intent</h4><p>直接指明了要切换的目的活动。</p>
<p>源活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 第一个参数是启动活动的上下文</div><div class="line">// 第二个参数是要启动的目标活动的类</div><div class="line">Intent intent = new Intent(FirstAcitity.this, SecondActivity.class);</div><div class="line">// 用来启动活动</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<h4 id="隐式-Intent"><a href="#隐式-Intent" class="headerlink" title="隐式 Intent"></a>隐式 Intent</h4><p>并不明确指明要启动的活动，而是指定了更为抽象的 action 和 category 等信息，然后交由系统来启动目的活动，可以是同一个应用的活动，也可以是其他应用的活动。</p>
<p>使用方法：</p>
<ul>
<li>在 AndroidManifest.xml 文件中指明 action 与 category</li>
<li>在活动中使用 Intent<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 只有当二者的 action 和 category 完全匹配才能响应 Intent</div><div class="line">// 隐式 Intent 使用 action 来初始化实例的</div><div class="line">Intent intent = new Intent(&quot;和前面指明的 action 内容相同&quot;);</div><div class="line">intent.addCategory(&quot;和前面指明的 category 内容相同&quot;);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="隐式-Intent-Plus"><a href="#隐式-Intent-Plus" class="headerlink" title="隐式 Intent Plus"></a>隐式 Intent Plus</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Intent.ACTION_VIEW 是一个 Android 内置的动作</div><div class="line">// 对应的 xml 文件中的值是 android.intent.category.VIEW</div><div class="line">Intent intent = new Intent(Intent.ACTION_VIEW);</div><div class="line">// setData() 接受一个 Uri 对象，指定操作的数据（注意不是 Url）</div><div class="line">intent.setData(Uri.parse(&quot;https://blog.patrickcty.cc&quot;));</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<h4 id="用-Intent-向下一个活动传递信息"><a href="#用-Intent-向下一个活动传递信息" class="headerlink" title="用 Intent 向下一个活动传递信息"></a>用 Intent 向下一个活动传递信息</h4><p>使用 putExtra() 发送数据，在目的活动中使用 getStringExtra() 取出数据</p>
<p>源活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String data = &quot;Hello SecondActivity&quot;;</div><div class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</div><div class="line">// putExtra 接受两个参数，第一个参数是 key，用来在目的活动取出数据</div><div class="line">// 第二个参数是数据</div><div class="line">intent.putExtra(&quot;extra_data&quot;, data);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>目的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = getIntent();</div><div class="line">// 通过 key 来取出数据并保存在 data 里面</div><div class="line">String data = intent.getStringExtra(&quot;extra_data&quot;);</div></pre></td></tr></table></figure></p>
<h4 id="用-Intent-返回数据给上一个活动"><a href="#用-Intent-返回数据给上一个活动" class="headerlink" title="用 Intent 返回数据给上一个活动"></a>用 Intent 返回数据给上一个活动</h4><p>startActivityForResult() 启动活动并且在活动销毁的时候能够返回结果给上一个活动。</p>
<p>源活动按钮的点击事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</div><div class="line">// 第二个参数是请求码，唯一，用来区分不同请求</div><div class="line">startActivityForResult(intent, 1);</div></pre></td></tr></table></figure></p>
<p>目的活动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent();</div><div class="line">intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity&quot;);</div><div class="line">// 专门用来向上一个活动返回数据</div><div class="line">// 第一个参数是处理结果，第二个参数是 Intent</div><div class="line">setResult(RESULT_OK, intent);</div><div class="line">finish();</div></pre></td></tr></table></figure></p>
<p>源活动接受数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// requestCode 就是上面唯一的请求码</div><div class="line">// resultCode 就是处理结果</div><div class="line">@Override</div><div class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">    switch (requestCode) &#123;</div><div class="line">        case 1:</div><div class="line">            if (resultCode == RESULT_OK) &#123;</div><div class="line">                String returnedData = data.getStringExtra(&quot;data_return&quot;);</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《第一行代码》——-Android-休闲学习（一）&quot;&gt;&lt;a href=&quot;#《第一行代码》——-Android-休闲学习（一）&quot; class=&quot;headerlink&quot; title=&quot;《第一行代码》—— Android 休闲学习（一）&quot;&gt;&lt;/a&gt;《第一行代码》—— A
    
    </summary>
    
      <category term="Android" scheme="https://blog.patrickcty.cc/categories/Android/"/>
    
    
      <category term="休闲" scheme="https://blog.patrickcty.cc/tags/%E4%BC%91%E9%97%B2/"/>
    
      <category term="Android" scheme="https://blog.patrickcty.cc/tags/Android/"/>
    
      <category term="菜鸡的自我修养" scheme="https://blog.patrickcty.cc/tags/%E8%8F%9C%E9%B8%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>《一条狗的使命》</title>
    <link href="https://blog.patrickcty.cc/2017/07/10/%E3%80%8A%E4%B8%80%E6%9D%A1%E7%8B%97%E7%9A%84%E4%BD%BF%E5%91%BD%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/07/10/《一条狗的使命》/</id>
    <published>2017-07-10T15:17:31.000Z</published>
    <updated>2017-07-10T15:21:46.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一条狗的使命》"><a href="#《一条狗的使命》" class="headerlink" title="《一条狗的使命》"></a>《一条狗的使命》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>不得不说这学期的课程太过凶残了，平常两周的复习周就可以把要复习的都复习完了，然后考试周就可以休闲一点了。但是今年的两周复习周基本上都用在复习计组和操作系统上面去了，所以即使是考试周每天考完了也还是要继续留在图书馆“抢救”，所以在看这部电影之前考试周这么久我都没有看过一部电影。</p>
<p>不过因为只剩最后一门了，所以提前了不少时间回寝室了，之后便打开了这部电影～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>影片是以狗为第一人称视角来写的，这个视角给不少地方都增添了笑点，算是一个比较成功的 idea。影片中的狗狗经历了五次转世。其实一开始我是没有意识到是转世的，因为从一开始狗狗被捕，到后来是一只大狗狗在笼子里面，感觉并没有什么不对 233（虽然两次毛的颜色不同）。后来我才意识到了原来是经过了转世。</p>
<p>其中最重要的也是最着力刻画的是第二次转世和地五次转世，但是第二次转世在网上引起的争议也是最大的。</p>
<p>小男孩伊森和妈妈救助了一只被关在车里因为灼热气温而濒死的狗狗并带回了家，而养狗的第一个关键就是获得爸爸的同意。影片似乎是有意把爸爸作为一个大反派来刻画的，从刚进家开始爸爸就不怎么喜欢这只狗，而且爸爸这个人也比较消极，每天因为政治和工作而苦恼，总是一副不高兴的样子。直到领导来家里吃饭的尴尬遭遇，狗毁掉了爸爸升职的机会，爸爸对狗的愤怒升到了顶峰并彻底爆发。</p>
<p>但在这之前，伊森和贝利的接球配合已经很好了，那个贝利找到的橄榄球也在后面成为了重要的线索，Boss Dog 的名号也叫起来了。有人说这个 Boss Dog 叫得不合适，不能让狗形成自己是老大的念头，不过我对狗是否能理解这个称呼的意思表示怀疑，而且昵称这种东西嘛，只要不是那种侮辱性的，大家都开心就好嘛。</p>
<p>在爸爸升职的机会被毁掉后，伊森进入了高中，成为了橄榄球对的核心成员，而爸爸却显现出了颓废之态，成为了酒鬼，直到一次推搡妈妈被赶出了家门。但在这次冲突之前其实爸爸就有一次也是怒气冲冲地离开了家，口里还怪罪着妈妈花了他的很多钱。其实我个人感觉这个地方表现的很不好，很多人觉得是狗让爸爸变成了这样，但我觉得这样的一次打击应该不至于毁掉一个男人，更何况他是顶级销售员，即使被炒了去其他的公司也未必混不开。从网上的评论可以猜到应该是由于时代原因，推销被逐渐取代，爸爸的工作也因此越来越难做甚至没了，而这样的打击使得原本就比较消极的他彻底堕落，沦为了一个酒鬼。再加上妈妈总是用他很多钱，这样的小事情就引起了夫妻之间的矛盾，使得夫妻之间难以好好沟通，造成了被赶出家门的前因。</p>
<p>对我觉得爸爸这条支线描写得真的是不是很好，内容太过简略，又有一种把人往狗狗毁掉了爸爸的人生这方向带的感觉，另外对于妈妈用很多钱这个地方也很模糊，所以当最后爸爸被赶出家这时候我是真的感觉莫名其妙。不过这部分关于狗狗的描写真的是比较到位，慢慢建立羁绊，并因为狗狗结识了女朋友，过上了幸福快乐的生活。这部分比较偏日常，不过狗狗的作用还是不可忽视的。</p>
<p>直到赢得至关重要的橄榄球决赛之后，伊森成功获得了密歇根大学的全额奖学金。这场比赛爸爸也前来观看了，并在赛后向他“表示祝贺”，只不过说话的语气有些阴阳怪气，与其说是祝贺，不如说是酸溜溜的表达内心的嫉妒。而男主的表现很正常，并不是其他人所说的嫌弃他的酒鬼老爸。而后面男主揍陶德这一部分我觉得也很正常，面对一而再再而三的挑衅，男主选择了反击，只不过对于这种垃圾人最妥当的办法还是不理会，直接离开。不过男主的行为也没有什么过错，至于又拿嫌弃爸爸来说事的，这里嫌弃男主爸爸的是陶德，并不是伊森，而自己爸爸是酒鬼这件事本来就不是什么很光荣应该让所有人都知道的事情，因此说嫌弃爸爸还是有点太过了。</p>
<p>没想到陶德这家伙为了报复半夜来丢烟花到伊森家，烟花烧到了地毯最后点燃了整个家，此时贝利出场叫醒了伊森，伊森又叫醒了妈妈，但是最后火势已经太凶了，他们只能从窗户逃脱。妈妈和狗狗被救了下来，但是伊森却被困在了房子里，最后只好跳下来，却摔断了腿。这个地方我想吐槽的是房子外面不是有很多人么，为什么没人去接住他或者搭把手……这个摔断腿真的感觉是强行的剧情需要了。</p>
<p>我一开始还以为这个腿伤并不严重，应该只要好好养伤还是可以恢复到原来的水平的，没想到这个伤直接葬送了他的职业生涯，他只得去家附近的农业大学就读，继承农场。而在养伤的时候他和他女朋友提出了分手，当时我对这个地方的理解是他和她一起上大学的梦想破灭了，而他觉得现在这样会拖累她，于是为了她好就选择了分手。这个从是他之后的想念推测的，但是没想到最后一部分居然说是因为当时受到的打击太大太颓废才分手的……这个其实也可以理解，毕竟密歇根大学和农业大学的差别还不是一般的大，更关键的是职业生涯的葬送，这是未来被毁灭，从一个可能成为体育明星的未来到只能做一个农场主的未来的落差确实十分巨大，不过这样总感觉有些奇怪……最遗憾的是女主就这样离开了，不过生活其实就是这样的，很多时候冲动会造成终生的遗憾，其实男主并不是真的不爱女主了，只是一是冲动。</p>
<p>之后男主去上大学的时候就上演了一幕感人了狗狗万里追车情节，这部分拍得还是很赞的。但是从这之后狗狗就开始快速衰老起来了，再也没有精力四处跑动，甚至连吃饭都没有力气，在去世之前，他也终于见到了伊森。</p>
<p>第三次转世他是成为了一条警犬，不过连性别都转换了 233。这里的篇幅没有前面的多，不过对这短暂的一生的刻画是本片中争议最少的一部分。这一生的使命就和上一生的完全不同了，每天不再是无忧无虑地玩耍了，而要去做警犬应该做的事情。而在这方面，她把她的使命履行得很好。</p>
<p>除此之外，在晚上她也表现出了她的善解人意，她看出了主人内心的痛苦，她在用自己的方式给予主人慰藉，而主人也逐渐接收到了，对她的感情也越来越深厚。而好景不长，在一次追捕坏人的任务中，当她成功救起了被推下水库的女孩之后，她又冲了出来阻止了坏人的射击，却被子弹击中，不幸身亡。</p>
<p>这一生虽然短暂，但使命感却十足，她也很好完成了自己的使命。</p>
<p>接着第四次转世成为了一只柯基，被一个宅女所收养。而正是通过他对另一只狗的喜爱，促使了一段姻缘。这部分狗与主人的默契非常让人印象深刻。比较虐心的是他所爱先一步离他去，而她一直以来活着的意义就是为了保护她。失去了所爱的他也在之后离去了。</p>
<p>而第五次转世就没那么好了，他被一个嬉皮士女士收留，而她老公不让狗狗进家，于是他每天都被锁在了院子里，直到女生再也养不了，他被抛弃。但是抛弃对他来说或许是一件更好的事情，他不仅获得了自由，也远离了令狗难受的城镇。机缘巧合之下，他又闻到了汉娜的味道，他又回到了伊森的身边，但此时的伊森年龄已经不年轻了。因为他已不再是贝利的样子，因此伊森一开始也不是很愿意收留他，但命运使然，伊森还是收留了他。</p>
<p>而机智的贝利又根据之前闻到的气味——汉娜女儿的气味，找到了汉娜。就这样多年之后两人重新相逢，此时汉娜丈夫已经去世，伊森没有让遗憾继续下去，在单身这么多年之后伊森终于又挽回了爱情，终止了遗憾～虽然这里很圆满，不过还是得为伊森感到遗憾……</p>
<p>之后贝利又在仓库里找到了那个充满回忆的球，并且用那个熟悉的接球姿势让伊森知道 Boss Dog 又回来了～这部分真的让人看得十分激动啊～</p>
<p>本来看到前面我就以为伊森这部分已经结束了，没想到最后居然是以这样的方式来给他们的故事画上了一个句号。我想最后伊森一定想说：“终于等到你，还好我没放弃。”。虽然有些刻意，不过结局还是让人感到温暖的，就像整部电影的旋律一样。</p>
<p>狗的使命是什么呢？这或许不重要，只要自己快乐，身边人快乐就好。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>8/10.</p>
<p>这部电影剧情还是不错的，不过有一些地方感觉有一些刻意。但是转世这个设定让人眼前一亮，特别是兜兜转转之后又回到了伊森的身边这里还是很让人惊喜的。总体还是一步让人感动并且欢乐的影片，在考试周也给予了我一些慰藉～还是值得推荐的～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《一条狗的使命》&quot;&gt;&lt;a href=&quot;#《一条狗的使命》&quot; class=&quot;headerlink&quot; title=&quot;《一条狗的使命》&quot;&gt;&lt;/a&gt;《一条狗的使命》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="宠物电影" scheme="https://blog.patrickcty.cc/tags/%E5%AE%A0%E7%89%A9%E7%94%B5%E5%BD%B1/"/>
    
      <category term="感动" scheme="https://blog.patrickcty.cc/tags/%E6%84%9F%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>《神奇女侠》</title>
    <link href="https://blog.patrickcty.cc/2017/06/28/%E3%80%8A%E7%A5%9E%E5%A5%87%E5%A5%B3%E4%BE%A0%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/06/28/《神奇女侠》/</id>
    <published>2017-06-28T12:21:20.000Z</published>
    <updated>2017-06-28T12:34:58.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《神奇女侠》"><a href="#《神奇女侠》" class="headerlink" title="《神奇女侠》"></a>《神奇女侠》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影也是在很久之前看的，因为种种原因也一直没能写点什么。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次看到这个角色是在前两年的《蝙蝠侠大战超人》，在他们打得最激烈的时候，神奇女侠及时出现阻止了他们的内战，当时看到这个角色就觉得眼前一亮～</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;神奇女侠的扮演者是盖尔加朵，而盖尔加朵的话也不是一个生面孔了，她所出演的速度与激情的 Gisele 也让人觉得十分有灵性，当她离开主角小分队的时候我真的觉得十分遗憾。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再加上这部电影在网上也收获了不少好评，于是找到时间之后我就和女票一起在吃 CHIZZA 之后顺便看了～</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部 DC 的电影和漫威的《美国队长 1》在不少方面都有相似的地方。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的故事都是发生在战争时期，神奇女侠是在一战，美国队长是在二战，二人都是从“初出茅庐”的迷茫到最后的认清自我有所作为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为神奇女侠是在一个平静安详的地方长大，没见识过战争，也没见识过各种各样的人，再加上她听着神话长大，因此她以为只要能打败阿瑞斯就能拯救人类平息战争，但当她打败“阿瑞斯”——鲁登道夫的时候，她发现一切并没有任何改变，这时候的她陷入了无尽的迷茫。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里，我觉得剧情还是很优秀的。在这之前尽管她的同伴都认为她的目标比较不切实际，但他们都没有完全地否定她的观念，而是用他们自己的行动展示给她看，让她自己感受这个世界。但是当之后所有人都认为是虚构的阿瑞斯真正的出现的时候，剧情就突然就变得神了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也正是在与这个正牌的阿瑞斯战斗的过程中，她慢慢找到了自我，也打败了阿瑞斯，而在场的人们在亲眼目睹这场浩大的战斗后也丧失了战斗的欲望，这也算是“实现目标”了吧。然而此时一直保护着她不受这个世界的伤害并且教给她爱的那个男人却在她搞懂爱情之前已经永远的离开了……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整部电影情节的把控还是很好的，看的时候完全不会觉得描写背景的时候太过无趣，也不会觉得打斗空洞，莫名其妙，整体的观影感觉十分舒服，让人意犹未尽。其实开头是承接着之前的《蝙蝠侠大战超人》，那张照片也是蝙蝠侠派人送过来的，这不得不让人期待后续的正义联盟了，当他们再次相遇，又会有什么有趣的事情发生呢？这么多年过去了，神奇女侠究竟又有什么不同呢？真的非常让人期待啊。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.5/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;剧情流畅，人物塑造很到位，女侠也很漂亮～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《神奇女侠》&quot;&gt;&lt;a href=&quot;#《神奇女侠》&quot; class=&quot;headerlink&quot; title=&quot;《神奇女侠》&quot;&gt;&lt;/a&gt;《神奇女侠》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="超级英雄" scheme="https://blog.patrickcty.cc/tags/%E8%B6%85%E7%BA%A7%E8%8B%B1%E9%9B%84/"/>
    
      <category term="神奇女侠" scheme="https://blog.patrickcty.cc/tags/%E7%A5%9E%E5%A5%87%E5%A5%B3%E4%BE%A0/"/>
    
  </entry>
  
  <entry>
    <title>《加勒比海盗 5：死无对证》</title>
    <link href="https://blog.patrickcty.cc/2017/06/20/%E3%80%8A%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%975%EF%BC%9A%E6%AD%BB%E6%97%A0%E5%AF%B9%E8%AF%81%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/06/20/《加勒比海盗5：死无对证》/</id>
    <published>2017-06-20T00:20:54.000Z</published>
    <updated>2017-06-20T00:28:26.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《加勒比海盗-5：死无对证》"><a href="#《加勒比海盗-5：死无对证》" class="headerlink" title="《加勒比海盗 5：死无对证》"></a>《加勒比海盗 5：死无对证》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影在好久之前就看了，然而一直拖着没有开始写。距离上一部加勒比海盗已经过去六年了，前面的几部我都没有去电影院看，因此当新的一部上映，当我终于可以去大屏幕观看的时候，怎么能不去看？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为过去了这么久，前面几部内容都不记得了，因此在结束之后我还特意去看了看木鱼水心的相应的视频来回顾了一下。看的时候感觉这一部和前面几部关系并不大，但是因为一些地方忘记了，所以在看到有些地方的时候就有些不能理解了，不过现在回顾了之前的剧情，前面的疑惑就得到了解答。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的反派是杰克船长在他的成名之战中打败的萨拉查船长，萨拉查曾经是西班牙海军的神奇船长，以歼灭所有海军为目标。就当他以为击败了最后的海盗的时候却被初出茅庐的杰克使用了一个乾坤大飘逸引诱到了死亡三角区去了，受到了诅咒的他们被困在了其中，只有当杰克放弃了他的罗盘他们才能重见天日，因为罗盘的特性是当它的持有者抛弃掉它的时候，他最大的威胁就会被释放出来。在这段回忆中出现的年轻时候的杰克船长是用 CG 做出来的，效果十分逼真，连我的女票都发出了“他怎么能演这么久”的惊叹 233。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而这次的主线是亨利为了救回他那因为诅咒被困在飞翔的荷兰人号的威尔特纳而出海寻找海神三叉戟。而此时的杰克船长呢，却待在一个小岛上，进行了一场可笑几乎分文未得到的抢劫。因为没有好船，没有收入，再加上经历了许多失败的冒险，他的船员也对他有些失望了。杰克那出名的黑珍珠号因为受到了黑胡子的诅咒，被禁锢在玻璃瓶里面，杰克仅有一条不知道能不能下海的小破船。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杰克落魄到了什么程度呢？船员全都离开了他，海军四处追杀他，而他的赏金也在几次修改后逐渐降低，甚至他穷到了要用他的神奇的罗盘来换取酒喝。这个罗盘是他成名战胜利之前所得到，也陪伴着他经过了一次次的冒险，无数次带他去到了他最渴望的目标。但是在这里他放弃了它，一个没有船，没有船员的船长还叫什么船长呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是放弃罗盘是一件严重的事，这就意味着萨拉查再度取得自由，而这次的萨拉查有了诅咒的加成，再次成为了海上无敌的存在，而他的目的是直取杰克的人头，以报多年前的一箭之仇。在买酒之后，杰克被海军抓入监狱，不过在行刑时的一片混乱中，主角终于聚到了一起。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里不得不提一提在小岛上发生的抢劫银行和刑场救人的事件，首先我要吐槽一下杰克究竟是怎么进到保险箱里面去的，而且行长的妻子也进到里面去了……总感觉惊天魔盗团悄悄来到了小岛 233。总之这个抢银行的过程很有海盗气息，他们也是选择直接抢走保险柜，这让我联想起了速度与激情的那一幕。然而因为墙壁太结实，他们抢走的不仅仅是保险柜，更是直接把整个银行拖着走了。看着到处鸡飞狗跳的情况，无论是戏里戏外都是十分欢乐的，当然最喜闻乐见的是到了最后保险柜里只剩下了一枚金币——都在沿路上撒光了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而刑场救人这一次呢，也十分有海盗特色，首先就是杰克和天文学家卡琳娜分别在断头台和绞刑架的嘴炮，特别是杰克的油嘴滑舌真的非常有杰克特色。当然也不能让他们白白打这么久的嘴炮，在准备行刑的时候，杰克的船员出现了，炸毁了断头台，留下杰克一直与断头台的刀子进行生命的旋转——这个地方真的十分搞笑又让人捏了一把汗，不过最后自然是杰克安全着地。而主角众人也终于凑齐，为了共同的目标海神三叉戟来开始航海。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;杰克这里先放一边，本部电影的亮点所在是巴博萨船长，在杰克遭遇到萨拉查之前，巴博萨先碰上了他和他的鬼船。尽管在萨拉查自由之前，干掉了黑胡子的巴博萨是海上最强的海盗，但是遇到了杀人不眨眼而且海上无敌手并拥有不死之身的萨拉查和他的船员，巴博萨选择了先示好认怂，带领萨拉查找到他的仇人杰克。这无疑是在刀尖上舔血，但是巴博萨奸诈归奸诈，却并不是胆小怕事之辈。他成功在日出之前找到了杰克，保住了他和不少船员的性命。之后当他们上岸追赶杰克的时候他又反水去寻找三叉戟准备向萨拉查发起挑战，从这些看来巴博萨真的是当之无愧的海上枭雄。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在巴博萨夺得的黑胡子的剑的助攻下，黑珍珠号再次出山，而没想到的是一直在找爸爸的卡特琳娜的爸爸居然正是巴博萨，巴博萨原来是因为自己给不了孩子幸福才“抛弃了她”，只留下了一本带有红宝石的笔记本来让她能过得好一些。虽然这出发点是好的，但是抛弃这事怎么说都是不对的。最后果不其然当大海将要闭合，一行拼命逃向船的危急时刻，巴博萨为了救刚刚相认女儿带着萨拉查一起进入海洋中了……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;巴博萨和杰克相爱相杀，从开始的完全的敌人，到后来再次复活之后的惺惺相惜，亦敌亦友，到现在又再次死去。我想少了巴博萨的海上，杰克可能也会觉得没那么精彩了吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间的剧情没什么好说的，不过看得还是挺爽的，最后因为三叉戟被打破，海上的诅咒都被消除，特纳也终于可以从荷兰人号回到岸上和爱人相遇，特纳和亨利他们父子两对恩爱的夫妇在夕阳的土坡上撒狗粮之时，杰克已经先一步出航成功地躲开了双重暴击 233。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影的话，杰克依然是绝对的男主，亨利的话感觉主要作用就是推动剧情的发展……</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一部很有情怀的作品，剧情和前面关联得比较紧密，没有看前面的话虽然不影响观看，但是一些细节的地方就没有看过之后有感触了。不过在情怀的同时故事也讲得不错，整部电影看得非常爽快，连没看过这系列的女票都觉得很过瘾。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较遗憾的地方就是巴博萨领便当的这个情节比较套路，还有就是杰克什么时候才能找到女朋友啊 233，期待下一部，希望不要再等这么多年了……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《加勒比海盗-5：死无对证》&quot;&gt;&lt;a href=&quot;#《加勒比海盗-5：死无对证》&quot; class=&quot;headerlink&quot; title=&quot;《加勒比海盗 5：死无对证》&quot;&gt;&lt;/a&gt;《加勒比海盗 5：死无对证》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="海盗" scheme="https://blog.patrickcty.cc/tags/%E6%B5%B7%E7%9B%97/"/>
    
      <category term="德普" scheme="https://blog.patrickcty.cc/tags/%E5%BE%B7%E6%99%AE/"/>
    
      <category term="情怀" scheme="https://blog.patrickcty.cc/tags/%E6%83%85%E6%80%80/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式复习——第一章</title>
    <link href="https://blog.patrickcty.cc/2017/06/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://blog.patrickcty.cc/2017/06/19/嵌入式复习——第一章/</id>
    <published>2017-06-19T06:13:09.000Z</published>
    <updated>2017-06-19T06:14:07.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式复习——第一章"><a href="#嵌入式复习——第一章" class="headerlink" title="嵌入式复习——第一章"></a>嵌入式复习——第一章</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="嵌入式操作系统分类"><a href="#嵌入式操作系统分类" class="headerlink" title="嵌入式操作系统分类"></a>嵌入式操作系统分类</h2><h3 id="按收费模式划分"><a href="#按收费模式划分" class="headerlink" title="按收费模式划分"></a>按收费模式划分</h3><ul>
<li>商用型：VxWorks, Nucleux, PlamOS, Symbian, WinCE, QNX, pSOS, VRTX, Lynx OS, Hopen, Delta OS</li>
<li>免费型：Linux, μCLinux 等</li>
</ul>
<h3 id="按实时性划分"><a href="#按实时性划分" class="headerlink" title="按实时性划分"></a>按实时性划分</h3><ul>
<li>硬实时：VxWorks</li>
<li>软实时：WinCE, RTLinux</li>
<li>无实时：Embedded Linux</li>
</ul>
<h2 id="实时性概念"><a href="#实时性概念" class="headerlink" title="实时性概念"></a>实时性概念</h2><p>实时性的本质是任务处理花费时间的可预测性，即任务需要在规定的时限内完成。</p>
<p>软实时意味着如果没有满足制定的时间约束不会导致灾难性的后果，而对于影视是系统来说却是灾难性的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式复习——第一章&quot;&gt;&lt;a href=&quot;#嵌入式复习——第一章&quot; class=&quot;headerlink&quot; title=&quot;嵌入式复习——第一章&quot;&gt;&lt;/a&gt;嵌入式复习——第一章&lt;/h1&gt;&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;head
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="嵌入式" scheme="https://blog.patrickcty.cc/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《Linux/Unix 使用》复习（二）</title>
    <link href="https://blog.patrickcty.cc/2017/06/19/linux%E5%A4%8D%E4%B9%A02/"/>
    <id>https://blog.patrickcty.cc/2017/06/19/linux复习2/</id>
    <published>2017-06-19T01:35:38.000Z</published>
    <updated>2017-06-19T01:50:24.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Linux-Unix-使用》复习（二）"><a href="#《Linux-Unix-使用》复习（二）" class="headerlink" title="《Linux/Unix 使用》复习（二）"></a>《Linux/Unix 使用》复习（二）</h1><h1 id="安装和卸载"><a href="#安装和卸载" class="headerlink" title="安装和卸载"></a>安装和卸载</h1><h2 id="硬盘的磁道与扇区"><a href="#硬盘的磁道与扇区" class="headerlink" title="硬盘的磁道与扇区"></a>硬盘的磁道与扇区</h2><ul>
<li>磁道：磁碟的每一面划分的大小不同的同心圆</li>
<li>柱面：全部磁碟面上有相同半径的磁道，也就是说每个磁碟的相同地方的磁道连起来就形成了柱面</li>
<li>扇区：磁道划成的若干小弧段</li>
<li>磁头：每个磁碟有两面对应两个磁头</li>
</ul>
<blockquote>
<p>访问一个具体的扇区需要的物理参数是 （柱面号/磁道号，磁头号，扇区号）</p>
<p>硬盘总容量 = 柱面数 × 磁头数 × 每个磁道的扇区数 × 512 KB</p>
</blockquote>
<h2 id="硬盘的分区"><a href="#硬盘的分区" class="headerlink" title="硬盘的分区"></a>硬盘的分区</h2><blockquote>
<p>柱面是分区的边界，即一个分区包含整数个连续编号的柱面</p>
</blockquote>
<h3 id="MBR-的分区"><a href="#MBR-的分区" class="headerlink" title="MBR 的分区"></a>MBR 的分区</h3><p>（0 柱面，0 磁头，1 扇区）是硬盘的主引导分区，里面存放了：</p>
<ul>
<li>硬盘的主引导程序</li>
<li>四个分区表记录</li>
<li>硬盘有效标志</li>
</ul>
<p>分区记录表里面用来存放分区的信息，且存放的一定是主分区，否则则是逻辑分区。</p>
<h4 id="主分区"><a href="#主分区" class="headerlink" title="主分区"></a>主分区</h4><p>也可称为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。其中的主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区。</p>
<p>总之主分区和操作系统是密切相关的。</p>
<h4 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h4><p>也要占用分区表记录，用来创建逻辑分区。一个扩展分区对应着多个逻辑分区。</p>
<h4 id="逻辑分区"><a href="#逻辑分区" class="headerlink" title="逻辑分区"></a>逻辑分区</h4><p>仅仅只是存储介质，和操作系统以及主分区无关，作用类似于 U 盘。</p>
<h3 id="Linux-分区方法"><a href="#Linux-分区方法" class="headerlink" title="Linux 分区方法"></a>Linux 分区方法</h3><ul>
<li>创建根分区（主分区），挂载 / 目录</li>
<li>交换分区（主分区，可选），大小为物理内存两倍，但最大不超过 4GB</li>
</ul>
<h3 id="GPT-的分区"><a href="#GPT-的分区" class="headerlink" title="GPT 的分区"></a>GPT 的分区</h3><p>GPT 支持分区数可达 128 个，只有支持 UEFI 的主板才能从 GPT 分区硬盘启动操作系统。</p>
<h3 id="分区命名"><a href="#分区命名" class="headerlink" title="分区命名"></a>分区命名</h3><blockquote>
<p>/dev/设备代号和设备代号数（如果不包含代号数则是整块硬盘）</p>
</blockquote>
<p>例如 /dev/sdb5</p>
<ul>
<li>sdb 表示第二块硬盘</li>
<li>5 表示第五个分区，在这里是逻辑分区</li>
</ul>
<p>其中光盘命名为 /dev/cdrom<br>IDE 硬盘为 /dev/hd[a~z][1~16]</p>
<h2 id="卸载-Linux"><a href="#卸载-Linux" class="headerlink" title="卸载 Linux"></a>卸载 Linux</h2><p>所谓卸载，就是在分区表中删除掉 Linux 的分区并且修改主引导程序</p>
<p>删除分区方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo fdisk /dev/sda  # 假如要删除第一块硬盘的分区，然后再在里面进行相应的操作</div></pre></td></tr></table></figure></p>
<h2 id="初步管理"><a href="#初步管理" class="headerlink" title="初步管理"></a>初步管理</h2><pre><code>pass，如果习题里面出现再看
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《Linux-Unix-使用》复习（二）&quot;&gt;&lt;a href=&quot;#《Linux-Unix-使用》复习（二）&quot; class=&quot;headerlink&quot; title=&quot;《Linux/Unix 使用》复习（二）&quot;&gt;&lt;/a&gt;《Linux/Unix 使用》复习（二）&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="Linux" scheme="https://blog.patrickcty.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《Linux/Unix 使用》复习（一）</title>
    <link href="https://blog.patrickcty.cc/2017/06/19/linux%E5%A4%8D%E4%B9%A01/"/>
    <id>https://blog.patrickcty.cc/2017/06/19/linux复习1/</id>
    <published>2017-06-19T01:35:35.000Z</published>
    <updated>2017-06-19T01:40:41.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Linux-Unix-使用》复习（一）"><a href="#《Linux-Unix-使用》复习（一）" class="headerlink" title="《Linux/Unix 使用》复习（一）"></a>《Linux/Unix 使用》复习（一）</h1><h1 id="Linux-系统概况"><a href="#Linux-系统概况" class="headerlink" title="Linux 系统概况"></a>Linux 系统概况</h1><h2 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h2><blockquote>
<p>major.minor.patch-build.desc</p>
</blockquote>
<ul>
<li>major 主版本号</li>
<li>minor 次版本号——新增明显功能时递增<ul>
<li>奇数：开发板</li>
<li>偶数：稳定版</li>
</ul>
</li>
<li>patch 对 minor 的修订次数——修订或打补丁时递增</li>
<li>build 编译次数——对少量代码优化或者修改并重新编译则递增</li>
<li>desc 当前版本特殊信息——用英文单词或缩写表示，例如 generic 表示通用内核</li>
</ul>
<h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">cond1=&gt;condition: 他人修改源代码</div><div class="line">是否可以闭源？</div><div class="line">cond2=&gt;condition: 新增源代码</div><div class="line">是否采用</div><div class="line">同样许可证？</div><div class="line">cond3=&gt;condition: 每一个修改过的</div><div class="line">文件是否都</div><div class="line">必须放入版权声明？</div><div class="line">cond4=&gt;condition: 是否需要对</div><div class="line">源代码的修改</div><div class="line">之处提供说明文档？</div><div class="line">cond5=&gt;condition: 衍生软件</div><div class="line">是否可以用</div><div class="line">你的名字促销？</div><div class="line">op1=&gt;operation: LGPL</div><div class="line">op2=&gt;operation: Mozilla</div><div class="line">op3=&gt;operation: GPL</div><div class="line">op4=&gt;operation: BSD</div><div class="line">op5=&gt;operation: MIT</div><div class="line">op6=&gt;operation: Apache</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">cond1</div><div class="line">cond1(yes)-&gt;cond3</div><div class="line">cond1(no)-&gt;cond2</div><div class="line">cond2(yes)-&gt;op3</div><div class="line">cond2(no)-&gt;cond4</div><div class="line">cond3(yes)-&gt;op6</div><div class="line">cond3(no)-&gt;cond5</div><div class="line">cond4(yes)-&gt;op2</div><div class="line">cond4(no)-&gt;op1</div><div class="line">cond5(yes)-&gt;op5</div><div class="line">cond5(no)-&gt;op4</div></pre></td></tr></table></figure>
<p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a>是按照这个的语法来写的，如果无法渲染就用 CMD MarkDown 来看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《Linux-Unix-使用》复习（一）&quot;&gt;&lt;a href=&quot;#《Linux-Unix-使用》复习（一）&quot; class=&quot;headerlink&quot; title=&quot;《Linux/Unix 使用》复习（一）&quot;&gt;&lt;/a&gt;《Linux/Unix 使用》复习（一）&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="Linux" scheme="https://blog.patrickcty.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ArduinoLearn2</title>
    <link href="https://blog.patrickcty.cc/2017/06/17/ArduinoLearn2/"/>
    <id>https://blog.patrickcty.cc/2017/06/17/ArduinoLearn2/</id>
    <published>2017-06-17T05:48:10.000Z</published>
    <updated>2017-06-19T01:44:22.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arduino-学习（二）：-高级输入输出"><a href="#Arduino-学习（二）：-高级输入输出" class="headerlink" title="Arduino 学习（二）： 高级输入输出"></a>Arduino 学习（二）： 高级输入输出</h1><h2 id="传感器型开关"><a href="#传感器型开关" class="headerlink" title="传感器型开关"></a>传感器型开关</h2><p>上一次的学习中使用的是瞬时按键来控制开关，其实瞬时按键只是传感器型开关的一种，它能检测它是否被按下。而类似的传感器型开关还有：</p>
<ul>
<li>拨动开关：类似于灯的开关</li>
<li>温控器：根据温度来调节</li>
<li>磁力开关：两个小金属片，靠近磁场的时候会吸在一起</li>
<li>压力开关：压力达到一定程度就会检测到</li>
<li>倾斜开关：由一些触点和小球构成，倾斜小球会离开触点</li>
<li>PIR 传感器：检测人是否在范围内移动</li>
</ul>
<h2 id="灯光逐渐点亮熄灭"><a href="#灯光逐渐点亮熄灭" class="headerlink" title="灯光逐渐点亮熄灭"></a>灯光逐渐点亮熄灭</h2><p>在之前控制亮灭的时候中间要有一定时间的延时，因为间隔太小的话人眼是无法捕捉相应的变化的。而间隔太小的时候虽然无法看出闪烁，但是能感觉到亮度比一直亮着的时候要暗，这种通过改变脉冲宽度来改变亮度的技术叫做脉宽调制，或 PWN。</p>
<p>而在 Arduino 中为了避免代码的长度给调节亮度造成的影响于是有了 analogWrite() 函数。</p>
<p>下面便是逐渐点亮和熄灭 LED 灯的代码，电路则只用把 LED 灯一边接在 9 端口，一边接在 GND，当然保护电阻也是不可少的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const int LED = 9;</div><div class="line">int i = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    for (; i &lt; 255; ++i) &#123;</div><div class="line">        analogWrite(LED, i);</div><div class="line">        delay(10);  // 延时，否则看不到变化</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (; i &gt; 0; --i) &#123;</div><div class="line">        analogWrite(LED, i);</div><div class="line">        delay(10);  // 延时，否则看不到变化</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>analogWrite(引脚号, 亮度)<br>-&gt; 这里亮度是从 0~255，0 是全灭，255 是全亮，引脚号只能为3、5、6、9、10、11，因为这个功能需要硬件的支持。</p>
</blockquote>
<h2 id="通过按钮控制灯管亮度"><a href="#通过按钮控制灯管亮度" class="headerlink" title="通过按钮控制灯管亮度"></a>通过按钮控制灯管亮度</h2><p>如果想通过瞬时开关来进行亮度调节，则需要捕捉按下按键时间了，在下面的代码里面，按开关则改变灯的状态，而长按则调整亮度，亮度达到顶峰就变为零。</p>
<p>电路图为上面的电路图和上一次电路图的结合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">const int LED = 9;</div><div class="line">const int BUTTON = 7;</div><div class="line"></div><div class="line">int val = 0;</div><div class="line">int old_val = 0;</div><div class="line">int state = 0;</div><div class="line">int brightness = 128;</div><div class="line">unsigned long startTime = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT);</div><div class="line">    pinMode(BUTTON, INPUT);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    val = digitalRead(BUTTON);</div><div class="line"></div><div class="line">    if (val == HIGH &amp;&amp; old_val == LOW) &#123;  // 按下按钮则改变状态</div><div class="line">        state = 1 - state;</div><div class="line">        startTime = millis();  // millis 返回距离上次重置所用的毫秒数</div><div class="line">        delay(10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (val == HIGH &amp;&amp; old_val == HIGH) &#123;  // 长按则调节亮度</div><div class="line">        if (state == 1 &amp;&amp; (millis() - startTime) &gt; 500) &#123;</div><div class="line">            brightness++;</div><div class="line">            delay(10);</div><div class="line"></div><div class="line">            if (brightness &gt; 255) &#123;</div><div class="line">                brightness = 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    old_val = val;</div><div class="line"></div><div class="line">    if (state == 1) &#123;</div><div class="line">        analogWrite(LED, brightness);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        analogWrite(LED, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>millis()<br>-&gt; 获取距离上次重置所用的毫秒数，这里用来测量按下的时间</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Arduino-学习（二）：-高级输入输出&quot;&gt;&lt;a href=&quot;#Arduino-学习（二）：-高级输入输出&quot; class=&quot;headerlink&quot; title=&quot;Arduino 学习（二）： 高级输入输出&quot;&gt;&lt;/a&gt;Arduino 学习（二）： 高级输入输出&lt;/
    
    </summary>
    
      <category term="Arduino" scheme="https://blog.patrickcty.cc/categories/Arduino/"/>
    
    
      <category term="Arduino" scheme="https://blog.patrickcty.cc/tags/Arduino/"/>
    
      <category term="硬件" scheme="https://blog.patrickcty.cc/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式复习——第二章</title>
    <link href="https://blog.patrickcty.cc/2017/06/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://blog.patrickcty.cc/2017/06/15/嵌入式复习——第二章/</id>
    <published>2017-06-15T11:14:19.000Z</published>
    <updated>2017-06-15T11:15:19.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式复习——第二章"><a href="#嵌入式复习——第二章" class="headerlink" title="嵌入式复习——第二章"></a>嵌入式复习——第二章</h1><h2 id="Linux-基础命令"><a href="#Linux-基础命令" class="headerlink" title="Linux 基础命令"></a>Linux 基础命令</h2><blockquote>
<p>useradd [选项] 用户名</p>
</blockquote>
<ul>
<li>创建用户</li>
<li>需要 root 权限</li>
</ul>
<blockquote>
<p>passwd [用户名]</p>
</blockquote>
<ul>
<li>修改密码</li>
<li>需要 root 权限</li>
</ul>
<blockquote>
<p>ps [选项]</p>
</blockquote>
<ul>
<li>查看进程</li>
<li>选项：<ul>
<li>-ef 查看所有进程的信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>kill [选项] PID</p>
</blockquote>
<ul>
<li>杀死进程</li>
</ul>
<blockquote>
<p>fdisk [-l]</p>
</blockquote>
<ul>
<li>查看磁盘分区</li>
<li>需要 root 权限</li>
</ul>
<blockquote>
<p>mount [选项] [类型] 设备名 挂载目录</p>
</blockquote>
<ul>
<li>挂载磁盘</li>
<li>需要 root 权限</li>
<li>设备名可以通过 fdisk 查看</li>
<li>例<code>sudo mount /dev/sdb3 disk</code> 是将 /dev/sdb3 设备挂载到 ~/disk 目录上</li>
</ul>
<blockquote>
<p>umount 挂载目录</p>
</blockquote>
<ul>
<li>卸载磁盘</li>
<li>需要 root 权限</li>
</ul>
<blockquote>
<p>mkdir [选项] 路径</p>
</blockquote>
<ul>
<li>创建目录</li>
<li>选项<ul>
<li>-m 设置权限，用法类似于 chmod</li>
<li>-p 可以是一个路径名称，不存在的目录会自动创建</li>
</ul>
</li>
</ul>
<blockquote>
<p>cat [选项] 文件 1  文件 2 ……</p>
</blockquote>
<ul>
<li>查看文件，多个文件就合并在一起查看</li>
<li>选项<ul>
<li>-n 显示行号</li>
<li>-b 显示非空白行行号</li>
</ul>
</li>
</ul>
<blockquote>
<p>cp [选项] 源目录 目的目录</p>
</blockquote>
<ul>
<li>复制文件</li>
<li>选项<ul>
<li>-a 保留所有内容</li>
</ul>
</li>
</ul>
<blockquote>
<p>mv [选项] 源目录 目的目录</p>
</blockquote>
<ul>
<li>移动文件</li>
<li>选项<ul>
<li>-i 有覆盖就询问</li>
</ul>
</li>
</ul>
<blockquote>
<p>rm [选项] 文件目录名</p>
</blockquote>
<ul>
<li>删除文件或目录</li>
<li>选项<ul>
<li>-i 交互式删除，安全</li>
<li>-r 递归删除目录子目录</li>
<li>-f 忽略不存在的文件不给出提示</li>
</ul>
</li>
</ul>
<blockquote>
<p>chmod [选项] 符号权限 文件<br>或者 chmod [选项] 八进制权限 文件</p>
</blockquote>
<ul>
<li>设置权限</li>
<li>第一种方法<ul>
<li>a/u/g 表示对所有用户，所有者，用户组操作权限</li>
<li>+/-/= 表示添加删除设置权限</li>
<li>r/w/x 表示读写执行权限</li>
<li>例 <code>chmod +x a.py</code> 把该文件给当前用户增加执行权限</li>
</ul>
</li>
<li>第二种方法<ul>
<li>三个数是八进制数，八进制展开为三个二进制位分别表示表示读写执行，例如 5 就是 101 也就是只读和执行</li>
<li>例 <code>chmod 666 disk</code> 给 disk 目录对于所有用户、群组、所有者增加读写权限</li>
</ul>
</li>
<li>选项<ul>
<li>-R 递归操作，可以给文件夹的所有文件来修改权限 </li>
</ul>
</li>
</ul>
<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><blockquote>
<p>在 Ubuntu home 目录创建两个文件夹 con1 与 con2，挂在 U 盘到 con1 中，把 con1 中的文件复制到 con2 中，并把 con2 中所有文件改为可读可写</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~</div><div class="line">mkdir con1 con2</div><div class="line">sudo fdisk <span class="_">-l</span>  <span class="comment"># 查看 U 盘设备名</span></div><div class="line">mount /dev/sdb1 con1</div><div class="line">cp <span class="_">-a</span> con con2</div><div class="line">chmod -R 666 con2  <span class="comment"># R 是递归操作，对里面的所有文件夹</span></div></pre></td></tr></table></figure>
<h2 id="C-编程基础"><a href="#C-编程基础" class="headerlink" title="C 编程基础"></a>C 编程基础</h2><h3 id="gcc-的编译流程"><a href="#gcc-的编译流程" class="headerlink" title="gcc 的编译流程"></a>gcc 的编译流程</h3><ul>
<li>预处理，处理头文件、宏，产生 .i 文件</li>
<li>编译，产生 .s 文件</li>
<li>汇编，产生 .o 文件</li>
<li>链接，产生可执行文件</li>
</ul>
<h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><p>规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">目标: 依赖</div><div class="line">    命令</div></pre></td></tr></table></figure></p>
<p>平凡的样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">david: kang.o yul.o</div><div class="line">    gcc kang.o bar.o -o myprog</div><div class="line">kang.o: kang.c kang.h head.h</div><div class="line">    gcc -Wall -O -g -c kang.c -o kang.o</div><div class="line">yul.o: bar.c head.h</div><div class="line">    gcc -Wall -O -g -c yul.c -o yul.o</div><div class="line">    </div><div class="line">clean:</div><div class="line">    rm -f myprog</div></pre></td></tr></table></figure></p>
<p>其中从上到下是和编译的顺序相反，也就是一层层向内调用获得依赖</p>
<p>带有变量的样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">OBJS = kang.o yul.o</div><div class="line">CC = gcc</div><div class="line">CFLAGS = -Wall -O -g</div><div class="line">david: $(OBJS)</div><div class="line">    $(CC) $(OBJS) -o myprog</div><div class="line">kang.o: kang.c kang.h head.h</div><div class="line">    $(CC) $(CFLAGS) -c kang.c -o kang.o</div><div class="line">yul.o: bar.c head.h</div><div class="line">    $(CC) $(CFLAGS) -c yul.c -o yul.o</div><div class="line">    </div><div class="line">clean:</div><div class="line">    rm -f myprog</div></pre></td></tr></table></figure></p>
<p>其中变量是 $(变量名) 的形式来使用的</p>
<h2 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h2><blockquote>
<p>在 home 目录下使用 vi 创建 sum.c 文件，比阿尼额代码，实现数字 1 累加到 100 的程序<br>（1）使用 gcc 编译器编译，生成目标文件 sum_gcc 并执行<br>（2）编写 makefile 文件，编译 sum.c 文件生成目标文件 sum_makefile 并执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vi sum.c </div><div class="line">gcc -o sum.c sum_gcc</div><div class="line">./sum_gcc</div><div class="line"></div><div class="line">vi makefile</div></pre></td></tr></table></figure>
<p>makefile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sum: sum.o</div><div class="line">    gcc sum.o -o sum</div><div class="line">sum.o: sum.c</div><div class="line">    gcc -c sum.c -o sum.o</div><div class="line"></div><div class="line">clean:</div><div class="line">    rm -f sum</div></pre></td></tr></table></figure></p>
<h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>Bootloader 就是在操作系统的内核运行之前的一段程序，它类似于 PC 中的 BIOS 程序。通过这段程序，可以完成硬件设备的初始化，并建立内存空间的映射关系，从而将系统的软硬件环境带到一个合适的状态，为最终加载系统内核做好准备。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;嵌入式复习——第二章&quot;&gt;&lt;a href=&quot;#嵌入式复习——第二章&quot; class=&quot;headerlink&quot; title=&quot;嵌入式复习——第二章&quot;&gt;&lt;/a&gt;嵌入式复习——第二章&lt;/h1&gt;&lt;h2 id=&quot;Linux-基础命令&quot;&gt;&lt;a href=&quot;#Linux-基础命令&quot;
    
    </summary>
    
      <category term="复习" scheme="https://blog.patrickcty.cc/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="嵌入式" scheme="https://blog.patrickcty.cc/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Arduino 学习（一）： 简单的 LED 程序</title>
    <link href="https://blog.patrickcty.cc/2017/06/15/ArduinoLearn1/"/>
    <id>https://blog.patrickcty.cc/2017/06/15/ArduinoLearn1/</id>
    <published>2017-06-15T08:13:55.000Z</published>
    <updated>2017-06-15T08:15:31.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arduino-学习（一）：-简单的-LED-程序"><a href="#Arduino-学习（一）：-简单的-LED-程序" class="headerlink" title="Arduino 学习（一）： 简单的 LED 程序"></a>Arduino 学习（一）： 简单的 LED 程序</h1><h2 id="LED-闪烁"><a href="#LED-闪烁" class="headerlink" title="LED 闪烁"></a>LED 闪烁</h2><p>Arduino 的 LED 闪烁和其他语言开始的 Hello, world! 类似，是开始 Arduino 之旅的第一段程序。</p>
<h3 id="电路接法"><a href="#电路接法" class="headerlink" title="电路接法"></a>电路接法</h3><p>LED 长脚(+)接在 13 号引脚，短脚(-)接在 GND。</p>
<h3 id="LED-闪烁代码"><a href="#LED-闪烁代码" class="headerlink" title="LED 闪烁代码"></a>LED 闪烁代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const int LED = 13;  // Arduino 默认板上的 LED 就是连接 13 端口 </div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">  // 初始化，只有在程序开始的时候会执行</div><div class="line">  pinMode(LED, OUTPUT);  // 设置引脚，并且引脚用来输出</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">  // 重复执行的主程序</div><div class="line">  // digitalWrite 打开或关闭任何设置为输出的引脚</div><div class="line">  digitalWrite(LED, HIGH);  // 将电位置为高电位</div><div class="line">  delay(1000);  // 单位为 ms</div><div class="line">  digitalWrite(LED, LOW);</div><div class="line">  delay(1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里用到了三个函数</p>
<p>用来控制特定引脚输入输出情况</p>
<blockquote>
<p>pinMode(引脚号, 输入/输出) </p>
</blockquote>
<p>用来改变特定引脚的电位高低</p>
<blockquote>
<p>digitalWrite(引脚号, 高/低电位)</p>
</blockquote>
<p>用来延时</p>
<blockquote>
<p>delay(毫秒数)</p>
</blockquote>
<h2 id="按钮控制-LED"><a href="#按钮控制-LED" class="headerlink" title="按钮控制 LED"></a>按钮控制 LED</h2><p>光闪烁当然没意思，这次用一个按钮来控制 LED。</p>
<h3 id="电路接法-1"><a href="#电路接法-1" class="headerlink" title="电路接法"></a>电路接法</h3><ul>
<li>LED 同上</li>
<li>按钮一边接到 7 号引脚另一边是 GND</li>
</ul>
<h3 id="长按亮代码"><a href="#长按亮代码" class="headerlink" title="长按亮代码"></a>长按亮代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const int LED = 13;  </div><div class="line">const int BUTTOM = 7;</div><div class="line">int val = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT); </div><div class="line">    pinMode(BUTTOM, INPUT);  // 按钮作为输入部分接在 7 号引脚</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    val = digitalRead(BUTTOM);  // 按钮被按下的时候为高，否则为低</div><div class="line"></div><div class="line">    if (val == HIGH) &#123;</div><div class="line">        digitalWrite(LED, HIGH);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        digitalWrite(LED, LOW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用到了一个新函数</p>
<p>查看特定引脚处的电位状态，返回值为 HIGH 或 LOW</p>
<blockquote>
<p>digitalRead(引脚号)</p>
</blockquote>
<p>注意由于开关默认情况是按下之后立刻弹起，所以如果只按一下是看不到灯的变化的，只有一直按着灯才会亮起来。而由于 Arduino 运行得很快（相对于人手），因此 val 是一直在被重新赋值的。</p>
<p>一直按着显然不符合常理，正常操作应该是按下时点亮，再按熄灭。</p>
<h3 id="按下时点亮，再按熄灭"><a href="#按下时点亮，再按熄灭" class="headerlink" title="按下时点亮，再按熄灭"></a>按下时点亮，再按熄灭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const int LED = 13;  </div><div class="line">const int BUTTOM = 7;</div><div class="line">int val = 0;</div><div class="line">int state = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT); </div><div class="line">    pinMode(BUTTOM, INPUT);  // 按钮作为输入部分接在 7 号引脚</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    val = digitalRead(BUTTOM);  // 按钮被按下的时候为高，否则为低</div><div class="line"></div><div class="line">    if (val == HIGH) &#123;</div><div class="line">        state = !state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (state) &#123;</div><div class="line">        digitalWrite(LED, HIGH);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        digitalWrite(LED, LOW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里增加了一个状态位 state，只有当 val 变为 HIGH 的时候才会改变原来的状态，也就是按下时点亮，再按熄灭。</p>
<p>但是这样又有点问题，那就是因为程序运行得太快，因此在我们按下去的“一瞬间”，对 Arduino 已经循环了好多次了，state 的值在多次变化，最终的 state 的值是无法确定的，因此程序要继续改进。</p>
<p>改进的方法就是只有当 val 为 HIGH 且 val 前一次的值为 LOW 的时候才对 state 进行改变。</p>
<h3 id="改进后的按下时点亮，再按熄灭"><a href="#改进后的按下时点亮，再按熄灭" class="headerlink" title="改进后的按下时点亮，再按熄灭"></a>改进后的按下时点亮，再按熄灭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">const int LED = 13;  </div><div class="line">const int BUTTOM = 7;</div><div class="line">int val = 0;</div><div class="line">int old_val = 0;</div><div class="line">int state = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT); </div><div class="line">    pinMode(BUTTOM, INPUT);  // 按钮作为输入部分接在 7 号引脚</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    val = digitalRead(BUTTOM);  // 按钮被按下的时候为高，否则为低</div><div class="line"></div><div class="line">    if (val == HIGH &amp;&amp; old_val == LOW) &#123;</div><div class="line">        state = !state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    old_val = val;</div><div class="line"></div><div class="line">    if (state) &#123;</div><div class="line">        digitalWrite(LED, HIGH);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        digitalWrite(LED, LOW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来理论上就可以比较好地运行程序了，但是因为按键开关的机械特性，在按下的时候触点之间会发生弹跳，也就是开关在一定时间会在开和关之间抖动，虽然时间很短，但是对于 Arduino 来说完全可以检测到了，这时候就要进行“去抖”——也就是在改变状态之后延时一段时间，通常这里只需要 10~15ms。</p>
<h3 id="去抖后的按下时点亮，再按熄灭"><a href="#去抖后的按下时点亮，再按熄灭" class="headerlink" title="去抖后的按下时点亮，再按熄灭"></a>去抖后的按下时点亮，再按熄灭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">const int LED = 13;  </div><div class="line">const int BUTTOM = 7;</div><div class="line">int val = 0;</div><div class="line">int old_val = 0;</div><div class="line">int state = 0;</div><div class="line"></div><div class="line">void setup() &#123;</div><div class="line">    pinMode(LED, OUTPUT); </div><div class="line">    pinMode(BUTTOM, INPUT);  // 按钮作为输入部分接在 7 号引脚</div><div class="line">&#125;</div><div class="line"></div><div class="line">void loop() &#123;</div><div class="line">    val = digitalRead(BUTTOM);  // 按钮被按下的时候为高，否则为低</div><div class="line"></div><div class="line">    if (val == HIGH &amp;&amp; old_val == LOW) &#123;</div><div class="line">        state = !state;</div><div class="line">        delay(10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (val == LOW &amp;&amp; old_val == HIGH) </div><div class="line">        delay(10);</div><div class="line"></div><div class="line">    old_val = val;</div><div class="line"></div><div class="line">    if (state) &#123;</div><div class="line">        digitalWrite(LED, HIGH);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        digitalWrite(LED, LOW);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，LED 程序就结束了。</p>
<p>Arduino 还是很有趣的，不过对于我这种手残党可能就要走一些弯路了 orz。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Arduino-学习（一）：-简单的-LED-程序&quot;&gt;&lt;a href=&quot;#Arduino-学习（一）：-简单的-LED-程序&quot; class=&quot;headerlink&quot; title=&quot;Arduino 学习（一）： 简单的 LED 程序&quot;&gt;&lt;/a&gt;Arduino 学习（
    
    </summary>
    
      <category term="Arduino" scheme="https://blog.patrickcty.cc/categories/Arduino/"/>
    
    
      <category term="Arduino" scheme="https://blog.patrickcty.cc/tags/Arduino/"/>
    
      <category term="硬件" scheme="https://blog.patrickcty.cc/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>运行 Vue.js 蠢萌的 Markdown 编辑器的时候遇到的坑</title>
    <link href="https://blog.patrickcty.cc/2017/05/28/%E8%BF%90%E8%A1%8CVue%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://blog.patrickcty.cc/2017/05/28/运行Vue的示例代码遇到的坑/</id>
    <published>2017-05-28T12:56:44.000Z</published>
    <updated>2017-05-28T12:58:57.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行-Vue-js-蠢萌的-Markdown-编辑器的时候遇到的坑"><a href="#运行-Vue-js-蠢萌的-Markdown-编辑器的时候遇到的坑" class="headerlink" title="运行 Vue.js 蠢萌的 Markdown 编辑器的时候遇到的坑"></a>运行 Vue.js 蠢萌的 Markdown 编辑器的时候遇到的坑</h1><p>在基本看了 Vue 的介绍之后我就准备运行 Vue.js 蠢萌的 Markdown 编辑器来看看效果，没想到遇到了不少坑…</p>
<h2 id="Vue-的实例并没有初始化"><a href="#Vue-的实例并没有初始化" class="headerlink" title="Vue 的实例并没有初始化"></a>Vue 的实例并没有初始化</h2><p>浏览器里报错 <code>_ is not defined</code></p>
<p>我 Google 了很久但是一直不得要点，最后放弃的时候 Google 了一下 <code>_.debounce</code> 这个函数。</p>
<blockquote>
<p>_.debounce(func, [wait=0], [options])</p>
<p>创建一个防抖动函数。 该函数会在 wait 毫秒后调用 func 方法。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定延迟前后如何触发。 func 会传入最后一次传入的参数给防抖动函数。 随后调用的防抖动函数返回是最后一次 func 调用的结果。</p>
</blockquote>
<p>原来 _ 并不是一个变量，这个函数是来自于 <code>underscore.js</code> 这个模块的，于是接下来就引入这个模块就好了。</p>
<h2 id="mark-模块也要引入"><a href="#mark-模块也要引入" class="headerlink" title="mark 模块也要引入"></a>mark 模块也要引入</h2><p>这里之所以能用这么少的代码就完成 MarkDown 编辑器是因为用了解析 MarkDown 的库，而这个库是来自 <code>marked.js</code> ，也就是说这个模块也需要引入。</p>
<h2 id="注意引入的顺序"><a href="#注意引入的顺序" class="headerlink" title="注意引入的顺序"></a>注意引入的顺序</h2><p>这里一共用到了四个 js 文件，其中</p>
<ul>
<li>vue.js 是最重要的 js，也是最先被渲染的，因此应该放在第一个引入</li>
<li>md.js 这里初始化了 Vue 的实例，但是因为它用到了 Underscore.js 因此必须在它之后渲染，于是把它放在最后</li>
<li>underscore.js 这里是 _.debounce 的来源，没有这个函数页面不能正常显示，因此它要在第二个引入</li>
<li><p>marked.js 这是解析 MarkDown 的模块，在 _.debounce 之后才会调用，放在第三个引入</p>
<p>正常运行的代码片段   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://unpkg.com/vue@2.3.3/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/underscore.js/1.8.3/underscore-min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;md.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="完整代码及分析"><a href="#完整代码及分析" class="headerlink" title="完整代码及分析"></a>完整代码及分析</h2><p>md.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">        &lt;title&gt;Vue Markdown Editor&lt;/title&gt;</div><div class="line">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;md.css&quot;&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">        </div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;div id=&quot;editor&quot;&gt;</div><div class="line">            &lt;textarea :value=&quot;input&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt;</div><div class="line">            &lt;div v-html=&quot;compiledMarkdown&quot;&gt;&lt;/div&gt;</div><div class="line">        &lt;/div&gt;     </div><div class="line">    &lt;/body&gt;</div><div class="line"></div><div class="line">    &lt;script src=&quot;https://unpkg.com/vue@2.3.3/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;https://cdn.bootcss.com/underscore.js/1.8.3/underscore-min.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;md.js&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>其中第十一行 textarea 是 Vue 中的文本区域组件，构成了编辑器的左半部分，里面的内容是由 input 中的值来指定的。而 @input 则监视了 textarea 的内容，有变化则调用 update 的内容。</p>
<p>md.css</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">html, body, #editor &#123;</div><div class="line">  margin: 0;</div><div class="line">  height: 100%;</div><div class="line">  font-family: &apos;Helvetica Neue&apos;, Arial, sans-serif;</div><div class="line">  color: #333;</div><div class="line">&#125;</div><div class="line"></div><div class="line">textarea, #editor div &#123;</div><div class="line">  display: inline-block;</div><div class="line">  width: 49%;</div><div class="line">  height: 100%;</div><div class="line">  vertical-align: top;</div><div class="line">  box-sizing: border-box;</div><div class="line">  padding: 0 20px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">textarea &#123;</div><div class="line">  border: none;</div><div class="line">  border-right: 1px solid #ccc;</div><div class="line">  resize: none;</div><div class="line">  outline: none;</div><div class="line">  background-color: #f6f6f6;</div><div class="line">  font-size: 14px;</div><div class="line">  font-family: &apos;Monaco&apos;, courier, monospace;</div><div class="line">  padding: 20px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">code &#123;</div><div class="line">  color: #f66;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个没什么好说的。</p>
<p>md.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var app = new Vue(&#123;</div><div class="line">  el: &apos;#editor&apos;,</div><div class="line">  data: &#123;</div><div class="line">    input: &apos;# hello&apos;</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    compiledMarkdown: function () &#123;</div><div class="line">      return marked(this.input, &#123; sanitize: true &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    update: _.debounce(function (e) &#123;</div><div class="line">      this.input = e.target.value</div><div class="line">    &#125;, 300)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里是初始化了一个 Vue 的实例，其中 input 存放 md 源文件的内容。</p>
<p>computed 是计算属性，它使得 input 一发生改变计算属性就重新求值。详情可以看<a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7" target="_blank" rel="external">官方文档</a>。</p>
<p>而 methods 里面的 update 就是当检测到 DOM 的变化之后得到事件对象被 e 接收，然后再把新的内容 e.target.value 赋值给 input。而为了防止抖动，使用了 _.debounce。</p>
<p>关于事件对象：</p>
<blockquote>
<p>而事件对象也有很多属性和方法，其中target属性是获取触发事件对象的目标，也就是绑定事件的元素，e.target表示该DOM元素，然后在获取其相应的属性值。<br>来源：<a href="http://www.imooc.com/qadetail/153498" target="_blank" rel="external">http://www.imooc.com/qadetail/153498</a></p>
</blockquote>
<p>在这里 _.debounce 接受了两个参数，第一个是要防抖的函数，第二个是需要延迟的毫秒数，也就是说刷新得不会太快。详情见<a href="http://lodash.think2011.net/debounce" target="_blank" rel="external">具体文档</a>。</p>
<p>因此综上，当输入了新的内容会触发 update 对 input 进行更新，然后根据 computed 的性质使得 v-html 也就是页面进行了更新，于是一个简单高效的编辑器就这样完成了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这一切都归根结底与 js 没有学好…其实也没怎么系统地学习 js，只学过一些皮毛的内容…回头继续看 Vue 的语法…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;运行-Vue-js-蠢萌的-Markdown-编辑器的时候遇到的坑&quot;&gt;&lt;a href=&quot;#运行-Vue-js-蠢萌的-Markdown-编辑器的时候遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;运行 Vue.js 蠢萌的 Markdown 编辑器
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="坑爹" scheme="https://blog.patrickcty.cc/tags/%E5%9D%91%E7%88%B9/"/>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="Vue.js" scheme="https://blog.patrickcty.cc/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>配置Vue命令行环境</title>
    <link href="https://blog.patrickcty.cc/2017/05/26/%E9%85%8D%E7%BD%AEVue%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.patrickcty.cc/2017/05/26/配置Vue命令行环境/</id>
    <published>2017-05-26T09:17:57.000Z</published>
    <updated>2017-05-26T09:18:34.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置-Vue-命令行环境"><a href="#配置-Vue-命令行环境" class="headerlink" title="配置 Vue 命令行环境"></a>配置 Vue 命令行环境</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 全局安装 vue-cli</div><div class="line">$ npm install --global vue-cli</div><div class="line"># 创建一个基于 webpack 模板的新项目</div><div class="line">$ vue init webpack my-project</div><div class="line"># 安装依赖，走你</div><div class="line">$ cd my-project</div><div class="line">$ npm install</div><div class="line">$ npm run dev</div></pre></td></tr></table></figure>
<p>但是在执行 <code>npm install</code> 的时候会报错</p>
<blockquote>
<p>Failed at the phantomjs-prebuilt@2.1.14 install script ‘node install.js’.</p>
</blockquote>
<p>解决方法</p>
<pre><code>npm install -g phantomjs-prebuilt@2.1.14 --ignore-scripts
</code></pre><p>现在就可以成功运行 Vue 项目了，注意上面这行命令的 -g 是指全局安装，不然只在安装目录下生效。上面的所有命令也都是在全局环境下安装的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; vue-project@1.0.0 dev /home/patrick/音乐/vue-project</div><div class="line">&gt; node build/dev-server.js</div><div class="line"></div><div class="line">&gt; Starting dev server...</div><div class="line"></div><div class="line"></div><div class="line"> DONE  Compiled successfully in 2323ms                                  17:14:54</div><div class="line"></div><div class="line">&gt; Listening at http://localhost:8080</div></pre></td></tr></table></figure>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>接下来就要慢慢学习 Vue 的各种语法了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置-Vue-命令行环境&quot;&gt;&lt;a href=&quot;#配置-Vue-命令行环境&quot; class=&quot;headerlink&quot; title=&quot;配置 Vue 命令行环境&quot;&gt;&lt;/a&gt;配置 Vue 命令行环境&lt;/h1&gt;&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; cla
    
    </summary>
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/categories/Fronted/"/>
    
    
      <category term="Fronted" scheme="https://blog.patrickcty.cc/tags/Fronted/"/>
    
      <category term="Vue.js" scheme="https://blog.patrickcty.cc/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>《摔跤吧，爸爸！》</title>
    <link href="https://blog.patrickcty.cc/2017/05/21/%E3%80%8A%E6%91%94%E8%B7%A4%E5%90%A7%EF%BC%8C%E7%88%B8%E7%88%B8%EF%BC%81%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/05/21/《摔跤吧，爸爸！》/</id>
    <published>2017-05-21T08:16:20.000Z</published>
    <updated>2017-05-21T08:18:13.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《摔跤吧，爸爸！》"><a href="#《摔跤吧，爸爸！》" class="headerlink" title="《摔跤吧，爸爸！》"></a>《摔跤吧，爸爸！》</h1><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影本来应该是吕方和歆培一起看的，然而因为种种原因，最后变成了吕方和一脸懵逼的我去看了 233 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实在这之前我一直都很想去看，然而没有找到好的机会。第一次看到这个奇葩的名字的时候我还以为又是一个国产八线骗钱片子，结果后来在各种社交平台发现这是阿米尔汗主演的电影，没错就是《三傻大闹宝莱坞》以此《我滴个神呀》的那个印度国宝演员。他为了演这部电影硬生生地把身材吃到了电影中那个中年发福的爸爸的形象，因为他觉得只有这样才能真实体会主人公的情感，才能演得更到位，之后他又花费了很大的代价以及毅力才恢复到了原来的身材。看到这些之后我就更想去电影院观看了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过之后在知乎上看到了关于这部电影的主题的争议，还知道这部电影在影院上映的是删减版，于是不禁担心起来观看的效果会打折扣，不过这次到电影院看了之后感觉之前的顾虑都是多余的，虽然有删减，但是并不影响观看。倒是晚了几分钟错过了片头有一点遗憾…</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为是周一看的电影，中途因为种种原因一直都没有真正下笔来写，现在终于找到时间来写了。说了这么多废话，下面就正式开始了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个实现爸爸梦想的故事。爸爸以前是一个很厉害的国内摔跤冠军，但是因为种种原因，一直没能在国际大赛获得金牌。于是他把希望寄托在了儿子身上，然而事与愿违，一连四次，生出的都是女儿，他也因此放弃了自己的梦想，但是一次女儿打架完胜男孩的事件中，他看到了两个女儿的摔跤天赋，也看到了自己实现梦想的希望。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是爸爸对两个女儿进行了摔跤的训练，而对于无忧无虑的儿童来说，这训练无疑是魔鬼般的训练，父亲也面临着全村人的质疑和嘲笑。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚开始的时候两个女儿自然是难以接受，甚至想去反抗，但是一次她们参加结婚典礼却被父亲破坏，过后她们在向新娘抱怨的时候新娘的话却让他们的态度发生了三百六十度的转变。众所周知，女性在印度的地位实在是不高，很多女性早早就要嫁入其他的人家里只为了减轻自己家的负担，从此一辈子只能与家务为伍，而她们爸爸的行为虽然专横独裁但是实际上是给他们一条改变自己命运的出路。她们也是懂事的人，知道了这点这之后她们也终于去主动接受训练了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而此时爸爸看到她们的反抗行为之后虽然内心不甘甚至十分愤怒但也无可奈何，如果她们实在不想去训练恐怕爸爸也会放弃他的梦想，这一点从爸爸在只打了他侄子一耳光而没有打他的两个女儿可以看出来。所以其实那个“自私”、“独裁”的爸爸其实并不是那么的不堪，他或许真的是想去改变女儿的命运。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外这个逗比的侄子承担起了全剧的大部分笑点，还是一个背锅侠 233 ，不过塑造的还是很成功的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而女儿在他的训练下也充分地发挥了她们摔跤的天赋，一路上过关斩将轻松杀进了全国赛，大女儿 Geeta 率先夺得全国冠军，进入了印度国家体育学院，离开了爸爸，而此时小女儿 Babita 依旧跟在父亲的身边继续训练。这时候冲突就产生了，因为见识到了更高的世界，于是 Geeta 就认为父亲的一套过时了，并且重新留起了长发，注重起了形象，而父亲的大男子主义(？)或者是作为曾经职业摔跤运动员的骄傲让他感觉十分不高兴。但是女儿用自己的摔跤技巧让父亲无话可说。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当年迈的父亲被女儿摔在地上，他最多的感觉应该就是不甘心了，因为身体的退化，自己的那一套技术的威力不能充分发挥，女儿也开始不听自己的话。和之两个女儿反抗的那次一样，虽然内心不甘心、无奈，但是他知道这时候说什么都没有用了，他能做的就只是默默地在阳台上目送 Geeta 的离去。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而小女儿则是父亲的支持者，她认为父亲的技巧并没有过时，只是父亲的身体大不如前了，而正值风头的 Geeta 才不这样认为，于是父亲和 Geeta 的分歧演变成了 Geeta 和 Babita 的争执。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后 Babita 在父亲的训练下也顺利地拿到了全国冠军进入了同样的学校，但此时 Geeta 多次在国际大赛中失利，甚至快要迷失。还是 Babita 站了出来，让她去向爸爸寻找帮助，尽管 Geeta 感觉不好意思开口，但是“他毕竟是我们的爸爸，爸爸顶多把你骂一顿，他骂的话你就乖乖听着就好”让她终于踏出了那一步。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 Geeta 最终向爸爸打了电话，当爸爸终于等到了 Geeta 的电话，当 Geeta 在电话里放声痛哭，这一瞬间便成了永恒，连局外人的我都差点留下了眼泪。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父女重归于好，接下来的就是父亲和教练的冲突了，不得不说教练的形象真的塑造得有点过于坏了——死要面子、权威性强、嫉妒心强、使用下三滥的手段……不过这样为剧情增加了不少起伏。当教练不相信 Geeta 能参加 55 kg 比赛，父亲站出来力挺女儿，为她制定额外的饮食训练计划；当教练因为额外的训练和饮食想要开除她们，是父亲站了出来承认错误，他知道他这些年对女儿太严格甚至是专横，但是那些都是为了女儿的前途，为了女儿的前途他也愿意低下头认错；当女儿参加国际大赛不知所措，也是父亲站了出来制定战术；当决赛父亲“失踪”、Geeta 接近失败，也是父亲的那些话语带她走出了犹豫，赢得了比赛。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当父亲在地下室听到了印度国歌声，当父亲的梦想终于实现，当父女俩终于见面，当父亲眼中出现满足的眼神，当父亲终于说出女儿是他的骄傲。一切的一切，都变成了过往；一切的一切，也变成了永恒。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然这是一部很棒的电影，但同时也被一些人诟病，我觉得这应该是删减的锅，虽然看的时候没发现，但是回想起来，删减的片段使得前期父亲的形象不是那么的好，不过也不太影响观感。父亲并不是一个冷血专横的父亲，他也爱着他的女儿，只是他并不能那么顺利地表达出来，但他对女儿的爱，对女儿的体贴从那些微小动作中体现得淋漓尽致。很高兴最后父亲实现了他的梦想。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;摔跤的内容也让人看得很爽，同时也觉得紧张不已，尽管过程没那么顺利，但是当最后 Geeta 赢得了冠军，那种爽的感觉真的是一言难尽呀，哈哈。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管小时候很恨父亲的残暴，但是当未来 Geeta 和 Babita 掌控着自己的命运的时候，她们一定会很感谢父亲曾经对她们的严格。父亲也会老，父亲也不总是对的，父亲也不是万能的，但是父亲产生的影响，却是让人受益终身的。</p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;音乐剧情都很不错，主演的演技也很到位，内心独白这些钥匙多一点就更好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《摔跤吧，爸爸！》&quot;&gt;&lt;a href=&quot;#《摔跤吧，爸爸！》&quot; class=&quot;headerlink&quot; title=&quot;《摔跤吧，爸爸！》&quot;&gt;&lt;/a&gt;《摔跤吧，爸爸！》&lt;/h1&gt;&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerli
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="父爱" scheme="https://blog.patrickcty.cc/tags/%E7%88%B6%E7%88%B1/"/>
    
      <category term="印度电影" scheme="https://blog.patrickcty.cc/tags/%E5%8D%B0%E5%BA%A6%E7%94%B5%E5%BD%B1/"/>
    
      <category term="阿米尔汗" scheme="https://blog.patrickcty.cc/tags/%E9%98%BF%E7%B1%B3%E5%B0%94%E6%B1%97/"/>
    
  </entry>
  
  <entry>
    <title>《喜欢你》</title>
    <link href="https://blog.patrickcty.cc/2017/05/05/%E3%80%8A%E5%96%9C%E6%AC%A2%E4%BD%A0%E3%80%8B/"/>
    <id>https://blog.patrickcty.cc/2017/05/05/《喜欢你》/</id>
    <published>2017-05-05T15:29:26.000Z</published>
    <updated>2017-05-06T15:50:46.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《喜欢你》"><a href="#《喜欢你》" class="headerlink" title="《喜欢你》"></a>《喜欢你》</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个人都是一把锁，外向的人是一把活锁，用力就能打开；而有的人是死锁，只有遇到那把能解开的钥匙，才能看到内心所想。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而没有人一开始就是一把死锁，也没有人会愿意一直紧锁，只是那把打开他的锁的钥匙还没出现。而在这部电影中，解开霸道总裁路晋的钥匙就是顾胜男以及她做的菜肴。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必须要吐槽一下开场对路晋的描写，这尼玛哪像一个总裁，没有时间概念，随随便便开人，喜怒无常，就像一个纨绔子弟，富二代…不过还好后面对人物刻画还是不错的，前后的反差还是很有趣的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;路晋是一个跨国经济体的掌管者，在这样的人身上，一般会有一些鲜明又不同寻常的特点。而他的特点就是对饮食挑剔、独自进餐、不近人情。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而顾胜男的出现似乎就是为了打破他的不近人情，从开始的“巧合”到后来的用菜征服，渐渐地打开了这把死锁。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部电影的笑点还是特别密集的时候，很多次我都忍不住笑出声来了，他们是两个性格完全不同的人，这样的反差使得剧情的有趣性更上一层楼。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是你改变了我，让我找到了我作为厨师的价值，你是真正懂我的人。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是你改变了我，让我明白一起吃饭的美好，让我能安稳地睡个好觉，让我能克服我的洁癖。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是啊，我古怪的性格让我不能主动说出爱你，我会嫉妒，我会控制不住自己，我会说出很重的伤害你的话。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是啊，我傲娇的性格让我难以开口说出我喜欢你，我一直极度不近人情让我都不明白我究竟对你是怎样怎样的想法。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我就是爱你呀，但是我只是一个凡人，我只能在家里尽力不去想你，只是我的眼泪为什么一直不停地在流呢？</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我极度理性，我极度冷静，我极度爱好美食，但是为什么小时候的和狗在一起的场景会挥之不去呢？为什么我连七年来最爱的食物都吃不下去了呢？为什么那个吃河豚出现幻觉的夜晚会那么印象深刻呢？</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果他能过来找我就好了。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就算多十个小时，我也要去找她，也要去带她看最美的夕阳。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，在菜市场的调度室门的内外，感情终于浮现在了空气中，尽管路晋难以表达感情，但他还是说出来了。这部分既温馨，又搞笑，总之他们在一起了～即使遇到了钥匙，也需要锁和钥匙靠得足够近，才能解开死锁，而这次，是锁主动靠了过去。</p>
<blockquote>
<p>有没有人 依偎我身旁<br>听我倾诉 余生的漫长<br>在你的眼中 我似乎健忘<br>因为我脑海 已有最难忘 最难遗忘</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有你依偎在我身旁，和我一起度过余生的漫长。就这样就好，一直这样就好，《喜欢你》，喜欢你，五月五日第一次约会，北京路，越秀，广州，广东，珠三角，中国，亚洲，地球，太阳系，银河系，宇宙。May the 4th be with you, and May the 5th be with you, too.</p>
<p><img src="https://okdkbnczs.qnssl.com/image/movies/bwithu.jpg" alt="bwithu"></p>
<h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8/10.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电影整体还是不错的，剧情的“霸道总裁爱上我”这个设定比较尴尬，不过内容却出乎意料地轻松，有趣，整场电影都很开心。不足的话就是配音明显和嘴唇的动作对不上，还有就是男主的助手，女主的闺蜜定位比较鸡肋，“吕子乔”这么逗逼，增加一些笑点就好些了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时这也是一起看的第一部电影～还是在情侣厅看的～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《喜欢你》&quot;&gt;&lt;a href=&quot;#《喜欢你》&quot; class=&quot;headerlink&quot; title=&quot;《喜欢你》&quot;&gt;&lt;/a&gt;《喜欢你》&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;每个人都是一把锁，外
    
    </summary>
    
      <category term="电影" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E7%94%B5%E5%BD%B1/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="爱情" scheme="https://blog.patrickcty.cc/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="霸道总裁爱上我" scheme="https://blog.patrickcty.cc/tags/%E9%9C%B8%E9%81%93%E6%80%BB%E8%A3%81%E7%88%B1%E4%B8%8A%E6%88%91/"/>
    
      <category term="喜剧" scheme="https://blog.patrickcty.cc/tags/%E5%96%9C%E5%89%A7/"/>
    
  </entry>
  
</feed>
