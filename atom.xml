<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Patrick&#39;s Space</title>
  <subtitle>Stay hungry, stay foolish!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.patrickcty.cc/"/>
  <updated>2019-05-03T03:37:26.256Z</updated>
  <id>https://blog.patrickcty.cc/</id>
  
  <author>
    <name>Patrick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习一些概念整理</title>
    <link href="https://blog.patrickcty.cc/2019/05/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"/>
    <id>https://blog.patrickcty.cc/2019/05/03/深度学习一些概念整理/</id>
    <published>2019-05-03T03:26:37.000Z</published>
    <updated>2019-05-03T03:37:26.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Conv1D"><a href="#什么是-Conv1D" class="headerlink" title="什么是 Conv1D"></a>什么是 Conv1D</h2><ul>
<li>Conv2D 的卷积核是一个 n * n 的正方形，多用于处理图像</li>
<li>Conv1D 的卷积核则是一个 1 * n 的长条矩形，多用于处理文本，其实这里的 1 与词向量长度有关</li>
</ul>
<h2 id="全连接层转换为卷积层"><a href="#全连接层转换为卷积层" class="headerlink" title="全连接层转换为卷积层"></a>全连接层转换为卷积层</h2><p>卷积层与全连接层可以相互转换，例如，对于输入为 7 <em> 7 </em> 512 的有 4096 个神经元的全连接层，可以表示为如下的卷积层：</p>
<ul>
<li>Kernel size: 7</li>
<li>Padding: 0</li>
<li>Stride: 1</li>
<li>Filters: 4096</li>
</ul>
<p>这样卷积层输出就是 1 <em> 1 </em> 4096，与全连接层的输出相同。</p>
<h3 id="转换的作用"><a href="#转换的作用" class="headerlink" title="转换的作用"></a>转换的作用</h3><ul>
<li>便于计算更大的图像</li>
</ul>
<p>比如 AlexNet 输入为 227 <em> 227，如果输入为 384 </em> 384 则到了全连接层会报错，而如果进行了如上转换，则会正常输出，不过输出结果为 6 <em> 6 </em> 1000 而非 1 <em> 1 </em> 1000</p>
<h2 id="CNN-的通道"><a href="#CNN-的通道" class="headerlink" title="CNN 的通道"></a>CNN 的通道</h2><p>一般是指每个卷积层中卷积核的数量。</p>
<p>对于一个 7 <em> 7 </em> 512 的张量进行卷积操作，假设卷积核的大小为 3 * 3。此时卷积核其实还有一个隐藏的参数就是 in_channels = 512。</p>
<p>一次卷积就是 7 <em> 7 </em> 512 个数字对应位相乘然后加起来的结果，这个操作会把所有通道的信息都统一到一起。当然，由于 out_channels 的存在，也就是 filter 的数量，因此会有多个卷积核把所有通道的信息用不同的方式统一起来，形成了一个新的张量，比如可能是 7 <em> 7 </em> 1024。</p>
<p>详细内容可以参考<a href="https://blog.csdn.net/sscc_learning/article/details/79814146" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="CNN-的卷积核"><a href="#CNN-的卷积核" class="headerlink" title="CNN 的卷积核"></a>CNN 的卷积核</h2><p>CNN 的卷积核就是这一层的特征。多个卷积核就是为了匹配多个不同的特征。</p>
<p>卷积生成的 feature map 就是特征匹配的结果，越接近 1 说明这个位置特征越匹配，越接近 -1 说明这个位置这个位置越匹配相反的特征。</p>
<p>多层的卷积神经网络每一层都是提取到更细小的特征，这些特征可以作为基底来表示这个图像。</p>
<h2 id="CNN-池化"><a href="#CNN-池化" class="headerlink" title="CNN 池化"></a>CNN 池化</h2><p>池化用来保留最显著的特征（Max Pooling）。这样一方面保留了图像必要的部分，又把图像的维度降低了，这样之后层次层处理的量就会小很多。</p>
<h2 id="1-1-卷积核作用"><a href="#1-1-卷积核作用" class="headerlink" title="1 * 1 卷积核作用"></a>1 * 1 卷积核作用</h2><ul>
<li>实现数据维度改变</li>
</ul>
<p>可以把维度从 m <em> n </em> 10 改变到 m <em> n </em> 5 或者 m <em> n </em> 50，只需要改变 filter 的数量</p>
<ul>
<li>实现跨通道的交互信息的整合</li>
</ul>
<p>由于次个卷积会把多个通道的信息汇总，因此这个 1 * 1 卷积的过程也会把跨通道的交互信息整合起来</p>
<ul>
<li>增加非线性</li>
</ul>
<p>通过卷积之后的非线性激活函数来实现</p>
<p>具体讲解参考<a href="https://zhuanlan.zhihu.com/p/40050371" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="Global-Average-Pooling-GAP-作用"><a href="#Global-Average-Pooling-GAP-作用" class="headerlink" title="Global Average Pooling (GAP) 作用"></a>Global Average Pooling (GAP) 作用</h2><p>GAP 是用来将每个通道的信息统一到同一个像素上，比如输入为 7 <em> 7 </em> 512 的张量，经过 GAP 之后输出就是 1 <em> 1 </em> 512。</p>
<ul>
<li>代替全连接层</li>
</ul>
<p>CNN 最后一层卷积的输出就是一个高度提取的 feature map（本质上是特征），而全连接层就是将最后一层卷积得到的特征整合起来映射到样本空间（分类，识别等）（由于有非线性激活函数，因此不是线性映射）。</p>
<p>具体理解参照<a href="https://www.zhihu.com/question/41037974/answer/320267531" target="_blank" rel="external">这个回答</a>。</p>
<p>关于 GAP 的效果对比可以参考<a href="https://www.cnblogs.com/hutao722/p/10008581.html" target="_blank" rel="external">这篇博客</a>。</p>
<p>我自己在小型的神经网络上训练的结果（GAP 代替了 128 FC）是使用 GAP 提高了 2% 左右的准确度。</p>
<h2 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h2><p>深度学习更新参数通常不是由一个数据来决定的，不然更新的方向可能会差别较大（一下这边一下那边）。</p>
<p>一批里面有多个数据更容易朝着正确的方向进行，利用各个数据之间的一些共性。</p>
<p>另外，使用批处理也避免了一次使用所有数据进行训练，减小了显存的压力，也更有可能找到极小值。</p>
<h2 id="epoch"><a href="#epoch" class="headerlink" title="epoch"></a>epoch</h2><p>一个完整的数据集经过网络一次并返回一次的结果。一个 epoch 并不一定能让网络达到最佳的方向，因而要训练多个 epoch，但是训练过多会过拟合。</p>
<h2 id="Batch-Normalization-作用"><a href="#Batch-Normalization-作用" class="headerlink" title="Batch Normalization 作用"></a>Batch Normalization 作用</h2><p>将一个 batch 中的各个元素归一化（各个通道分别进行 BN），通常放到激活函数之前。</p>
<p>好处：</p>
<ul>
<li>减小梯度弥散（梯度消失/爆炸）</li>
</ul>
<p>改变激活函数的输入，让数据分布更均匀，从而杀掉的神经元更少。</p>
<ul>
<li>训练更快，可以用更高的学习率</li>
</ul>
<p>数据分布更均匀，神经网络不用去适应各种分布</p>
<ul>
<li>一定程度增加泛化能力，避免过拟合</li>
</ul>
<p>数据通过 BN 处理引入的随机噪声能够起到对模型参数进行正则化的作用，有利于增强模型泛化能力</p>
<p>缺陷：</p>
<ul>
<li>不适用 batch 非常小</li>
<li>不适用 RNN</li>
</ul>
<p>关于 BN 的理解，尤其是背后的原理理解参考<a href="https://www.jiqizhixin.com/articles/2018-08-29-7" target="_blank" rel="external">这篇文章</a></p>
<h2 id="验证-测试集的作用"><a href="#验证-测试集的作用" class="headerlink" title="验证/测试集的作用"></a>验证/测试集的作用</h2><h3 id="验证集"><a href="#验证集" class="headerlink" title="验证集"></a>验证集</h3><ul>
<li>与测试集同分布，用来观察训练的走向（是否过拟合等）</li>
<li>选择超参数</li>
</ul>
<h3 id="测试集"><a href="#测试集" class="headerlink" title="测试集"></a>测试集</h3><p>评估模型的训练状况，检验泛化能力</p>
<h2 id="Softmax-是什么"><a href="#Softmax-是什么" class="headerlink" title="Softmax 是什么"></a>Softmax 是什么</h2><p>Softmax 函数用来产生 k 个概率，而 Softmax 损失函数，准确来说是用 Softmax 的结果来计算交叉熵分类损失函数。</p>
<p>Softmax 函数可以参考<a href="https://blog.csdn.net/ture_dream/article/details/54948518" target="_blank" rel="external">这篇博文</a>，交叉熵可以参考<a href="https://zhuanlan.zhihu.com/p/35709485" target="_blank" rel="external">这篇博文</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Conv1D&quot;&gt;&lt;a href=&quot;#什么是-Conv1D&quot; class=&quot;headerlink&quot; title=&quot;什么是 Conv1D&quot;&gt;&lt;/a&gt;什么是 Conv1D&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Conv2D 的卷积核是一个 n * n 的正方形，多用于处理图
    
    </summary>
    
      <category term="深度学习" scheme="https://blog.patrickcty.cc/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Batch Normalization" scheme="https://blog.patrickcty.cc/tags/Batch-Normalization/"/>
    
      <category term="Global Average Pooling" scheme="https://blog.patrickcty.cc/tags/Global-Average-Pooling/"/>
    
      <category term="Deep Learning" scheme="https://blog.patrickcty.cc/tags/Deep-Learning/"/>
    
      <category term="CNN" scheme="https://blog.patrickcty.cc/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>cifar100实验</title>
    <link href="https://blog.patrickcty.cc/2019/05/03/cifar100%E5%AE%9E%E9%AA%8C/"/>
    <id>https://blog.patrickcty.cc/2019/05/03/cifar100实验/</id>
    <published>2019-05-03T02:44:20.000Z</published>
    <updated>2019-05-03T02:45:03.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验一：初步探究-BN-作用"><a href="#实验一：初步探究-BN-作用" class="headerlink" title="实验一：初步探究 BN 作用"></a>实验一：初步探究 BN 作用</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16 + BN + GAP</li>
<li>B：使用 VGG16 + GAP</li>
<li>数据集 cifar100</li>
<li>Adam，30 epoch</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>A：train acc：90%+，test acc：50%，发生严重的过拟合</li>
<li>B：train acc：1%，发生严重的欠拟合</li>
</ul>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>BN 在防止梯度弥散这方面起了重要的作用，让深层的神经网络在面对很小的数据的时候也能够拟合。</p>
<h2 id="实验二：探究-GAP-作用"><a href="#实验二：探究-GAP-作用" class="headerlink" title="实验二：探究 GAP 作用"></a>实验二：探究 GAP 作用</h2><h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16 + 256 fc * 2 + BN</li>
<li>B：使用 VGG16 + 256 fc * 2</li>
<li>数据集 cifar100</li>
<li>Adam，30 epoch</li>
</ul>
<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><p>A，B train acc 均为 1%，发生严重的欠拟合</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>怀疑是因为：</p>
<ul>
<li>数据维度过小，后面的卷积层很难提取特征（1 <em> 1， 2 </em> 2 这样的大小）</li>
<li>全连接层神经元太少（只有 256 * 2）</li>
<li>GAP 把过于分散的特征“结合”了起来，因此实验一在 BN 的帮助下还是可以拟合的</li>
</ul>
<h2 id="实验三：实验二欠拟合探究之一"><a href="#实验三：实验二欠拟合探究之一" class="headerlink" title="实验三：实验二欠拟合探究之一"></a>实验三：实验二欠拟合探究之一</h2><h3 id="基本配置-2"><a href="#基本配置-2" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16 + 4096 fc * 2 + BN</li>
<li>B：使用 VGG16 + 256 fc <em> 2 + 图像缩放到 80 </em> 80 </li>
<li>数据集 cifar100</li>
<li>Adam，30 epoch</li>
</ul>
<h3 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>A：train acc：69%，test acc：43%，略有过拟合</li>
<li>B：train acc：1%，欠拟合严重</li>
</ul>
<h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>增加了 fc 神经元个数之后就开始拟合了，效果好了一些，因此上一个推测二是对的；增加了图像的大大小之后还是不能拟合，因而单纯缩放是无法解决问题的（症结还是在网络骨架的结构上）。</p>
<h2 id="实验四：实验二欠拟合探究之二"><a href="#实验四：实验二欠拟合探究之二" class="headerlink" title="实验四：实验二欠拟合探究之二"></a>实验四：实验二欠拟合探究之二</h2><h3 id="基本配置-3"><a href="#基本配置-3" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16 + BN + 4096 fc * 2（去掉 vgg block 5）</li>
<li>B：使用 VGG16 + 4096 fc <em> 2 + 图像缩放到 80 </em> 80 </li>
<li>数据集 cifar100</li>
<li>Adam，30 epoch</li>
</ul>
<h3 id="实验结果-3"><a href="#实验结果-3" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>A：train acc：75%，test acc：48%，有过拟合</li>
<li>B：train acc：1%，欠拟合严重</li>
</ul>
<h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><p>进一步表明图像缩不是症结所在果，图像本身太小了，持续的池化让 shape 过小，再使用卷积反而起反作用，因而效果差了。</p>
<h2 id="实验五：深入研究-BN-作用"><a href="#实验五：深入研究-BN-作用" class="headerlink" title="实验五：深入研究 BN 作用"></a>实验五：深入研究 BN 作用</h2><h3 id="基本配置-4"><a href="#基本配置-4" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16 + GAP + BN（去掉 vgg block 5）</li>
<li>B：使用 VGG16 + GAP（去掉 vgg block 5）</li>
<li>C：使用 VGG16 + GAP + BN（去掉 vgg block 4、5）</li>
<li>D：使用 VGG16 + GAP（去掉 vgg block 4、5）</li>
<li>数据集 cifar100</li>
<li>Adam，30 epoch</li>
</ul>
<h3 id="实验结果-4"><a href="#实验结果-4" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>A：train acc：98%，test acc：53%，发生严重过拟合</li>
<li>B：train acc：&lt;1%，欠拟合严重</li>
<li>C：train acc：98%，test acc：59%，发生严重过拟合</li>
<li>D：train acc：87%，test acc：34%，过拟合严重且结果也一般</li>
</ul>
<h3 id="结果分析-3"><a href="#结果分析-3" class="headerlink" title="结果分析"></a>结果分析</h3><p>BN 确实厉害，可以有效防止过拟合，梯度弥散。</p>
<ul>
<li>同样是过拟合没加 BN 过拟合程度比加了要严重不少。</li>
<li>同样是多了一个 block，没有 BN 就直接梯度消失没办法拟合，有了 BN 尽管会过拟合但是可以非常顺利训练下来。</li>
</ul>
<p>而且加了 BN 之后训练的训读会快一些（A：47s-&gt;B：65s，C：24s-&gt;D：39s）</p>
<h2 id="实验六：过拟合探究"><a href="#实验六：过拟合探究" class="headerlink" title="实验六：过拟合探究"></a>实验六：过拟合探究</h2><h3 id="基本配置-5"><a href="#基本配置-5" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>A：使用 VGG16（去掉 vgg block 4、5） + GAP + BN + l2_normalization（所有卷积层都加 l2）+ 60 epoch</li>
<li>B：使用 VGG16（去掉 vgg block 4、5） + GAP + BN + l2_normalization（l2 只加到最后一个卷积上）+ 30 epoch</li>
<li>C：使用 VGG16（去掉 vgg block 4、5） + GAP + BN + l2_normalization（l2 只加到最后三个卷积上）+ 30 epoch</li>
<li>数据集 cifar100</li>
<li>Adam</li>
</ul>
<h3 id="实验结果-5"><a href="#实验结果-5" class="headerlink" title="实验结果"></a>实验结果</h3><ul>
<li>A：train acc：51.8%，test acc：38%，虽然过拟合没那么严重，但是效果比较差</li>
<li>B：train acc：93%，test acc：46%，惩罚作用太弱，过拟合严重</li>
<li>C：<ul>
<li>30 epoch：train acc：71%，test acc：43%，惩罚作用较强，过拟合依旧严重</li>
<li>60 epoch：train acc：84%，test acc：39%，惩罚作用较强，过拟合依旧严重</li>
</ul>
</li>
</ul>
<h3 id="结果分析-4"><a href="#结果分析-4" class="headerlink" title="结果分析"></a>结果分析</h3><p>l2_normalization 如果在全局应用会使惩罚作用太强，性能严重降低；只在最后一层加惩罚效果又太弱；在最后三层加则不仅性能差而且过拟合依旧严重。</p>
<p>这几次实验都是训练到最后，没有加入验证集，从而没有在过拟合之前停止下来查看效果。</p>
<p>不过实验证明了加 l2 正则并不是一个非常有效的方法。或者是 l2 正则不应该这样用。</p>
<h2 id="实验七：图片预处理"><a href="#实验七：图片预处理" class="headerlink" title="实验七：图片预处理"></a>实验七：图片预处理</h2><h3 id="基本配置-6"><a href="#基本配置-6" class="headerlink" title="基本配置"></a>基本配置</h3><ul>
<li>使用 VGG16 + GAP + BN + 预处理（去掉 vgg block 4、5）</li>
<li>数据集 cifar100</li>
<li>Adam，40 epoch</li>
</ul>
<h3 id="实验结果-6"><a href="#实验结果-6" class="headerlink" title="实验结果"></a>实验结果</h3><p>train acc：98%，test acc：65%，过拟合略有缓解</p>
<h3 id="结果分析-5"><a href="#结果分析-5" class="headerlink" title="结果分析"></a>结果分析</h3><p>给图片做预处理果然有用，缓解过拟合效果不错。不过需要注意，训练图片和测试图片格式必须一样！！！（比如如果要除以 255 就都要除），不然就是百分之百测试效果很差了 233。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><ul>
<li>对于小的输入不要使用太复杂的神经网络，不然梯度消失反而会起到反作用</li>
<li>设计网络时将最后一层卷积输出控制在 4 <em> 4 </em> 512 比较好</li>
<li>使用 BN 可以有效加快训练速度，缓解梯度弥散</li>
<li>使用 GAP 代替全连接层，减小训练量，降低过拟合</li>
<li>使用图片预处理减轻过拟合</li>
<li>l2 normalization 慎用</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验一：初步探究-BN-作用&quot;&gt;&lt;a href=&quot;#实验一：初步探究-BN-作用&quot; class=&quot;headerlink&quot; title=&quot;实验一：初步探究 BN 作用&quot;&gt;&lt;/a&gt;实验一：初步探究 BN 作用&lt;/h2&gt;&lt;h3 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基
    
    </summary>
    
      <category term="深度学习" scheme="https://blog.patrickcty.cc/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://blog.patrickcty.cc/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Batch Normalization" scheme="https://blog.patrickcty.cc/tags/Batch-Normalization/"/>
    
      <category term="Global Average Pooling" scheme="https://blog.patrickcty.cc/tags/Global-Average-Pooling/"/>
    
  </entry>
  
  <entry>
    <title>图像检索一些指标</title>
    <link href="https://blog.patrickcty.cc/2019/04/26/%E5%9B%BE%E5%83%8F%E6%A3%80%E7%B4%A2%E4%B8%80%E4%BA%9B%E6%8C%87%E6%A0%87/"/>
    <id>https://blog.patrickcty.cc/2019/04/26/图像检索一些指标/</id>
    <published>2019-04-26T02:27:44.000Z</published>
    <updated>2019-05-03T03:30:23.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Precision-查准率"><a href="#Precision-查准率" class="headerlink" title="Precision 查准率"></a>Precision 查准率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Precision = \frac&#123;TP&#125;&#123;TP + TN&#125;</div></pre></td></tr></table></figure>
<p>即检索到的这些结果中正确结果的比例。</p>
<h2 id="Recall-查全率"><a href="#Recall-查全率" class="headerlink" title="Recall 查全率"></a>Recall 查全率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Recall = \frac&#123;TP&#125;&#123;TP + FN&#125;</div></pre></td></tr></table></figure>
<p>即检索到的正确结果占所有正确结果的比例。</p>
<h2 id="F-measure"><a href="#F-measure" class="headerlink" title="F-measure"></a>F-measure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Recall = 2 \cdot \frac&#123;Precision \cdot Recall&#125;&#123;Precision + Recall&#125;</div></pre></td></tr></table></figure>
<p>综合描述 Precision 和 Recall。</p>
<h2 id="PR-曲线"><a href="#PR-曲线" class="headerlink" title="PR 曲线"></a>PR 曲线</h2><p>描述 Precision 和 Recall 变化关系的曲线，一般来说 Precision 越高 Recall 就比较低，反之亦然。</p>
<p>用来进行二者之间的取舍，一般检索类的要保证 Recall 提高 Precision，反垃圾等则要保证 Precision 提高 Recall。</p>
<h2 id="AP-和-mAP"><a href="#AP-和-mAP" class="headerlink" title="AP 和 mAP"></a>AP 和 mAP</h2><p>分别为：图像检索精度（average precision，AP）与平均检索精度（mean average precision，mAP）。</p>
<p>这两个指标是为了解决 P，R，F-measure 的单点值局限性，考虑了检索效果的排名情况。</p>
<p>计算方法参考[1]。</p>
<h2 id="top-k"><a href="#top-k" class="headerlink" title="top@k"></a>top@k</h2><p>指检索返回的结果为 k 个，一般作为评价 P，R，mAP 等指标的阈值。</p>
<h2 id="信息检索评价指标"><a href="#信息检索评价指标" class="headerlink" title="信息检索评价指标"></a>信息检索评价指标</h2><p>一般是 Precision，Recall，mAP</p>
<h2 id="ROC-曲线和-AUC"><a href="#ROC-曲线和-AUC" class="headerlink" title="ROC 曲线和 AUC"></a>ROC 曲线和 AUC</h2><p>这个是用来评价二分类器所用指标，ROC 纵轴为 TPR（True Positive Rate），横轴为 FPR（False Positive Rate，公式分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TPR = \frac&#123;TP&#125;&#123;TP + FN&#125;</div><div class="line"></div><div class="line">FPR = \frac&#123;fP&#125;&#123;FP + TN&#125;</div></pre></td></tr></table></figure>
<p>AUC（Area Under Curve）即 ROC 曲线与坐标轴围成的面积，一般不小于 0.5，越大表示分类效果越好。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://yongyuan.name/blog/evaluation-of-information-retrieval.html" target="_blank" rel="external">http://yongyuan.name/blog/evaluation-of-information-retrieval.html</a><br>[2] <a href="https://blog.csdn.net/marising/article/details/6543943" target="_blank" rel="external">https://blog.csdn.net/marising/article/details/6543943</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/34079183" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/34079183</a><br>[4] <a href="https://blog.csdn.net/Lu597203933/article/details/41802155" target="_blank" rel="external">https://blog.csdn.net/Lu597203933/article/details/41802155</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Precision-查准率&quot;&gt;&lt;a href=&quot;#Precision-查准率&quot; class=&quot;headerlink&quot; title=&quot;Precision 查准率&quot;&gt;&lt;/a&gt;Precision 查准率&lt;/h2&gt;&lt;figure class=&quot;highlight plai
    
    </summary>
    
      <category term="深度学习" scheme="https://blog.patrickcty.cc/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="https://blog.patrickcty.cc/tags/Deep-Learning/"/>
    
      <category term="Information Retrieval" scheme="https://blog.patrickcty.cc/tags/Information-Retrieval/"/>
    
  </entry>
  
  <entry>
    <title>关于毕业设计的一些事</title>
    <link href="https://blog.patrickcty.cc/2019/04/16/%E5%85%B3%E4%BA%8E%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>https://blog.patrickcty.cc/2019/04/16/关于毕业设计的一些事/</id>
    <published>2019-04-16T15:55:49.000Z</published>
    <updated>2019-05-03T03:29:37.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漫画人脸二分类"><a href="#漫画人脸二分类" class="headerlink" title="漫画人脸二分类"></a>漫画人脸二分类</h2><p>一开始我一直想用 VGG 来实现漫画人脸的二分类，即判断是不是人脸。但是效果一直很差，acc 和随便猜的一模一样（50%）。</p>
<p>这时候我一直以为是数据有问题，不过在洗过好多次之后我发现并非如此，出问题的不是数据，而是数据和网络不匹配。</p>
<p>换句话来说就是漫画人脸中包含的要素太少，使用 VGG 这种深层网络会让特征到最后“消失殆尽”，所以最后效果就很差了。</p>
<p>为了验证这个猜想，我使用 VGG 训练 MNIST，结果不出意料的也是随便猜的概率（10%）。</p>
<p>++当然上面的也只是猜想，因为我对 CNN 理解还是太浅，这个基础问题还得在之后再恶补一下了。++</p>
<p>心里有这个概念之后我就尝试用浅一点的网络来解决问题了，尝试着用 AlexNet 和另一个浅一点的 CNN 来训练模型，虽然最后在二分类问题上能达到 80% 左右 的准确率，但是还有一个大问题又被我忽视掉了。</p>
<p>在尝试这两个网络中，我又在其中加入了 bn 层，不过加入之后浅层的 CNN acc 又变成了 50%……</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>MNIST 这个 acc 这么低，原因不是我想的那样，而是我在处理输入的时候直接无脑 resize，破坏了原来图片的语义……使用正常的处理方法就能得到正确的结果了，并不是 VGG 的锅……</p>
<p>那么问题来了，我的漫画网络究竟是哪里出问题了呢……</p>
<h2 id="提取特征"><a href="#提取特征" class="headerlink" title="提取特征"></a>提取特征</h2><p>Acc 80%，这是一个不算特别好又不算坏的结果。但是试了很多种方法一时间没能找到更高的准确度，于是就准备拿这个模型来提取特征了。</p>
<p>不过在这个过程中，我有又发现了一个大问题：提取出来的特征太稀疏了，256 维的特征中，只有不到十个元素不为零……而 flatten 层也仅有 1/8 左右的不为零。虽然我内心没有逼数，但这的确是一个不正常的现象。</p>
<p>==后面我准备训练 MNIST 来观察一下各层的正常输出应该是怎么样的。==</p>
<h3 id="检索系统中遇到的坑"><a href="#检索系统中遇到的坑" class="headerlink" title="检索系统中遇到的坑"></a>检索系统中遇到的坑</h3><ul>
<li><code>ValueError: Tensor Tensor(&quot;Sigmoid_2:0&quot;, shape=(?, 17), dtype=float32) is not an element of this graph.</code></li>
</ul>
<p>出现这个问题的原因就是多线程、分布式环境下，恢复 Model 时的 Tensor Graph 和生成 Model 时不同。</p>
<p>具体来说就是模型是在全局变量里面恢复的，但是调用是在 Flask 的多线程调用的。</p>
<p>解决方法就是在恢复 Model 的时候保存相应的 Graph，然后再在 predict 的时候恢复这个 Graph 即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># when load model</div><div class="line">graph = tf.get_default_graph()</div><div class="line"></div><div class="line"># when use model in another thread</div><div class="line">global graph</div><div class="line">with graph.as_default():</div><div class="line">    (... do inference here ...)</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/keras-team/keras/issues/2397" target="_blank" rel="external">https://github.com/keras-team/keras/issues/2397</a></li>
<li><p><a href="https://justttry.github.io/justttry.github.io/not-an-element-of-Tensor-graph/" target="_blank" rel="external">https://justttry.github.io/justttry.github.io/not-an-element-of-Tensor-graph/</a></p>
</li>
<li><p><code>FailedPreconditionError: tensorflow not found container localhost does not exist</code></p>
</li>
</ul>
<p>这个问题比较玄学，好像各种问题都可能报这个错误。我出现这个问题的原因可能是 tf 的版本和 keras 的版本有些冲突，使用系统的 Python 不行，但是换成 Anaconda 的 Python 就没问题了。</p>
<p>不过需要注意的是，tf.keras 和 keras 并不是一个东西，如果两个混用的话是会出现各种错误的，如果用到了某一个就一条路走到黑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;漫画人脸二分类&quot;&gt;&lt;a href=&quot;#漫画人脸二分类&quot; class=&quot;headerlink&quot; title=&quot;漫画人脸二分类&quot;&gt;&lt;/a&gt;漫画人脸二分类&lt;/h2&gt;&lt;p&gt;一开始我一直想用 VGG 来实现漫画人脸的二分类，即判断是不是人脸。但是效果一直很差，acc 和随便
    
    </summary>
    
      <category term="Python" scheme="https://blog.patrickcty.cc/categories/Python/"/>
    
      <category term="深度学习" scheme="https://blog.patrickcty.cc/categories/Python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="https://blog.patrickcty.cc/tags/Deep-Learning/"/>
    
      <category term="TensorFlow" scheme="https://blog.patrickcty.cc/tags/TensorFlow/"/>
    
      <category term="Keras" scheme="https://blog.patrickcty.cc/tags/Keras/"/>
    
  </entry>
  
  <entry>
    <title>安装 OpenCV C++ 库以及运行相应程序</title>
    <link href="https://blog.patrickcty.cc/2019/04/07/%E5%AE%89%E8%A3%85OpenCV/"/>
    <id>https://blog.patrickcty.cc/2019/04/07/安装OpenCV/</id>
    <published>2019-04-07T07:40:53.000Z</published>
    <updated>2019-05-03T03:31:38.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扯两句废话"><a href="#扯两句废话" class="headerlink" title="扯两句废话"></a>扯两句废话</h2><p>之前用惯了 Python，以为使用 C++ 的模块也是直接一行命令安装然后再直接编译就可以了，没想到并没有这么简单，还是需要其他的一些步骤。</p>
<p>于是这两天在不会 C++ 上吃了大亏 orz。</p>
<h2 id="Ubuntu-安装-OpenCV"><a href="#Ubuntu-安装-OpenCV" class="headerlink" title="Ubuntu 安装 OpenCV"></a>Ubuntu 安装 OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libopencv-dev</div></pre></td></tr></table></figure>
<p>没错，一行命令完事。</p>
<p>一开始我是老老实实下载、编译的（因为搜安装教程完全没看到用 apt 安装的，于是我以为只能编译来安装了 orz），结果配了半天环境变量还是找不到 OpenCV 的包，最后这行命令下去直接就一切 ok 了。</p>
<p>检查 OpenCV 是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg-config --cflags --libs opencv</div></pre></td></tr></table></figure>
<p>如果输出的那一大堆不是报错的那就说明安装成功了。</p>
<h2 id="Mac-安装-OpenCV"><a href="#Mac-安装-OpenCV" class="headerlink" title="Mac 安装 OpenCV"></a>Mac 安装 OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install opencv</div></pre></td></tr></table></figure>
<p>这样安装了还是要配置环境变量</p>
<h3 id="配置-pkg-config-环境变量"><a href="#配置-pkg-config-环境变量" class="headerlink" title="配置 pkg-config 环境变量"></a>配置 pkg-config 环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/</div></pre></td></tr></table></figure>
<h3 id="把-OpenCV-pc-文件链接到-PKG-CONFIG-PATH"><a href="#把-OpenCV-pc-文件链接到-PKG-CONFIG-PATH" class="headerlink" title="把 OpenCV .pc 文件链接到 PKG_CONFIG_PATH"></a>把 OpenCV .pc 文件链接到 PKG_CONFIG_PATH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/opt/opencv3/lib/pkgconfig/opencv.pc $PKG_CONFIG_PATH</div></pre></td></tr></table></figure>
<p>这一步具体的路径就要看 opencv.pc 文件在哪里了，我的 Mac 上的是 opencv4.pc 文件</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>环境变量配置好了之后应该就可以了，之后还是运行上面的命令来检查是否安装成功。详细的安装过程可以看<a href="https://gist.github.com/nkcr/6f5c6db4dccd3b32e8ba" target="_blank" rel="external">这个教程</a>。</p>
<h2 id="运行相应程序"><a href="#运行相应程序" class="headerlink" title="运行相应程序"></a>运行相应程序</h2><p>如果源程序中引用了相应的模块那么编译的时候就要加入一些其他的内容了，比如如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++11 main.cpp mangaLineSeparator.cpp -o main $(pkg-config --cflags --libs opencv4)</div></pre></td></tr></table></figure>
<p>然后就生成了可执行程序 <code>main</code> 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ 的模块的使用和 Python 还是有一些不同的，在处理问题的时候不要根据惯性思维来思考，不然就会在一些你意想不到的地方纠结……比如明明是编译的命令写错了，我却一直以为是模块没有正常安装……</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扯两句废话&quot;&gt;&lt;a href=&quot;#扯两句废话&quot; class=&quot;headerlink&quot; title=&quot;扯两句废话&quot;&gt;&lt;/a&gt;扯两句废话&lt;/h2&gt;&lt;p&gt;之前用惯了 Python，以为使用 C++ 的模块也是直接一行命令安装然后再直接编译就可以了，没想到并没有这么简单，
    
    </summary>
    
      <category term="C++" scheme="https://blog.patrickcty.cc/categories/C/"/>
    
    
      <category term="C++" scheme="https://blog.patrickcty.cc/tags/C/"/>
    
      <category term="OpenCV" scheme="https://blog.patrickcty.cc/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>3.28随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/28/3-28%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/28/3-28随想/</id>
    <published>2019-03-28T06:10:34.000Z</published>
    <updated>2019-03-28T06:47:17.292Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写随想了，不知不觉这本王小波散文集也快读完了。</p>
<p>今天读到的《盖茨的紧身衣》让我有了一些想法。现在经常有一些新事物号称要颠覆、取代已有的一些事物。也有一些新事物被人们鼓吹会完全取代旧事物。</p>
<p>虽然真正能颠覆和取代的确实存在，但大多数新事物只是让市面上多了一个 fancy 的选择，分流了一些摇摆的受众，原本的事物并没有收到那么大的冲击。就比如前几年很多人鼓吹电子书将取代书籍，电子货币将取代现金。但是现在呢？实体书依旧有市场，现金仍然被广泛的使用。不过还有下半句那就是实体书的市场已经大大萎缩了，现金的使用也大大减少了。但其实这种缩小并不是一件坏事，作家的书籍在互联网上得到了更大的曝光，更容易被其他人阅读到；货币的流通不但没有减少反而跟着网购一起腾飞。</p>
<p>不过说起要，要想不被淘汰，最重要的一点就是有实力。群众的眼睛是雪亮的，好的内容在竞争中往往不会落入下风。另外一点就是不要盲目跟风，虽然跟风的话运气好可以一夜暴富，但是通常情况下就会落得一个不三不四的结果。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写随想了，不知不觉这本王小波散文集也快读完了。&lt;/p&gt;
&lt;p&gt;今天读到的《盖茨的紧身衣》让我有了一些想法。现在经常有一些新事物号称要颠覆、取代已有的一些事物。也有一些新事物被人们鼓吹会完全取代旧事物。&lt;/p&gt;
&lt;p&gt;虽然真正能颠覆和取代的确实存在，但大多数新事物只是让
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>3.19随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/19/3-19%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/19/3-19随想/</id>
    <published>2019-03-19T01:41:10.000Z</published>
    <updated>2019-03-19T02:01:53.558Z</updated>
    
    <content type="html"><![CDATA[<p>在看《我的精神家园》的时候我就一直在想我在大学之前的事。</p>
<p>王小波的精神家园来自于从小读过的书籍，而对于那些从小并没有养成主动读书习惯的人，精神家园则是大为不同了。在现在看来，我认为背诵语文书上的一些课文，尤其是诗歌与古文是非常有必要的，尽管在大学之前我都是那种看到“背诵”二字都会万分头疼的人（现在好像也非常讨厌背书）。</p>
<p>在批判过去教育的死板与迂腐之前，我不得不说，那种强行要你背的方法虽不是一个最佳的方法，但它的成效确实还不错。何出此言？不说是在小学和初中，就算是在高中很多人对生活的认识都是非常浅薄的，欣赏力也比较有限。即是说，他们无法发现其中的美与内涵。就以《游褒禅山记》为例，在学习这篇文章的时候我并没有感觉到任何吸引到我的地方，但在现在再回想里来，其中蕴含的道理，在生活之中还是非常受用的。我们到底是那些迎难而上的人还是看到险峰就回走的人？即使是最讨厌古文的我，在学习《滕王阁序》的时候，也彻底被王勃的喷涌而出的才华给折服了，这样一篇才华横溢的文章，课后没有要求背诵全文，我也基本把全文熟悉到可以背诵的地步。</p>
<p>虽然当时所学习的那些课文并没有建立起我的精神家园，但它们却在潜移默化之中改变了我的想法，同时这种帮助在我成熟的过程中越发清晰。</p>
<p>这些背诵全文，或者往广了说是语文的学习，都是为了构建我们的精神家园。只不过人们往往对强制的东西非常反感，所以在当时很多人都非常抵触，但还是有一些人从这样的过程中获得了乐趣，为他们的精神家园奠定了坚实的基础。现在的教育方式和我那时候相比已经有了长足的进步，老师都是以一种引导的方式来让学生自主进行自己精神家园的构建，这样的方法在效率和效果上都要比被动灌输要来的好不少。如今网络上键盘侠横行，一个重要的原因就是他们精神家园没有建立起来，自己独立思考的能力严重欠缺，非常缺乏教养。或许到了下一代之后这样的情形能有所好转吧，那时候大家都有了自己的精神家园。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看《我的精神家园》的时候我就一直在想我在大学之前的事。&lt;/p&gt;
&lt;p&gt;王小波的精神家园来自于从小读过的书籍，而对于那些从小并没有养成主动读书习惯的人，精神家园则是大为不同了。在现在看来，我认为背诵语文书上的一些课文，尤其是诗歌与古文是非常有必要的，尽管在大学之前我都是那种
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>写在考研尘埃落定之后</title>
    <link href="https://blog.patrickcty.cc/2019/03/18/%E5%86%99%E5%9C%A8%E8%80%83%E7%A0%94%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A%E4%B9%8B%E5%90%8E/"/>
    <id>https://blog.patrickcty.cc/2019/03/18/写在考研尘埃落定之后/</id>
    <published>2019-03-18T14:04:43.000Z</published>
    <updated>2019-03-18T14:29:20.785Z</updated>
    
    <content type="html"><![CDATA[<p>3.18 晚上七点二十，考研的总排名终于公布在软件学院的官网上了，我也在拟录取的名单之中。这也意味着我的考研生活终于真正意义上的尘埃落定了。</p>
<p>这个时候按理说应该是吹一波我考研是怎么认真复习，怎么磨练意志这种内容。然而事实并不是这样，虽然不想承认，但这次考研，特别是初试是有很大的运气成分存在的。即使是在最紧张的二轮复习的时候，我复习的效率还是非常低的；准备复试的效率低得就更加令人难以启齿了。关于考研，我想说的不是这些，而更多是一种感想。</p>
<p>在写《最短的捷径就是绕远路》这一篇博文的时候，我就想说我的考研相关内容，但当时还没有出结果，不好提前立 flag，现在终于可以来说一说了。就和乔尼认为的那样，我也饶了一大圈的远路，真的真的绕了好大一圈的远路，从武汉到广州，再从广州回到武汉。即使绕了这么大一圈的远路，但我好歹还是回到了起点，没有倒在半路，这也是一种幸运吧。但绕远路也不是没有代价的，无论是在知识储备还是编程能力亦或是专注力，我和同龄的优秀人才都有着不小的差距，我仅仅只是回到了以前——就像乔尼所说，从负数回归到零——但是他们已经往前冲了好大一截路了。这一段路是我在今后的生活中不能忽视的一段距离，也是我需要用实际行动来弥补的距离。</p>
<p>在这次考研的旅途中，我要感谢实验室的环境，一同考研小伙伴的相互鼓励，父母的全力支持，女朋友的鼓励，当然最大的帮助还是熊楚原全方位无死角的引导了。今天上热搜的清华初试专业第一复试被刷的当事人妹子就是因为缺乏正确的引导而导致这样的悲剧的发生。</p>
<p>说实话，当考研成绩真正出来的时候我的内心是无比的激动的，虽然现在内心依然有些躁动，不过我已经知道了这仅仅只是个开始，后面还有更多的事情要做，我不能一直沉溺在这次的成功之中，而是要像熊楚原说的那样，继续前行，做好我应该做的事情。今后的生活，希望我能多主动去“绕远路”，认真思考，不要逃避。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.18 晚上七点二十，考研的总排名终于公布在软件学院的官网上了，我也在拟录取的名单之中。这也意味着我的考研生活终于真正意义上的尘埃落定了。&lt;/p&gt;
&lt;p&gt;这个时候按理说应该是吹一波我考研是怎么认真复习，怎么磨练意志这种内容。然而事实并不是这样，虽然不想承认，但这次考研，特
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>最短的捷径就是绕远路</title>
    <link href="https://blog.patrickcty.cc/2019/03/13/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%8D%B7%E5%BE%84%E5%B0%B1%E6%98%AF%E7%BB%95%E8%BF%9C%E8%B7%AF/"/>
    <id>https://blog.patrickcty.cc/2019/03/13/最短的捷径就是绕远路/</id>
    <published>2019-03-13T05:48:41.000Z</published>
    <updated>2019-05-03T03:32:27.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.jnugeek.cn/image/mangas/3992.jpeg" alt="image"></p>
<p>“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大陆的期间，我一直都遵行着这个原则。也因为多亏有你陪伴，我才得以跨越这条漫漫长路。”  ——杰洛·齐贝林</p>
<p>杰洛的 Lesson 5 到底是什么意思，在看漫画的时候我就不明白，在之后这个问题又浮上我的心头，并又困扰了我许久。在参考了其他人的理解并结合自己的思考之后，我终于有了些端倪。</p>
<p>最令我困惑的就是杰洛的“在横跨这片大陆的期间，我一直都遵行着这个原则”这句话了。众所周知，杰洛在这次 SBR 大赛之中，从来都是抄捷径走。但实际上，这些所谓的捷径，或许就是“远路”。怎么理解呢？尽管这些路在距离上是最短的，但每一次都伴随着巨大的风险与挑战，稍有不慎就直接丧失比赛资格，输掉全盘的比赛了。所以这些道路尽管读作捷径，但是却写作需要勇气、果断与智慧的远路。也正是因为这样的“绕远路”，杰洛才能在比赛中拔得头筹。他没有波克洛克的强运，但他就是凭自己的努力，取得了领先的地位。</p>
<p><img src="https://static.jnugeek.cn/image/mangas/v2-f05fc60b0d4c75e3e4c01c143170a9c1_hd.jpg" alt="image"></p>
<p>纵观整部 SBR，我最喜欢的角色就是杰洛，一个追寻答案的人，一个良师益友。这部 SBR 我看的还是太匆忙，下次观看的时候我要专注于杰洛与乔尼的成长之上。</p>
<p>绕远路就是最短的捷径，可惜这个道理我没有早点领悟。</p>
<p>3.15</p>
<p>今天在思考中，我对这句话又有了新的理解。</p>
<p>一直以来，我都是一个喜欢抄近道的人，具体说来就是尽量的偷懒。不愿意去深入思考，不愿意去深入查找资料，于是就自己作出了很多让人后悔的决定。正是因为我大学生活之中抄捷径太多了，所以现在落到了一个尴尬的境地。和我比起来，熊楚原就是一个绕远路的人。于是现在的结果就是，熊楚原不仅比我有着更扎实同时更广的专业知识，而且在思想深度上也是我所不能企及的。</p>
<p>在编程方面，我坚信的一点就是“不要重复造轮子”，但是这句话是有适用对象的——是对那些对相关方面较为熟悉的人来说的。而对于接触一个领域的新手来说，造轮子的过程就是一个熟悉的过程，当你能自己独立地造出几个轮子，就说明你对这个领域已经有相当程度的了解了，这时候如果要开发一个项目或者工程的话就可以顺利地使用别人已经造好的轮子了。要不然可能会在你想不到的地方掉进坑，耗费更多的时间。很多时候一个简单的功能我宁可花很多时间来找相关的模块也不愿意自己动手实现一下——就算只有一行代码的事，想想真的有点本末倒置了。</p>
<p>一直以来在抄捷径的过程中，我饶了很多路，真的太讽刺了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.jnugeek.cn/image/mangas/3992.jpeg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;“我在这场 SBR 大赛中，总是尝试抄最短的捷径走，但是最短的捷径就是绕远路，绕远路才是我的最短捷径。在横跨这片大
    
    </summary>
    
      <category term="漫画" scheme="https://blog.patrickcty.cc/categories/%E6%BC%AB%E7%94%BB/"/>
    
    
      <category term="JOJO 的奇妙冒险" scheme="https://blog.patrickcty.cc/tags/JOJO-%E7%9A%84%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A9/"/>
    
      <category term="漫画" scheme="https://blog.patrickcty.cc/tags/%E6%BC%AB%E7%94%BB/"/>
    
      <category term="Steel Ball Run" scheme="https://blog.patrickcty.cc/tags/Steel-Ball-Run/"/>
    
  </entry>
  
  <entry>
    <title>3.12随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/12/3-12%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/12/3-12随想/</id>
    <published>2019-03-12T01:13:46.000Z</published>
    <updated>2019-03-12T01:33:42.708Z</updated>
    
    <content type="html"><![CDATA[<p>前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。</p>
<p>文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人们在不需要受苦的时候去追求吃苦，那就是一种非常害人的思想了。</p>
<p>在一些影视剧里面，常常会出现“忆苦思甜”的场景：一家人坐在餐桌上，吃着菜杆子，讲述着以前的苦日子。从那个苦年代过来的人非常吃这一套，而且这样的氛围真真切切能让他们回忆起之前的经历，不过对于他们的子女，这就是一顿难吃的饭以及一些不知所云的经历。忆苦思甜不是这么来的，在优渥环境中长大的人是无法想象那种艰难的情景的，你也别想他们能从中学到珍惜现在。</p>
<p>要让他们珍惜当下，培养他们的同理心，最好的方法就是实践。有条件的话可以去偏远山区去探望那里的儿童，让子女亲自把物资交给他们，让他们亲自感受一下安稳的生活是并不是理所当然；即使去不了偏远山区也可以去孤儿院这些地方去看看。形式从来都没那么重要，重要的是一种真真切切的感情，你说这样就比吃菜杆子更加的苦吗？完全没有啊！但这样的效果却比吃菜杆子来的不知道有多好，甚至还可以在回程的路上，在他们还没有回到他们熟悉的舒服环境之前，再给他们讲讲过去的苦日子，这样一来就能让他们有更深的感触。</p>
<p>最后我想说的是，很多人的吃苦就是一种假把式，用来麻痹自己，让自己心安理得，真正是因为懒还是因为别的什么的原因个人自己心里都有数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天看了《人性的逆转》，今天看了《体验生活》，这两者在一个方面有类似点，就是吃苦。&lt;/p&gt;
&lt;p&gt;文章中指出，人们常常把吃苦当做是一种宝贵的精神财富，是一种获取收益的必要条件。如果把这当做一种自我安慰，来度过艰难的岁月，那我觉得无可厚非；但如果把这当成一种真理进行鼓吹，让人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试准备指二零零七到二零一二上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/09/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E6%8C%87%E4%BA%8C%E9%9B%B6%E9%9B%B6%E4%B8%83%E5%88%B0%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%BA%8C%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/09/复试准备指二零零七到二零一二上机题/</id>
    <published>2019-03-09T03:21:35.000Z</published>
    <updated>2019-03-09T03:21:51.633Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程输出 出列编号的序列。</li>
</ol>
<p>例：</p>
<p>若 N=3,C=1,则出列编号的序列为 1，2，3</p>
<p>若 N=3,C=2,则出列编号的序列为 2，1，3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n, c;</div><div class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;</div><div class="line">        int out[1000] = &#123;0&#125;;</div><div class="line">        int cnt = n;  // 没有出列的人数</div><div class="line">        int num = 1;  // 报数</div><div class="line">        int no = 0;  // 排列编号</div><div class="line">        while (cnt) &#123;</div><div class="line">            if (out[no] == 1) &#123;</div><div class="line">                no = (no + 1) % n;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            if (num == c) &#123;</div><div class="line">                cout &lt;&lt; no + 1 &lt;&lt; &apos; &apos;;</div><div class="line">                out[no] = 1;</div><div class="line">                num = 1;</div><div class="line">                cnt--;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                num++;</div><div class="line">            &#125;</div><div class="line">            no = (no + 1) % n;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>输入一个循环数组（数组的最后一个元素的下一元素为数组的第一个元素），依次打印出 数组中所有元素的下一个比这个元素更大的值（按数组下标大小搜寻，可以循环），如果不 存在更大的元素，打印-1。</li>
</ol>
<p>例：</p>
<p>输入：</p>
<p>6</p>
<p>1 2 1 6 3 4</p>
<p>输出：2 6 6 -1 4 6 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    int n;</div><div class="line">    int a[1000];</div><div class="line">    while (cin &gt;&gt; n) &#123;</div><div class="line">        int mmax = -1;</div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            cin &gt;&gt; a[i];</div><div class="line">            if (a[i] &gt; mmax) &#123;</div><div class="line">                mmax = a[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; n; ++i) &#123;</div><div class="line">            if (a[i] == mmax) &#123;</div><div class="line">                cout &lt;&lt; -1 &lt;&lt; &apos; &apos;;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            int next = (i + 1) % n;</div><div class="line">            while (1) &#123;</div><div class="line">                if (a[i] &lt; a[next]) &#123;</div><div class="line">                    cout &lt;&lt; a[next] &lt;&lt; &apos; &apos;;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                next = (next + 1) % n;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;一群人（排列的编号从 1 到 N，N 可以设定）围成一圈，按一定规则出列。剩余的人仍然围成一圈，出列规则是顺着 1 到 N 的方向对圈内的人从 1 到 C 记数（C 可以设定）。圈内 记数为 C 的人出列。剩余的人重新计数。按上述规则，让圈内所有的人出列。请编程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试准备之二零一三上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E4%B8%89%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试准备之二零一三上机题/</id>
    <published>2019-03-07T13:46:47.000Z</published>
    <updated>2019-03-07T13:47:08.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>输出 100-1000 的所有平方回文数。</li>
</ol>
<p>平分回文数字是满足下列条件的整数：</p>
<p>（1）从左读与从右读都是一样的。</p>
<p>（2）为某一个数的平方。</p>
<p>例：121 是平方回文数。</p>
<ol>
<li>编程解决“八皇后问题”：即在一个 8*8 的矩形格子中排放 8 个皇后，要满足的条件包 括：任意两个皇后不能在同一行，同一列，也不能在同一条对角线上。</li>
</ol>
<p>要求编程给出解的个数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool is_huiwen(int num) &#123;</div><div class="line">    int x = num % 10;</div><div class="line">    int y = num / 100;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt; 1000; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; is_huiwen(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[8][8] = &#123;0&#125;;</div><div class="line">int col_flags[8] = &#123;0&#125;;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void queen(int row) &#123;</div><div class="line">    if (row == 8) &#123;</div><div class="line">        cnt++;</div><div class="line">        for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 8; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 8; ++i) &#123;</div><div class="line">        // 纵列上没有皇后</div><div class="line">        if (col_flags[i] == 1) continue;</div><div class="line">        // 左斜对角线上没有皇后</div><div class="line">        int flag = 0;</div><div class="line">        for (int j = 1; j + i &lt; 8; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i + j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        flag = 0;</div><div class="line">        // 右斜对角线没有皇后</div><div class="line">        for (int j = 1; j &lt;= i; ++j) &#123;</div><div class="line">            if (row - j &gt;= 0) &#123;</div><div class="line">                if (arr[row - j][i - j] != 0) &#123;</div><div class="line">                    flag = 1;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (flag == 1) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        arr[row][i] = 1;</div><div class="line">        col_flags[i] = 1;</div><div class="line">        queen(row + 1);</div><div class="line">        arr[row][i] = 0;</div><div class="line">        col_flags[i] = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    queen(0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;输出 100-1000 的所有平方回文数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平分回文数字是满足下列条件的整数：&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之二零一四上机题</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E4%BA%8C%E9%9B%B6%E4%B8%80%E5%9B%9B%E4%B8%8A%E6%9C%BA%E9%A2%98/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之二零一四上机题/</id>
    <published>2019-03-07T13:08:48.000Z</published>
    <updated>2019-03-07T13:09:10.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。</li>
</ol>
<p>（1）完全平方数。</p>
<p>（2）含有两位数字相同。</p>
<p>例：144，676…</p>
<ol>
<li>输入一串字符串，把下标为奇数的小写字母(从 0 开始编号)转换为大写字母。</li>
</ol>
<p>输出转换后的字符串。</p>
<h2 id="代码分别如下"><a href="#代码分别如下" class="headerlink" title="代码分别如下"></a>代码分别如下</h2><p>第一题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;cmath&gt;  // 用来求平方根</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">bool is_square(int num) &#123;</div><div class="line">    double x = sqrt(num);</div><div class="line">    int y = (int)x;</div><div class="line"></div><div class="line">    return x == y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool has_same_nums(int num) &#123;</div><div class="line">    int x = num / 100;</div><div class="line">    int y = (num - x * 100) / 10;</div><div class="line">    int z = num - x * 100 - y * 10;</div><div class="line">//    cout &lt;&lt; x &lt;&lt; &apos; &apos; &lt;&lt; y &lt;&lt; &apos; &apos; &lt;&lt; z;</div><div class="line"></div><div class="line">    return x == y || x == z || y == z;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    for (int i = 100; i &lt;= 999; ++i) &#123;</div><div class="line">        if (is_square(i) &amp;&amp; has_same_nums(i)) &#123;</div><div class="line">            cout &lt;&lt; i &lt;&lt; &apos; &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">    string str;</div><div class="line">    int interval = &apos;a&apos; - &apos;A&apos;;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (i % 2 == 1) continue;</div><div class="line">            if (str[i] - &apos;a&apos; &gt;= 0 &amp;&amp; str[i] - &apos;z&apos; &lt;= 0) &#123;</div><div class="line">                str[i] -= interval;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        cout &lt;&lt; str &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在三位整数（100 至 999）中寻找符合下列条件的整数并依次从小到大输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长连续数字</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之最长连续数字/</id>
    <published>2019-03-07T12:50:37.000Z</published>
    <updated>2019-03-07T12:50:47.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，</p>
<p>例：</p>
<p>输入：</p>
<p>ab125ff1234567#</p>
<p>输出：</p>
<p>1234567</p>
<p>开始位置为 8</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没啥好说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void longest_str(string str) &#123;</div><div class="line">    int max_len = 0, max_pos = 0;</div><div class="line">    int cur_num = 0, cur_pos = 0;</div><div class="line">    int flag = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; str.length() - 1; ++i) &#123;</div><div class="line">        // is number</div><div class="line">        if (str[i] - &apos;0&apos; &gt;= 0 &amp;&amp; str[i] - &apos;0&apos; &lt;= 9) &#123;</div><div class="line">            if (flag == 0) &#123;</div><div class="line">                flag = 1;</div><div class="line">                cur_pos = i;</div><div class="line">                cur_num = 1;</div><div class="line">            &#125; else &#123;</div><div class="line">                cur_num++;</div><div class="line">            &#125;</div><div class="line">            if (cur_num &gt; max_len) &#123;</div><div class="line">                max_len = cur_num;</div><div class="line">                max_pos = cur_pos;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;  // not number</div><div class="line">            flag = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; str.substr(max_pos, max_len) &lt;&lt; &quot; 开始位置为&quot; &lt;&lt; max_pos + 1 &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        longest_str(str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;设计一个程序，输入一个字符串以#结尾，输出此字符串中连续出现最长的数字串以及其开始的下标，&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之棒球赛</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%A3%92%E7%90%83%E8%B5%9B/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/复试上机准备之棒球赛/</id>
    <published>2019-03-07T12:35:20.000Z</published>
    <updated>2019-03-07T12:39:13.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：</p>
<ol>
<li>如果该字符串是数字：代表当轮比赛的得分情况。</li>
<li>如果该字符串是“+”：代表当轮比赛得分情况为上两轮之和。</li>
<li>如果该字符串是“C”：代表上一轮得分无效。</li>
<li>如果该字符串是“D”:代表当轮比赛得分为上一轮得分的两倍。</li>
</ol>
<p>你需要得出最后总的得分情况并返回结果。</p>
<p>例：</p>
<p>输入：52CD+</p>
<p>输出：30</p>
<p>解释：</p>
<p>第 1 轮得分 5 分，当前总共得分 5 分。</p>
<p>第 2 轮得分 2 分，当前总共得分 5+2=7 分。</p>
<p>第 3 轮取消上轮得分，当前总共得分 5 分。</p>
<p>第 4 轮获得上一轮双倍得分，当前总共得分 5+10=15 分。</p>
<p>第 5 轮获得上两轮得分之和，当前总共得分 15+5+10=30 分。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个==栈的应用==题，如果知道这一点解法就很简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"># include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    string str;</div><div class="line">    int stack[105];</div><div class="line"></div><div class="line">    while (cin &gt;&gt; str) &#123;</div><div class="line">        int top = 0;</div><div class="line">        for (int i = 0; i &lt; str.length(); ++i) &#123;</div><div class="line">            if (str[i] == &apos;C&apos;) &#123;</div><div class="line">                --top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;D&apos;) &#123;</div><div class="line">                stack[top] = 2 * stack[top - 1];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else if (str[i] == &apos;+&apos;) &#123;</div><div class="line">                stack[top] = stack[top - 1] + stack[top - 2];</div><div class="line">                ++top;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                stack[top++] = str[i] - &apos;0&apos;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int sum = 0;</div><div class="line">        for (int i = 0; i &lt; top; ++i) &#123;</div><div class="line">            sum += stack[i];</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; sum &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;第一届棒球比赛开赛啦。你现在是一名记分员，输入一个字符串数组（比赛记录情况），按如下规则计分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.7随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/07/3-7%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/07/3-7随想/</id>
    <published>2019-03-07T07:26:32.000Z</published>
    <updated>2019-03-07T07:42:51.372Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。</p>
<p>那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人们对这个国家的印象；另一方面国家的形象又能被个人的行为所影响，中国人在国外被认为素质低下，就是个人行为所产生的影响。</p>
<p>何为自我尊严呢？我和王小波想得不一样，我认为自尊就是问心无愧。古人被打板子，虽然外人看来很难看，但是如果是文死谏，我认为并没有丧失尊严；反之，皇帝老儿在殿堂之上骄纵作乐，看起来很风光，但是这就是尊严么？也不一定吧。</p>
<p>不过要说的话，很多尊严其实说白了就是面子，是给别人看的，而非问心无愧。这一套中国人是最擅长的，所以尊严这东西其实并不普遍。毕竟对于大多数人来说，过得舒服才是最重要的，只是有时候不得不追求一下所谓的尊严，因为如果你只秉持自尊的话，在这个社会上是寸步难行的。</p>
<p>王小波为了尊严不会在火车太挤的时候挤进去而且浑然无觉，但是总有人会为了回家而选择“丧失尊严”。这些其实都无关紧要，重要的是问心无愧就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看了两篇关于尊严的文章。何为尊严？这问题我还真没想过，想了半天也得不出什么答案。&lt;/p&gt;
&lt;p&gt;那就按照王小波的说法，将其划分为国家尊严和个人尊严。个人认为，国家尊严需要国家和个人的同时努力。一方面国家的形象是通过国家的整体实力来反映的，所谓整体实力，最直观的反应就是人
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>复试上机准备之跳台阶</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之跳台阶/</id>
    <published>2019-03-06T13:57:00.000Z</published>
    <updated>2019-03-06T14:01:49.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1 阶台阶，也可以跳 n-2 阶台阶……也可以跳 1 阶</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>a[1] = 1, a[2] = 2.</p>
<p>对于三级台阶，可以第一步跳三步，方法为 1；可以第一步跳两步，还剩一步，方法和 a[3 - 2] 相同；也可以第一步跳一步，还剩两步，方法和 a[3 - 1] 相同。最终结果为 1 + 1 + 2 = 4 = 2^2</p>
<p>同理 a[4] = 1 + 1 + 2 + 4 = 8 = 2^3</p>
<p>a[n] = 2^(n - 1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;超级青蛙跳台阶。一个台阶总共有 n 级，超级青蛙有能力一次跳到 n 阶台阶，也可以一 次跳 n-1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之马跳棋</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E9%A9%AC%E8%B7%B3%E6%A3%8B/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之马跳棋/</id>
    <published>2019-03-06T13:43:50.000Z</published>
    <updated>2019-03-06T14:01:53.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的位）开始跳马，能够把棋盘的格子全部都走一遍，每个格子只允许走一次。</p>
<p>（1）输出一个如图 2 的解，左上角为第一步起点。</p>
<p>（2）总共有多少解。</p>
<p>P.S 国际象棋的棋子是在格子中间的。国际象棋中的“马走日”，如下图所示，第一步为[1,1], 第二步为[2,8]或[2,12]，第三步可以是[3,5]或[3,21]等，以此类推。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个常规的回溯题，要注意的就是一共有八个走的方向，在返回的时候记得还原原本的状态值。</p>
<p>一共有 304 解，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"># include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int arr[5][5] = &#123;0&#125;;</div><div class="line">int vis_num = 1;</div><div class="line">int cnt = 0;</div><div class="line"></div><div class="line">void horse_jump(int x, int y) &#123;</div><div class="line">    // 输出走法</div><div class="line">    if (vis_num == 25) &#123;</div><div class="line">        for (int i = 0; i &lt; 5; ++i) &#123;</div><div class="line">            for (int j = 0; j &lt; 5; ++j) &#123;</div><div class="line">                cout &lt;&lt; arr[i][j] &lt;&lt; &apos; &apos;;</div><div class="line">            &#125;</div><div class="line">            cout &lt;&lt; endl;</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; endl;</div><div class="line">        cnt++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 右二下一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x + 2][y + 1] == 0) &#123;</div><div class="line">        arr[x + 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一下二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x + 1][y + 2] == 0) &#123;</div><div class="line">        arr[x + 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二上一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x - 2][y - 1] == 0) &#123;</div><div class="line">        arr[x - 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一上二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x - 1][y - 2] == 0) &#123;</div><div class="line">        arr[x - 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左二下一</div><div class="line">    if (x - 2 &gt;= 0 &amp;&amp; y + 1 &lt; 5 &amp;&amp; arr[x - 2][y + 1] == 0) &#123;</div><div class="line">        arr[x - 2][y + 1] = ++vis_num;</div><div class="line">        horse_jump(x - 2, y + 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 2][y + 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 左一下二</div><div class="line">    if (x - 1 &gt;= 0 &amp;&amp; y + 2 &lt; 5 &amp;&amp; arr[x - 1][y + 2] == 0) &#123;</div><div class="line">        arr[x - 1][y + 2] = ++vis_num;</div><div class="line">        horse_jump(x - 1, y + 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x - 1][y + 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右二上一</div><div class="line">    if (x + 2 &lt; 5 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; arr[x + 2][y - 1] == 0) &#123;</div><div class="line">        arr[x + 2][y - 1] = ++vis_num;</div><div class="line">        horse_jump(x + 2, y - 1);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 2][y - 1] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">    // 右一上二</div><div class="line">    if (x + 1 &lt; 5 &amp;&amp; y - 2 &gt;= 0 &amp;&amp; arr[x + 1][y - 2] == 0) &#123;</div><div class="line">        arr[x + 1][y - 2] = ++vis_num;</div><div class="line">        horse_jump(x + 1, y - 2);</div><div class="line">        // 重置状态</div><div class="line">        arr[x + 1][y - 2] = 0;</div><div class="line">        --vis_num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    arr[0][0] = 1;</div><div class="line">    horse_jump(0, 0);</div><div class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设国际象棋棋盘有 5*5 共 25 个格子。设计一个程序，使棋子从初始位置（棋盘编号 为 1 的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复试上机准备之最长公共子串</title>
    <link href="https://blog.patrickcty.cc/2019/03/06/%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%E5%87%86%E5%A4%87%E4%B9%8B%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <id>https://blog.patrickcty.cc/2019/03/06/复试上机准备之最长公共子串/</id>
    <published>2019-03-06T01:58:30.000Z</published>
    <updated>2019-03-06T02:50:26.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><blockquote>
<p>求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。</p>
</blockquote>
<p>输入：</p>
<p>What’re your namess?</p>
<p>My namess are your.</p>
<p>输出：</p>
<p>reyour</p>
<p>namess</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最长公共子串/序列，是动态规划中一个非常经典的题型。但我之前接触的是最长公共子序列，子序列不要求序列的元素是相邻的，而子串需要元素是相邻的。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>两个循环，把序列 B 的每个元素开始的子串和 A 的所有元素进行比较，找出所有子串，从而找出最长子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void get_sub_str(string a, string b) &#123;</div><div class="line">    int len_a = a.length();</div><div class="line">    int len_b = b.length();</div><div class="line"></div><div class="line">    int start = 0, max_len = 0;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; len_a; ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; len_b; ++j) &#123;</div><div class="line">            // 当找到相等的时候就顺着比下去，直到不相同</div><div class="line">            // 这里重新使用了一个变量 k，就不用改 i、j 了</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                int k = 1;</div><div class="line">                while (i + k &lt; len_a &amp;&amp; j + k &lt; len_b &amp;&amp; (a[i + k] == b[j + k])) &#123;</div><div class="line">                    ++k;</div><div class="line">                &#125;</div><div class="line">                if (k &gt; max_len) &#123;</div><div class="line">                    start = i;</div><div class="line">                    max_len = k;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = start; i &lt; start + max_len; ++i) &#123;</div><div class="line">        cout &lt;&lt; a[i];</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过上面这种实现只能输出第一个最长的子串，如果要输出所有最长子串，就要把所有有可能成为最长子串的子串保存下来，输出的时候再进行判断，只输出长度是最长的那些子串。</p>
<h3 id="动态规划-空间换时间"><a href="#动态规划-空间换时间" class="headerlink" title="动态规划-空间换时间"></a>动态规划-空间换时间</h3><p>我们可以用 m * n 的矩阵来存放相等的信息，如果 <code>arr[m][n] != 0</code> 则表明 <code>a[m] == b[n]</code>，子串就是斜对角线这些元素都不为零的那些位置。因此只用找最长的斜线即可。</p>
<p>为了简化找对角线的过程，我们可以让该点的元素值是左上方元素值加一，这样凭借元素值就知道序列的长度有多少了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 使用动态规划-空间换时间的方法</div><div class="line">void print_sub_str(string a, string b) &#123;</div><div class="line">    int arr[256][256] = &#123;0&#125;;</div><div class="line"></div><div class="line">    int max_len = 0;</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (a[i] == b[j]) &#123;</div><div class="line">                // 根据斜上方的元素来赋值</div><div class="line">                if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</div><div class="line">                    arr[i][j] = arr[i - 1][j - 1] + 1;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    arr[i][j] = 1;</div><div class="line">                &#125;</div><div class="line">                if (arr[i][j] &gt; max_len) &#123;</div><div class="line">                    max_len = arr[i][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 找到最有长度最长的子串</div><div class="line">    for (int i = 0; i &lt; a.length(); ++i) &#123;</div><div class="line">        for (int j = 0; j &lt; b.length(); ++j) &#123;</div><div class="line">            if (arr[i][j] == max_len) &#123;</div><div class="line">                // 要注意这里 substr 第二个参数是子串的长度！！！而非结束位置</div><div class="line">                cout &lt;&lt; b.substr(j - max_len + 1, max_len) &lt;&lt; endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是暴力法还是动态规划法都是有一定的技巧的。暴力法主要是注意一下变量是怎么安排的；动态规划法则要搞清楚是如何用时间换空间，如何减轻输出的计算量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;求 2 个字符串的最长公共子串（输出时不包含空格）,字符串长度不超过 255。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
      <category term="算法" scheme="https://blog.patrickcty.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="华科" scheme="https://blog.patrickcty.cc/tags/%E5%8D%8E%E7%A7%91/"/>
    
      <category term="考研" scheme="https://blog.patrickcty.cc/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复试" scheme="https://blog.patrickcty.cc/tags/%E5%A4%8D%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>3.5随想</title>
    <link href="https://blog.patrickcty.cc/2019/03/05/3-5%E9%9A%8F%E6%83%B3/"/>
    <id>https://blog.patrickcty.cc/2019/03/05/3-5随想/</id>
    <published>2019-03-05T08:52:36.000Z</published>
    <updated>2019-03-06T14:02:29.947Z</updated>
    
    <content type="html"><![CDATA[<p>今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。</p>
<p>文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。</p>
<p>看到这个我就想到我小学学过的一篇课文，叫做《懒惰的智慧》，其大意就是现在社会的很多发明都是人们为了“偷懒”而产生的。一些机械化的事情我们虽然能做，但真的没必要和机器去争一个高低。</p>
<p>很多程序员都有这样的一个习惯，当遇到一个十分钟就可以完成的纯重复的工作的时候，他们一般不会去选择花十分钟机械地去完成，而是可能回去选择花二十分钟写一个脚本，再花一秒钟来跑这个脚本。</p>
<p>听起来又是另一个极端是不是？但这才是人区别于其他事物的一个重要特点。虽然看起来花费了更多的时间，但是在这个过程中他们可能又接触到了一些平常没怎么用的用法，熟悉了某些新知识；而如果去做机械的工作，就不会有这样的体验了，可能还会影响到心情。当然，对于一些怕麻烦，不想折腾的人来说，即使可能只用花五分钟写脚本，他们或许也不会愿意去写脚本。（其实我有很多时候也是这样的，不过经过多次尝试之后我发现还是写脚本要更加的愉悦，无论是身体上还是心灵上。）</p>
<p>我想说的是，人要找准自己的定位，我们没必要在自己不熟悉的领域和其他的东西来较劲，做好自己的本分工作就好，在一定的约束下，怎么舒服怎么来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是非常浮躁的一天，不过看了《对中国文化的布罗代尔式考察》，还是生发了一些感触。&lt;/p&gt;
&lt;p&gt;文章中写道，我们的伦理道德要求我们能吃苦耐劳，而为了证明这一点，我们和动物甚至自然力竞争，通过和驴比能背的重量等来证明。&lt;/p&gt;
&lt;p&gt;看到这个我就想到我小学学过的一篇课文，叫
    
    </summary>
    
      <category term="日记" scheme="https://blog.patrickcty.cc/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="王小波" scheme="https://blog.patrickcty.cc/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
</feed>
